#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"IPC/Run.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN';
  package IPC::Run;
  use bytes;
  
  =pod
  
  =head1 NAME
  
  IPC::Run - system() and background procs w/ piping, redirs, ptys (Unix, Win32)
  
  =head1 SYNOPSIS
  
     ## First,a command to run:
        my @cat = qw( cat );
  
     ## Using run() instead of system():
        use IPC::Run qw( run timeout );
  
        run \@cat, \$in, \$out, \$err, timeout( 10 ) or die "cat: $?";
  
        # Can do I/O to sub refs and filenames, too:
        run \@cat, '<', "in.txt", \&out, \&err or die "cat: $?";
        run \@cat, '<', "in.txt", '>>', "out.txt", '2>>', "err.txt";
  
  
        # Redirecting using pseudo-terminals instead of pipes.
        run \@cat, '<pty<', \$in,  '>pty>', \$out_and_err;
  
     ## Scripting subprocesses (like Expect):
  
        use IPC::Run qw( start pump finish timeout );
  
        # Incrementally read from / write to scalars. 
        # $in is drained as it is fed to cat's stdin,
        # $out accumulates cat's stdout
        # $err accumulates cat's stderr
        # $h is for "harness".
        my $h = start \@cat, \$in, \$out, \$err, timeout( 10 );
  
        $in .= "some input\n";
        pump $h until $out =~ /input\n/g;
  
        $in .= "some more input\n";
        pump $h until $out =~ /\G.*more input\n/;
  
        $in .= "some final input\n";
        finish $h or die "cat returned $?";
  
        warn $err if $err; 
        print $out;         ## All of cat's output
  
     # Piping between children
        run \@cat, '|', \@gzip;
  
     # Multiple children simultaneously (run() blocks until all
     # children exit, use start() for background execution):
        run \@foo1, '&', \@foo2;
  
     # Calling \&set_up_child in the child before it executes the
     # command (only works on systems with true fork() & exec())
     # exceptions thrown in set_up_child() will be propagated back
     # to the parent and thrown from run().
        run \@cat, \$in, \$out,
           init => \&set_up_child;
  
     # Read from / write to file handles you open and close
        open IN,  '<in.txt'  or die $!;
        open OUT, '>out.txt' or die $!;
        print OUT "preamble\n";
        run \@cat, \*IN, \*OUT or die "cat returned $?";
        print OUT "postamble\n";
        close IN;
        close OUT;
  
     # Create pipes for you to read / write (like IPC::Open2 & 3).
        $h = start
           \@cat,
              '<pipe', \*IN, # may also be a lexical filehandle e.g. \my $infh
              '>pipe', \*OUT,
              '2>pipe', \*ERR 
           or die "cat returned $?";
        print IN "some input\n";
        close IN;
        print <OUT>, <ERR>;
        finish $h;
  
     # Mixing input and output modes
        run \@cat, 'in.txt', \&catch_some_out, \*ERR_LOG;
  
     # Other redirection constructs
        run \@cat, '>&', \$out_and_err;
        run \@cat, '2>&1';
        run \@cat, '0<&3';
        run \@cat, '<&-';
        run \@cat, '3<', \$in3;
        run \@cat, '4>', \$out4;
        # etc.
  
     # Passing options:
        run \@cat, 'in.txt', debug => 1;
  
     # Call this system's shell, returns TRUE on 0 exit code
     # THIS IS THE OPPOSITE SENSE OF system()'s RETURN VALUE
        run "cat a b c" or die "cat returned $?";
  
     # Launch a sub process directly, no shell.  Can't do redirection
     # with this form, it's here to behave like system() with an
     # inverted result.
        $r = run "cat a b c";
  
     # Read from a file in to a scalar
        run io( "filename", 'r', \$recv );
        run io( \*HANDLE,   'r', \$recv );
  
  =head1 DESCRIPTION
  
  IPC::Run allows you to run and interact with child processes using files, pipes,
  and pseudo-ttys.  Both system()-style and scripted usages are supported and
  may be mixed.  Likewise, functional and OO API styles are both supported and
  may be mixed.
  
  Various redirection operators reminiscent of those seen on common Unix and DOS
  command lines are provided.
  
  Before digging in to the details a few LIMITATIONS are important enough
  to be mentioned right up front:
  
  =over
  
  =item Win32 Support
  
  Win32 support is working but B<EXPERIMENTAL>, but does pass all relevant tests
  on NT 4.0.  See L</Win32 LIMITATIONS>.
  
  =item pty Support
  
  If you need pty support, IPC::Run should work well enough most of the
  time, but IO::Pty is being improved, and IPC::Run will be improved to
  use IO::Pty's new features when it is released.
  
  The basic problem is that the pty needs to initialize itself before the
  parent writes to the master pty, or the data written gets lost.  So
  IPC::Run does a sleep(1) in the parent after forking to (hopefully) give
  the child a chance to run.  This is a kludge that works well on non
  heavily loaded systems :(.
  
  ptys are not supported yet under Win32, but will be emulated...
  
  =item Debugging Tip
  
  You may use the environment variable C<IPCRUNDEBUG> to see what's going on
  under the hood:
  
     $ IPCRUNDEBUG=basic   myscript     # prints minimal debugging
     $ IPCRUNDEBUG=data    myscript     # prints all data reads/writes
     $ IPCRUNDEBUG=details myscript     # prints lots of low-level details
     $ IPCRUNDEBUG=gory    myscript     # (Win32 only) prints data moving through
                                        # the helper processes.
  
  =back
  
  We now return you to your regularly scheduled documentation.
  
  =head2 Harnesses
  
  Child processes and I/O handles are gathered in to a harness, then
  started and run until the processing is finished or aborted.
  
  =head2 run() vs. start(); pump(); finish();
  
  There are two modes you can run harnesses in: run() functions as an
  enhanced system(), and start()/pump()/finish() allow for background
  processes and scripted interactions with them.
  
  When using run(), all data to be sent to the harness is set up in
  advance (though one can feed subprocesses input from subroutine refs to
  get around this limitation). The harness is run and all output is
  collected from it, then any child processes are waited for:
  
     run \@cmd, \<<IN, \$out;
     blah
     IN
  
     ## To precompile harnesses and run them later:
     my $h = harness \@cmd, \<<IN, \$out;
     blah
     IN
  
     run $h;
  
  The background and scripting API is provided by start(), pump(), and
  finish(): start() creates a harness if need be (by calling harness())
  and launches any subprocesses, pump() allows you to poll them for
  activity, and finish() then monitors the harnessed activities until they
  complete.
  
     ## Build the harness, open all pipes, and launch the subprocesses
     my $h = start \@cat, \$in, \$out;
     $in = "first input\n";
  
     ## Now do I/O.  start() does no I/O.
     pump $h while length $in;  ## Wait for all input to go
  
     ## Now do some more I/O.
     $in = "second input\n";
     pump $h until $out =~ /second input/;
  
     ## Clean up
     finish $h or die "cat returned $?";
  
  You can optionally compile the harness with harness() prior to
  start()ing or run()ing, and you may omit start() between harness() and
  pump().  You might want to do these things if you compile your harnesses
  ahead of time.
  
  =head2 Using regexps to match output
  
  As shown in most of the scripting examples, the read-to-scalar facility
  for gathering subcommand's output is often used with regular expressions
  to detect stopping points.  This is because subcommand output often
  arrives in dribbles and drabs, often only a character or line at a time.
  This output is input for the main program and piles up in variables like
  the C<$out> and C<$err> in our examples.
  
  Regular expressions can be used to wait for appropriate output in
  several ways.  The C<cat> example in the previous section demonstrates
  how to pump() until some string appears in the output.  Here's an
  example that uses C<smb> to fetch files from a remote server:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /src:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
  Notice that we carefully clear $out after the first command/response
  cycle? That's because IPC::Run does not delete $out when we continue,
  and we don't want to trip over the old output in the second
  command/response cycle.
  
  Say you want to accumulate all the output in $out and analyze it
  afterwards.  Perl offers incremental regular expression matching using
  the C<m//gc> and pattern matching idiom and the C<\G> assertion.
  IPC::Run is careful not to disturb the current C<pos()> value for
  scalars it appends data to, so we could modify the above so as not to
  destroy $out by adding a couple of C</gc> modifiers.  The C</g> keeps us
  from tripping over the previous prompt and the C</c> keeps us from
  resetting the prior match position if the expected prompt doesn't
  materialize immediately:
  
     $h = harness \@smbclient, \$in, \$out;
  
     $in = "cd /src\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error cding to /src:\n$out" if $out =~ "ERR";
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/mgc;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $in = "quit\n";
     $h->finish;
  
     analyze( $out );
  
  When using this technique, you may want to preallocate $out to have
  plenty of memory or you may find that the act of growing $out each time
  new input arrives causes an C<O(length($out)^2)> slowdown as $out grows.
  Say we expect no more than 10,000 characters of input at the most.  To
  preallocate memory to $out, do something like:
  
     my $out = "x" x 10_000;
     $out = "";
  
  C<perl> will allocate at least 10,000 characters' worth of space, then
  mark the $out as having 0 length without freeing all that yummy RAM.
  
  =head2 Timeouts and Timers
  
  More than likely, you don't want your subprocesses to run forever, and
  sometimes it's nice to know that they're going a little slowly.
  Timeouts throw exceptions after a some time has elapsed, timers merely
  cause pump() to return after some time has elapsed.  Neither is
  reset/restarted automatically.
  
  Timeout objects are created by calling timeout( $interval ) and passing
  the result to run(), start() or harness().  The timeout period starts
  ticking just after all the child processes have been fork()ed or
  spawn()ed, and are polled for expiration in run(), pump() and finish().
  If/when they expire, an exception is thrown.  This is typically useful
  to keep a subprocess from taking too long.
  
  If a timeout occurs in run(), all child processes will be terminated and
  all file/pipe/ptty descriptors opened by run() will be closed.  File
  descriptors opened by the parent process and passed in to run() are not
  closed in this event.
  
  If a timeout occurs in pump(), pump_nb(), or finish(), it's up to you to
  decide whether to kill_kill() all the children or to implement some more
  graceful fallback.  No I/O will be closed in pump(), pump_nb() or
  finish() by such an exception (though I/O is often closed down in those
  routines during the natural course of events).
  
  Often an exception is too harsh.  timer( $interval ) creates timer
  objects that merely prevent pump() from blocking forever.  This can be
  useful for detecting stalled I/O or printing a soothing message or "."
  to pacify an anxious user.
  
  Timeouts and timers can both be restarted at any time using the timer's
  start() method (this is not the start() that launches subprocesses).  To
  restart a timer, you need to keep a reference to the timer:
  
     ## Start with a nice long timeout to let smbclient connect.  If
     ## pump or finish take too long, an exception will be thrown.
  
   my $h;
   eval {
     $h = harness \@smbclient, \$in, \$out, \$err, ( my $t = timeout 30 );
     sleep 11;  # No effect: timer not running yet
  
     start $h;
     $in = "cd /src\n";
     pump $h until ! length $in;
  
     $in = "ls\n";
     ## Now use a short timeout, since this should be faster
     $t->start( 5 );
     pump $h until ! length $in;
  
     $t->start( 10 );  ## Give smbclient a little while to shut down.
     $h->finish;
   };
   if ( $@ ) {
     my $x = $@;    ## Preserve $@ in case another exception occurs
     $h->kill_kill; ## kill it gently, then brutally if need be, or just
                     ## brutally on Win32.
     die $x;
   }
  
  Timeouts and timers are I<not> checked once the subprocesses are shut
  down; they will not expire in the interval between the last valid
  process and when IPC::Run scoops up the processes' result codes, for
  instance.
  
  =head2 Spawning synchronization, child exception propagation
  
  start() pauses the parent until the child executes the command or CODE
  reference and propagates any exceptions thrown (including exec()
  failure) back to the parent.  This has several pleasant effects: any
  exceptions thrown in the child, including exec() failure, come flying
  out of start() or run() as though they had occurred in the parent.
  
  This includes exceptions your code thrown from init subs.  In this
  example:
  
     eval {
        run \@cmd, init => sub { die "blast it! foiled again!" };
     };
     print $@;
  
  the exception "blast it! foiled again" will be thrown from the child
  process (preventing the exec()) and printed by the parent.
  
  In situations like
  
     run \@cmd1, "|", \@cmd2, "|", \@cmd3;
  
  @cmd1 will be initted and exec()ed before @cmd2, and @cmd2 before @cmd3.
  This can save time and prevent oddball errors emitted by later commands
  when earlier commands fail to execute.  Note that IPC::Run doesn't start
  any commands unless it can find the executables referenced by all
  commands.  These executables must pass both the C<-f> and C<-x> tests
  described in L<perlfunc>.
  
  Another nice effect is that init() subs can take their time doing things
  and there will be no problems caused by a parent continuing to execute
  before a child's init() routine is complete.  Say the init() routine
  needs to open a socket or a temp file that the parent wants to connect
  to; without this synchronization, the parent will need to implement a
  retry loop to wait for the child to run, since often, the parent gets a
  lot of things done before the child's first timeslice is allocated.
  
  This is also quite necessary for pseudo-tty initialization, which needs
  to take place before the parent writes to the child via pty.  Writes
  that occur before the pty is set up can get lost.
  
  A final, minor, nicety is that debugging output from the child will be
  emitted before the parent continues on, making for much clearer debugging
  output in complex situations.
  
  The only drawback I can conceive of is that the parent can't continue to
  operate while the child is being initted.  If this ever becomes a
  problem in the field, we can implement an option to avoid this behavior,
  but I don't expect it to.
  
  B<Win32>: executing CODE references isn't supported on Win32, see
  L</Win32 LIMITATIONS> for details.
  
  =head2 Syntax
  
  run(), start(), and harness() can all take a harness specification
  as input.  A harness specification is either a single string to be passed
  to the systems' shell:
  
     run "echo 'hi there'";
  
  or a list of commands, io operations, and/or timers/timeouts to execute.
  Consecutive commands must be separated by a pipe operator '|' or an '&'.
  External commands are passed in as array references or L<IPC::Run::Win32Process>
  objects.  On systems supporting fork(), Perl code may be passed in as subs:
  
     run \@cmd;
     run \@cmd1, '|', \@cmd2;
     run \@cmd1, '&', \@cmd2;
     run \&sub1;
     run \&sub1, '|', \&sub2;
     run \&sub1, '&', \&sub2;
  
  '|' pipes the stdout of \@cmd1 the stdin of \@cmd2, just like a
  shell pipe.  '&' does not.  Child processes to the right of a '&'
  will have their stdin closed unless it's redirected-to.
  
  L<IPC::Run::IO> objects may be passed in as well, whether or not
  child processes are also specified:
  
     run io( "infile", ">", \$in ), io( "outfile", "<", \$in );
        
  as can L<IPC::Run::Timer> objects:
  
     run \@cmd, io( "outfile", "<", \$in ), timeout( 10 );
  
  Commands may be followed by scalar, sub, or i/o handle references for
  redirecting
  child process input & output:
  
     run \@cmd,  \undef,            \$out;
     run \@cmd,  \$in,              \$out;
     run \@cmd1, \&in, '|', \@cmd2, \*OUT;
     run \@cmd1, \*IN, '|', \@cmd2, \&out;
  
  This is known as succinct redirection syntax, since run(), start()
  and harness(), figure out which file descriptor to redirect and how.
  File descriptor 0 is presumed to be an input for
  the child process, all others are outputs.  The assumed file
  descriptor always starts at 0, unless the command is being piped to,
  in which case it starts at 1.
  
  To be explicit about your redirects, or if you need to do more complex
  things, there's also a redirection operator syntax:
  
     run \@cmd, '<', \undef, '>',  \$out;
     run \@cmd, '<', \undef, '>&', \$out_and_err;
     run(
        \@cmd1,
           '<', \$in,
        '|', \@cmd2,
           \$out
     );
  
  Operator syntax is required if you need to do something other than simple
  redirection to/from scalars or subs, like duping or closing file descriptors
  or redirecting to/from a named file.  The operators are covered in detail
  below.
  
  After each \@cmd (or \&foo), parsing begins in succinct mode and toggles to
  operator syntax mode when an operator (ie plain scalar, not a ref) is seen.
  Once in
  operator syntax mode, parsing only reverts to succinct mode when a '|' or
  '&' is seen.
  
  In succinct mode, each parameter after the \@cmd specifies what to
  do with the next highest file descriptor. These File descriptor start
  with 0 (stdin) unless stdin is being piped to (C<'|', \@cmd>), in which
  case they start with 1 (stdout).  Currently, being on the left of
  a pipe (C<\@cmd, \$out, \$err, '|'>) does I<not> cause stdout to be
  skipped, though this may change since it's not as DWIMerly as it
  could be.  Only stdin is assumed to be an
  input in succinct mode, all others are assumed to be outputs.
  
  If no piping or redirection is specified for a child, it will inherit
  the parent's open file handles as dictated by your system's
  close-on-exec behavior and the $^F flag, except that processes after a
  '&' will not inherit the parent's stdin. Also note that $^F does not
  affect file descriptors obtained via POSIX, since it only applies to
  full-fledged Perl file handles.  Such processes will have their stdin
  closed unless it has been redirected-to.
  
  If you want to close a child processes stdin, you may do any of:
  
     run \@cmd, \undef;
     run \@cmd, \"";
     run \@cmd, '<&-';
     run \@cmd, '0<&-';
  
  Redirection is done by placing redirection specifications immediately 
  after a command or child subroutine:
  
     run \@cmd1,      \$in, '|', \@cmd2,      \$out;
     run \@cmd1, '<', \$in, '|', \@cmd2, '>', \$out;
  
  If you omit the redirection operators, descriptors are counted
  starting at 0.  Descriptor 0 is assumed to be input, all others
  are outputs.  A leading '|' consumes descriptor 0, so this
  works as expected.
  
     run \@cmd1, \$in, '|', \@cmd2, \$out;
     
  The parameter following a redirection operator can be a scalar ref,
  a subroutine ref, a file name, an open filehandle, or a closed
  filehandle.
  
  If it's a scalar ref, the child reads input from or sends output to
  that variable:
  
     $in = "Hello World.\n";
     run \@cat, \$in, \$out;
     print $out;
  
  Scalars used in incremental (start()/pump()/finish()) applications are treated
  as queues: input is removed from input scalars, resulting in them dwindling
  to '', and output is appended to output scalars.  This is not true of 
  harnesses run() in batch mode.
  
  It's usually wise to append new input to be sent to the child to the input
  queue, and you'll often want to zap output queues to '' before pumping.
  
     $h = start \@cat, \$in;
     $in = "line 1\n";
     pump $h;
     $in .= "line 2\n";
     pump $h;
     $in .= "line 3\n";
     finish $h;
  
  The final call to finish() must be there: it allows the child process(es)
  to run to completion and waits for their exit values.
  
  =head1 OBSTINATE CHILDREN
  
  Interactive applications are usually optimized for human use.  This
  can help or hinder trying to interact with them through modules like
  IPC::Run.  Frequently, programs alter their behavior when they detect
  that stdin, stdout, or stderr are not connected to a tty, assuming that
  they are being run in batch mode.  Whether this helps or hurts depends
  on which optimizations change.  And there's often no way of telling
  what a program does in these areas other than trial and error and
  occasionally, reading the source.  This includes different versions
  and implementations of the same program.
  
  All hope is not lost, however.  Most programs behave in reasonably
  tractable manners, once you figure out what it's trying to do.
  
  Here are some of the issues you might need to be aware of.
  
  =over
  
  =item *
  
  fflush()ing stdout and stderr
  
  This lets the user see stdout and stderr immediately.  Many programs
  undo this optimization if stdout is not a tty, making them harder to
  manage by things like IPC::Run.
  
  Many programs decline to fflush stdout or stderr if they do not
  detect a tty there.  Some ftp commands do this, for instance.
  
  If this happens to you, look for a way to force interactive behavior,
  like a command line switch or command.  If you can't, you will
  need to use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  false prompts
  
  Interactive programs generally do not guarantee that output from user
  commands won't contain a prompt string.  For example, your shell prompt
  might be a '$', and a file named '$' might be the only file in a directory
  listing.
  
  This can make it hard to guarantee that your output parser won't be fooled
  into early termination of results.
  
  To help work around this, you can see if the program can alter it's 
  prompt, and use something you feel is never going to occur in actual
  practice.
  
  You should also look for your prompt to be the only thing on a line:
  
     pump $h until $out =~ /^<SILLYPROMPT>\s?\z/m;
  
  (use C<(?!\n)\Z> in place of C<\z> on older perls).
  
  You can also take the approach that IPC::ChildSafe takes and emit a
  command with known output after each 'real' command you issue, then
  look for this known output.  See new_appender() and new_chunker() for
  filters that can help with this task.
  
  If it's not convenient or possibly to alter a prompt or use a known
  command/response pair, you might need to autodetect the prompt in case
  the local version of the child program is different then the one
  you tested with, or if the user has control over the look & feel of
  the prompt.
  
  =item *
  
  Refusing to accept input unless stdin is a tty.
  
  Some programs, for security reasons, will only accept certain types
  of input from a tty.  su, notable, will not prompt for a password unless
  it's connected to a tty.
  
  If this is your situation, use a pseudo terminal ('<pty<' and '>pty>').
  
  =item *
  
  Not prompting unless connected to a tty.
  
  Some programs don't prompt unless stdin or stdout is a tty.  See if you can
  turn prompting back on.  If not, see if you can come up with a command that
  you can issue after every real command and look for it's output, as
  IPC::ChildSafe does.   There are two filters included with IPC::Run that
  can help with doing this: appender and chunker (see new_appender() and
  new_chunker()).
  
  =item *
  
  Different output format when not connected to a tty.
  
  Some commands alter their formats to ease machine parsability when they
  aren't connected to a pipe.  This is actually good, but can be surprising.
  
  =back
  
  =head1 PSEUDO TERMINALS
  
  On systems providing pseudo terminals under /dev, IPC::Run can use IO::Pty
  (available on CPAN) to provide a terminal environment to subprocesses.
  This is necessary when the subprocess really wants to think it's connected
  to a real terminal.
  
  =head2 CAVEATS
  
  Pseudo-terminals are not pipes, though they are similar.  Here are some
  differences to watch out for.
  
  =over
  
  =item Echoing
  
  Sending to stdin will cause an echo on stdout, which occurs before each
  line is passed to the child program.  There is currently no way to
  disable this, although the child process can and should disable it for
  things like passwords.
  
  =item Shutdown
  
  IPC::Run cannot close a pty until all output has been collected.  This
  means that it is not possible to send an EOF to stdin by half-closing
  the pty, as we can when using a pipe to stdin.
  
  This means that you need to send the child process an exit command or
  signal, or run() / finish() will time out.  Be careful not to expect a
  prompt after sending the exit command.
  
  =item Command line editing
  
  Some subprocesses, notable shells that depend on the user's prompt
  settings, will reissue the prompt plus the command line input so far
  once for each character.
  
  =item '>pty>' means '&>pty>', not '1>pty>'
  
  The pseudo terminal redirects both stdout and stderr unless you specify
  a file descriptor.  If you want to grab stderr separately, do this:
  
     start \@cmd, '<pty<', \$in, '>pty>', \$out, '2>', \$err;
  
  =item stdin, stdout, and stderr not inherited
  
  Child processes harnessed to a pseudo terminal have their stdin, stdout,
  and stderr completely closed before any redirection operators take
  effect.  This casts off the bonds of the controlling terminal.  This is
  not done when using pipes.
  
  Right now, this affects all children in a harness that has a pty in use,
  even if that pty would not affect a particular child.  That's a bug and
  will be fixed.  Until it is, it's best not to mix-and-match children.
  
  =back
  
  =head2 Redirection Operators
  
     Operator       SHNP   Description
     ========       ====   ===========
     <, N<          SHN    Redirects input to a child's fd N (0 assumed)
  
     >, N>          SHN    Redirects output from a child's fd N (1 assumed)
     >>, N>>        SHN    Like '>', but appends to scalars or named files
     >&, &>         SHN    Redirects stdout & stderr from a child process
  
     <pty, N<pty    S      Like '<', but uses a pseudo-tty instead of a pipe
     >pty, N>pty    S      Like '>', but uses a pseudo-tty instead of a pipe
  
     N<&M                  Dups input fd N to input fd M
     M>&N                  Dups output fd N to input fd M
     N<&-                  Closes fd N
  
     <pipe, N<pipe     P   Pipe opens H for caller to read, write, close.
     >pipe, N>pipe     P   Pipe opens H for caller to read, write, close.
                        
  'N' and 'M' are placeholders for integer file descriptor numbers.  The
  terms 'input' and 'output' are from the child process's perspective.
  
  The SHNP field indicates what parameters an operator can take:
  
     S: \$scalar or \&function references.  Filters may be used with
        these operators (and only these).
     H: \*HANDLE or IO::Handle for caller to open, and close
     N: "file name".
     P: \*HANDLE or lexical filehandle opened by IPC::Run as the parent end of a pipe, but read
        and written to and closed by the caller (like IPC::Open3).
  
  =over
  
  =item Redirecting input: [n]<, [n]<pipe
  
  You can input the child reads on file descriptor number n to come from a
  scalar variable, subroutine, file handle, or a named file.  If stdin
  is not redirected, the parent's stdin is inherited.
  
     run \@cat, \undef          ## Closes child's stdin immediately
        or die "cat returned $?"; 
  
     run \@cat, \$in;
  
     run \@cat, \<<TOHERE;
     blah
     TOHERE
  
     run \@cat, \&input;       ## Calls &input, feeding data returned
                                ## to child's.  Closes child's stdin
                                ## when undef is returned.
  
  Redirecting from named files requires you to use the input
  redirection operator:
  
     run \@cat, '<.profile';
     run \@cat, '<', '.profile';
  
     open IN, "<foo";
     run \@cat, \*IN;
     run \@cat, *IN{IO};
  
  The form used second example here is the safest,
  since filenames like "0" and "&more\n" won't confuse &run:
  
  You can't do either of
  
     run \@a, *IN;      ## INVALID
     run \@a, '<', *IN; ## BUGGY: Reads file named like "*main::A"
     
  because perl passes a scalar containing a string that
  looks like "*main::A" to &run, and &run can't tell the difference
  between that and a redirection operator or a file name.  &run guarantees
  that any scalar you pass after a redirection operator is a file name.
  
  If your child process will take input from file descriptors other
  than 0 (stdin), you can use a redirection operator with any of the
  valid input forms (scalar ref, sub ref, etc.):
  
     run \@cat, '3<', \$in3;
  
  When redirecting input from a scalar ref, the scalar ref is
  used as a queue.  This allows you to use &harness and pump() to
  feed incremental bits of input to a coprocess.  See L</Coprocesses>
  below for more information.
  
  The <pipe operator opens the write half of a pipe on the filehandle
  glob reference it takes as an argument:
  
     $h = start \@cat, '<pipe', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  Unlike the other '<' operators, IPC::Run does nothing further with
  it: you are responsible for it.  The previous example is functionally
  equivalent to:
  
     pipe( \*R, \*IN ) or die $!;
     $h = start \@cat, '<', \*IN;
     print IN "hello world\n";
     pump $h;
     close IN;
     finish $h;
  
  This is like the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Redirecting output: [n]>, [n]>>, [n]>&[m], [n]>pipe
  
  You can redirect any output the child emits
  to a scalar variable, subroutine, file handle, or file name.  You
  can have &run truncate or append to named files or scalars.  If
  you are redirecting stdin as well, or if the command is on the
  receiving end of a pipeline ('|'), you can omit the redirection
  operator:
  
     @ls = ( 'ls' );
     run \@ls, \undef, \$out
        or die "ls returned $?"; 
  
     run \@ls, \undef, \&out;  ## Calls &out each time some output
                                ## is received from the child's 
                                ## when undef is returned.
  
     run \@ls, \undef, '2>ls.err';
     run \@ls, '2>', 'ls.err';
  
  The two parameter form guarantees that the filename
  will not be interpreted as a redirection operator:
  
     run \@ls, '>', "&more";
     run \@ls, '2>', ">foo\n";
  
  You can pass file handles you've opened for writing:
  
     open( *OUT, ">out.txt" );
     open( *ERR, ">err.txt" );
     run \@cat, \*OUT, \*ERR;
  
  Passing a scalar reference and a code reference requires a little
  more work, but allows you to capture all of the output in a scalar
  or each piece of output by a callback:
  
  These two do the same things:
  
     run( [ 'ls' ], '2>', sub { $err_out .= $_[0] } );
  
  does the same basic thing as:
  
     run( [ 'ls' ], '2>', \$err_out );
  
  The subroutine will be called each time some data is read from the child.
  
  The >pipe operator is different in concept than the other '>' operators,
  although it's syntax is similar:
  
     $h = start \@cat, $in, '>pipe', \*OUT, '2>pipe', \*ERR;
     $in = "hello world\n";
     finish $h;
     print <OUT>;
     print <ERR>;
     close OUT;
     close ERR;
  
  causes two pipe to be created, with one end attached to cat's stdout
  and stderr, respectively, and the other left open on OUT and ERR, so
  that the script can manually
  read(), select(), etc. on them.  This is like
  the behavior of IPC::Open2 and IPC::Open3.
  
  B<Win32>: The handle returned is actually a socket handle, so you can
  use select() on it.
  
  =item Duplicating output descriptors: >&m, n>&m
  
  This duplicates output descriptor number n (default is 1 if n is omitted)
  from descriptor number m.
  
  =item Duplicating input descriptors: <&m, n<&m
  
  This duplicates input descriptor number n (default is 0 if n is omitted)
  from descriptor number m
  
  =item Closing descriptors: <&-, 3<&-
  
  This closes descriptor number n (default is 0 if n is omitted).  The
  following commands are equivalent:
  
     run \@cmd, \undef;
     run \@cmd, '<&-';
     run \@cmd, '<in.txt', '<&-';
  
  Doing
  
     run \@cmd, \$in, '<&-';    ## SIGPIPE recipe.
  
  is dangerous: the parent will get a SIGPIPE if $in is not empty.
  
  =item Redirecting both stdout and stderr: &>, >&, &>pipe, >pipe&
  
  The following pairs of commands are equivalent:
  
     run \@cmd, '>&', \$out;       run \@cmd, '>', \$out,     '2>&1';
     run \@cmd, '>&', 'out.txt';   run \@cmd, '>', 'out.txt', '2>&1';
  
  etc.
  
  File descriptor numbers are not permitted to the left or the right of
  these operators, and the '&' may occur on either end of the operator.
  
  The '&>pipe' and '>pipe&' variants behave like the '>pipe' operator, except
  that both stdout and stderr write to the created pipe.
  
  =item Redirection Filters
  
  Both input redirections and output redirections that use scalars or
  subs as endpoints may have an arbitrary number of filter subs placed
  between them and the child process.  This is useful if you want to
  receive output in chunks, or if you want to massage each chunk of
  data sent to the child.  To use this feature, you must use operator
  syntax:
  
     run(
        \@cmd
           '<', \&in_filter_2, \&in_filter_1, $in,
           '>', \&out_filter_1, \&in_filter_2, $out,
     );
  
  This capability is not provided for IO handles or named files.
  
  Two filters are provided by IPC::Run: appender and chunker.  Because
  these may take an argument, you need to use the constructor functions
  new_appender() and new_chunker() rather than using \& syntax:
  
     run(
        \@cmd
           '<', new_appender( "\n" ), $in,
           '>', new_chunker, $out,
     );
  
  =back
  
  =head2 Just doing I/O
  
  If you just want to do I/O to a handle or file you open yourself, you
  may specify a filehandle or filename instead of a command in the harness
  specification:
  
     run io( "filename", '>', \$recv );
  
     $h = start io( $io, '>', \$recv );
  
     $h = harness \@cmd, '&', io( "file", '<', \$send );
  
  =head2 Options
  
  Options are passed in as name/value pairs:
  
     run \@cat, \$in, debug => 1;
  
  If you pass the debug option, you may want to pass it in first, so you
  can see what parsing is going on:
  
     run debug => 1, \@cat, \$in;
  
  =over
  
  =item debug
  
  Enables debugging output in parent and child.  Debugging info is emitted
  to the STDERR that was present when IPC::Run was first C<use()>ed (it's
  C<dup()>ed out of the way so that it can be redirected in children without
  having debugging output emitted on it).
  
  =back
  
  =head1 RETURN VALUES
  
  harness() and start() return a reference to an IPC::Run harness.  This is
  blessed in to the IPC::Run package, so you may make later calls to
  functions as members if you like:
  
     $h = harness( ... );
     $h->start;
     $h->pump;
     $h->finish;
  
     $h = start( .... );
     $h->pump;
     ...
  
  Of course, using method call syntax lets you deal with any IPC::Run
  subclasses that might crop up, but don't hold your breath waiting for
  any.
  
  run() and finish() return TRUE when all subcommands exit with a 0 result
  code.  B<This is the opposite of perl's system() command>.
  
  All routines raise exceptions (via die()) when error conditions are
  recognized.  A non-zero command result is not treated as an error
  condition, since some commands are tests whose results are reported 
  in their exit codes.
  
  =head1 ROUTINES
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Exporter ();
  use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20231003.0';
      @ISA     = qw{ Exporter };
  
      ## We use @EXPORT for the end user's convenience: there's only one function
      ## exported, it's homonymous with the module, it's an unusual name, and
      ## it can be suppressed by "use IPC::Run ();".
      @FILTER_IMP = qw( input_avail get_more_input );
      @FILTERS    = qw(
        new_appender
        new_chunker
        new_string_source
        new_string_sink
      );
      @API = qw(
        run
        harness start pump pumpable finish
        signal kill_kill reap_nb
        io timer timeout
        close_terminal
        binary
      );
      @EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
      %EXPORT_TAGS = (
          'filter_imp' => \@FILTER_IMP,
          'all'        => \@EXPORT_OK,
          'filters'    => \@FILTERS,
          'api'        => \@API,
      );
  
  }
  
  use strict;
  use warnings;
  use IPC::Run::Debug;
  use Exporter;
  use Fcntl;
  use POSIX ();
  
  BEGIN {
      if ( $] < 5.008 ) { require Symbol; }
  }
  use Carp;
  use File::Spec ();
  use IO::Handle;
  require IPC::Run::IO;
  require IPC::Run::Timer;
  
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  BEGIN {
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; 1;"
            or ( $@ && die )
            or die "$!";
      }
      else {
          eval "use File::Basename; 1;" or die $!;
      }
  }
  
  sub input_avail();
  sub get_more_input();
  
  ###############################################################################
  
  ##
  ## Error constants, not too locale-dependent
  use vars qw( $_EIO $_EAGAIN );
  use Errno qw(   EIO   EAGAIN );
  
  BEGIN {
      local $!;
      $!       = EIO;
      $_EIO    = qr/^$!/;
      $!       = EAGAIN;
      $_EAGAIN = qr/^$!/;
  }
  
  ##
  ## State machine states, set in $self->{STATE}
  ##
  ## These must be in ascending order numerically
  ##
  sub _newed()     { 0 }
  sub _harnessed() { 1 }
  sub _finished()  { 2 }    ## _finished behave almost exactly like _harnessed
  sub _started()   { 3 }
  
  ##
  ## Which fds have been opened in the parent.  This may have extra fds, since
  ## we aren't all that rigorous about closing these off, but that's ok.  This
  ## is used on Unixish OSs to close all fds in the child that aren't needed
  ## by that particular child.
  my %fds;
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  
  use vars qw( $cur_self );
  
  sub _debug_fd {
      return fileno STDERR unless defined $cur_self;
  
      if ( _debugging && !defined $cur_self->{DEBUG_FD} ) {
          my $fd = select STDERR;
          $| = 1;
          select $fd;
          $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
          _debug("debugging fd is $cur_self->{DEBUG_FD}\n")
            if _debugging_details;
      }
  
      return fileno STDERR unless defined $cur_self->{DEBUG_FD};
  
      return $cur_self->{DEBUG_FD};
  }
  
  sub DESTROY {
      ## We absolutely do not want to do anything else here.  We are likely
      ## to be in a child process and we don't want to do things like kill_kill
      ## ourself or cause other destruction.
      my IPC::Run $self = shift;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  
      for my $kid ( @{$self->{KIDS}} ) {
          for my $op ( @{$kid->{OPS}} ) {
              delete $op->{FILTERS};
          }
      }
  }
  
  ##
  ## Support routines (NOT METHODS)
  ##
  my %cmd_cache;
  
  sub _search_path {
      my ($cmd_name) = @_;
      if ( File::Spec->file_name_is_absolute($cmd_name) && -x $cmd_name ) {
          _debug "'", $cmd_name, "' is absolute"
            if _debugging_details;
          return $cmd_name;
      }
  
      my $dirsep = (
            Win32_MODE     ? '[/\\\\]'
          : $^O =~ /MacOS/ ? ':'
          : $^O =~ /VMS/   ? '[\[\]]'
          :                  '/'
      );
  
      if (   Win32_MODE
          && ( $cmd_name =~ /$dirsep/ )
          && ( $cmd_name !~ m!\.[^\\/\.]+$! ) ) {
  
          _debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;
          for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
              my $name = "$cmd_name$_";
              $cmd_name = $name, last if -f $name && -x _;
          }
          _debug "cmd_name is now '$cmd_name'" if _debugging;
      }
  
      if ( $cmd_name =~ /($dirsep)/ ) {
          _debug "'$cmd_name' contains '$1'" if _debugging;
          croak "file not found: $cmd_name"    unless -e $cmd_name;
          croak "not a file: $cmd_name"        unless -f $cmd_name;
          croak "permission denied: $cmd_name" unless -x $cmd_name;
          return $cmd_name;
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
            if _debugging;
          return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
          _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
            if _debugging;
          delete $cmd_cache{$cmd_name};
      }
  
      my @searched_in;
  
      ## This next bit is Unix/Win32 specific, unfortunately.
      ## There's been some conversation about extending File::Spec to provide
      ## a universal interface to PATH, but I haven't seen it yet.
      my $re = Win32_MODE ? qr/;/ : qr/:/;
  
    LOOP:
      for ( split( $re, $ENV{PATH} || '', -1 ) ) {
          $_ = "." unless length $_;
          push @searched_in, $_;
  
          my $prospect = File::Spec->catfile( $_, $cmd_name );
          my @prospects;
  
          @prospects =
            ( Win32_MODE && !( -f $prospect && -x _ ) )
            ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
            : ($prospect);
  
          for my $found (@prospects) {
              if ( -f $found && -x _ ) {
                  $cmd_cache{$cmd_name} = $found;
                  last LOOP;
              }
          }
      }
  
      if ( exists $cmd_cache{$cmd_name} ) {
          _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
            if _debugging_details;
          return $cmd_cache{$cmd_name};
      }
  
      croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
  }
  
  # Translate a command or CODE reference (a $kid->{VAL}) to a list of strings
  # suitable for passing to _debug().
  sub _debugstrings {
      my $operand = shift;
      if ( !defined $operand ) {
          return '<undef>';
      }
  
      my $ref = ref $operand;
      if ( !$ref ) {
          return length $operand < 50
            ? "'$operand'"
            : join( '', "'", substr( $operand, 0, 10 ), "...'" );
      }
      elsif ( $ref eq 'ARRAY' ) {
          return (
              '[ ',
              join( " ", map /[^\w.-]/ ? "'$_'" : $_, @$operand ),
              ' ]'
          );
      }
      elsif ( UNIVERSAL::isa( $operand, 'IPC::Run::Win32Process' ) ) {
          return "$operand";
      }
      return $ref;
  }
  
  sub _empty($) { !( defined $_[0] && length $_[0] ) }
  
  ## 'safe' versions of otherwise fun things to do. See also IPC::Run::Win32Helper.
  sub _close {
      confess 'undef' unless defined $_[0];
      my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
      if (Win32_MODE) {
  
          # Perl close() or POSIX::close() on the read end of a pipe hangs if
          # another process is in a read attempt on the same pipe
          # (https://github.com/Perl/perl5/issues/19963).  Since IPC::Run creates
          # pipes and shares them with user-defined kids, it's affected.  Work
          # around that by first using dup2() to replace the FD with a non-pipe.
          # Unfortunately, for socket FDs, dup2() closes the SOCKET with
          # CloseHandle().  CloseHandle() documentation leaves its behavior
          # undefined for sockets.  However, tests on Windows Server 2022 did not
          # leak memory, leak ports, or reveal any other obvious trouble.
          #
          # No failure here is fatal.  (_close() has worked that way, either due
          # to a principle or just due to a history of callers passing closed
          # FDs.)  croak() on EMFILE would be a bad user experience.  Better to
          # proceed and hope that $fd is not a being-read pipe.
          #
          # Since start() and other user-facing methods _close() many FDs, we
          # could optimize this by opening and closing the non-pipe FD just once
          # per method call.  The overhead of this simple approach was in the
          # noise, however.
          my $nul_fd = POSIX::open 'NUL';
          if ( !defined $nul_fd ) {
              _debug "open( NUL ) = ERROR $!" if _debugging_details;
          }
          else {
              my $r = POSIX::dup2( $nul_fd, $fd );
              _debug "dup2( $nul_fd, $fd ) = ERROR $!"
                if _debugging_details && !defined $r;
              $r = POSIX::close $nul_fd;
              _debug "close( $nul_fd (NUL) ) = ERROR $!"
                if _debugging_details && !defined $r;
          }
      }
      my $r = POSIX::close $fd;
      $r = $r ? '' : " ERROR $!";
      delete $fds{$fd};
      _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
  }
  
  sub _dup {
      confess 'undef' unless defined $_[0];
      my $r = POSIX::dup( $_[0] );
      croak "$!: dup( $_[0] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup( $_[0] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _dup2_rudely {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::dup2( $_[0], $_[1] );
      croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
      $r = 0 if $r eq '0 but true';
      _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
      $fds{$r} = {};
      return $r;
  }
  
  sub _exec {
      confess 'undef passed' if grep !defined, @_;
  
      #   exec @_ or croak "$!: exec( " . join( ', ', @_ ) . " )";
      _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
  
      #   {
  ## Commented out since we don't call this on Win32.
      #      # This works around the bug where 5.6.1 complains
      #      # "Can't exec ...: No error" after an exec on NT, where
      #      # exec() is simulated and actually returns in Perl's C
      #      # code, though Perl's &exec does not...
      #      no warnings "exec";
      #
      #      # Just in case the no warnings workaround
      #      # stops being a workaround, we don't want
      #      # old values of $! causing spurious strerr()
      #      # messages to appear in the "Can't exec" message
      #      undef $!;
      exec { $_[0] } @_;
  
      #   }
      #   croak "$!: exec( " . join( ', ', map "'$_'", @_ ) . " )";
      ## Fall through so $! can be reported to parent.
  }
  
  sub _sysopen {
      confess 'undef' unless defined $_[0] && defined $_[1];
      _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
        sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
        sprintf( "O_RDWR=0x%02x ",   O_RDWR ),
        sprintf( "O_TRUNC=0x%02x ",  O_TRUNC ),
        sprintf( "O_CREAT=0x%02x ",  O_CREAT ),
        sprintf( "O_APPEND=0x%02x ", O_APPEND ),
        if _debugging_details;
      my $r = POSIX::open( $_[0], $_[1], 0666 );
      croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
      _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
        if _debugging_data;
      $fds{$r} = {};
      return $r;
  }
  
  sub _pipe {
      ## Normal, blocking write for pipes that we read and the child writes,
      ## since most children expect writes to stdout to block rather than
      ## do a partial write.
      my ( $r, $w ) = POSIX::pipe;
      croak "$!: pipe()" unless defined $r;
      _debug "pipe() = ( $r, $w ) " if _debugging_details;
      @fds{$r, $w} = ( {}, {} );
      return ( $r, $w );
  }
  
  sub _pipe_nb {
      ## For pipes that we write, unblock the write side, so we can fill a buffer
      ## and continue to select().
      ## Contributed by Borislav Deianov <borislav@ensim.com>, with minor
      ## bugfix on fcntl result by me.
      local ( *R, *W );
      my $f = pipe( R, W );
      croak "$!: pipe()" unless defined $f;
      my ( $r, $w ) = ( fileno R, fileno W );
      _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
      unless (Win32_MODE) {
          ## POSIX::fcntl doesn't take fd numbers, so gotta use Perl's and
          ## then _dup the originals (which get closed on leaving this block)
          my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
          croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
          _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
      }
      ( $r, $w ) = ( _dup($r), _dup($w) );
      _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
      return ( $r, $w );
  }
  
  sub _pty {
      require IO::Pty;
      my $pty = IO::Pty->new();
      croak "$!: pty ()" unless $pty;
      $pty->autoflush();
      $pty->blocking(0) or croak "$!: pty->blocking ( 0 )";
      _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
        if _debugging_details;
      @fds{ $pty->fileno, $pty->slave->fileno } = ( {}, {} );
      return $pty;
  }
  
  sub _read {
      confess 'undef' unless defined $_[0];
      my $s = '';
      my $r = POSIX::read( $_[0], $s, 10_000 );
      croak "$!: read( $_[0] )" if not($r) and !$!{EINTR};
      $r ||= 0;
      _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
      return $s;
  }
  
  ## A METHOD, not a function.
  sub _spawn {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      croak "Can't spawn IPC::Run::Win32Process except on Win32"
        if UNIVERSAL::isa( $kid->{VAL}, 'IPC::Run::Win32Process' );
  
      _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
      my $sync_reader_fd;
      ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
      $kid->{PID} = fork();
      croak "$! during fork" unless defined $kid->{PID};
  
      unless ( $kid->{PID} ) {
          ## _do_kid_and_exit closes sync_reader_fd since it closes all unwanted and
          ## unloved fds.
          $self->_do_kid_and_exit($kid);
      }
      _debug "fork() = ", $kid->{PID} if _debugging_details;
  
      ## Wait for kid to get to it's exec() and see if it fails.
      _close $self->{SYNC_WRITER_FD};
      my $sync_pulse = _read $sync_reader_fd;
      _close $sync_reader_fd;
  
      if ( !defined $sync_pulse || length $sync_pulse ) {
          if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
              $kid->{RESULT} = $?;
          }
          else {
              $kid->{RESULT} = -1;
          }
          $sync_pulse = "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
            unless length $sync_pulse;
          croak $sync_pulse;
      }
      return $kid->{PID};
  
  ## Wait for pty to get set up.  This is a hack until we get synchronous
  ## selects.
      if ( keys %{ $self->{PTYS} } && $IO::Pty::VERSION < 0.9 ) {
          _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
          sleep 1;
      }
  }
  
  sub _write {
      confess 'undef' unless defined $_[0] && defined $_[1];
      my $r = POSIX::write( $_[0], $_[1], length $_[1] );
      croak "$!: write( $_[0], '$_[1]' )" unless $r;
      _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
      return $r;
  }
  
  =pod
  
  =over
  
  =item run
  
  Run takes a harness or harness specification and runs it, pumping
  all input to the child(ren), closing the input pipes when no more
  input is available, collecting all output that arrives, until the
  pipes delivering output are closed, then waiting for the children to
  exit and reaping their result codes.
  
  You may think of C<run( ... )> as being like 
  
     start( ... )->finish();
  
  , though there is one subtle difference: run() does not
  set \$input_scalars to '' like finish() does.  If an exception is thrown
  from run(), all children will be killed off "gently", and then "annihilated"
  if they do not go gently (in to that dark night. sorry).
  
  If any exceptions are thrown, this does a L</kill_kill> before propagating
  them.
  
  =cut
  
  use vars qw( $in_run );    ## No, not Enron;)
  
  sub run {
      local $in_run = 1;     ## Allow run()-only optimizations.
      my IPC::Run $self = start(@_);
      my $r = eval {
          $self->{clear_ins} = 0;
          $self->finish;
      };
      if ($@) {
          my $x = $@;
          $self->kill_kill;
          die $x;
      }
      return $r;
  }
  
  =pod
  
  =item signal
  
     ## To send it a specific signal by name ("USR1"):
     signal $h, "USR1";
     $h->signal ( "USR1" );
  
  If $signal is provided and defined, sends a signal to all child processes.  Try
  not to send numeric signals, use C<"KILL"> instead of C<9>, for instance.
  Numeric signals aren't portable.
  
  Throws an exception if $signal is undef.
  
  This will I<not> clean up the harness, C<finish> it if you kill it.
  
  Normally TERM kills a process gracefully (this is what the command line utility
  C<kill> does by default), INT is sent by one of the keys C<^C>, C<Backspace> or
  C<E<lt>DelE<gt>>, and C<QUIT> is used to kill a process and make it coredump.
  
  The C<HUP> signal is often used to get a process to "restart", rereading 
  config files, and C<USR1> and C<USR2> for really application-specific things.
  
  Often, running C<kill -l> (that's a lower case "L") on the command line will
  list the signals present on your operating system.
  
  B<WARNING>: The signal subsystem is not at all portable.  We *may* offer
  to simulate C<TERM> and C<KILL> on some operating systems, submit code
  to me if you want this.
  
  B<WARNING 2>: Up to and including perl v5.6.1, doing almost anything in a
  signal handler could be dangerous.  The most safe code avoids all
  mallocs and system calls, usually by preallocating a flag before
  entering the signal handler, altering the flag's value in the
  handler, and responding to the changed value in the main system:
  
     my $got_usr1 = 0;
     sub usr1_handler { ++$got_signal }
  
     $SIG{USR1} = \&usr1_handler;
     while () { sleep 1; print "GOT IT" while $got_usr1--; }
  
  Even this approach is perilous if ++ and -- aren't atomic on your system
  (I've never heard of this on any modern CPU large enough to run perl).
  
  =cut
  
  sub signal {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      $self->_kill_kill_kill_pussycat_kill unless @_;
  
      Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
  
      my ($signal) = @_;
      croak "Undefined signal passed to signal" unless defined $signal;
      for ( grep $_->{PID} && !defined $_->{RESULT}, @{ $self->{KIDS} } ) {
          _debug "sending $signal to $_->{PID}"
            if _debugging;
          kill $signal, $_->{PID}
            or _debugging && _debug "$! sending $signal to $_->{PID}";
      }
  
      return;
  }
  
  =pod
  
  =item kill_kill
  
     ## To kill off a process:
     $h->kill_kill;
     kill_kill $h;
  
     ## To specify the grace period other than 30 seconds:
     kill_kill $h, grace => 5;
  
     ## To send QUIT instead of KILL if a process refuses to die:
     kill_kill $h, coup_d_grace => "QUIT";
  
  Sends a C<TERM>, waits for all children to exit for up to 30 seconds, then
  sends a C<KILL> to any that survived the C<TERM>.
  
  Will wait for up to 30 more seconds for the OS to successfully C<KILL> the
  processes.
  
  The 30 seconds may be overridden by setting the C<grace> option, this
  overrides both timers.
  
  The harness is then cleaned up.
  
  The doubled name indicates that this function may kill again and avoids
  colliding with the core Perl C<kill> function.
  
  Returns a 1 if the C<TERM> was sufficient, or a 0 if C<KILL> was 
  required.  Throws an exception if C<KILL> did not permit the children
  to be reaped.
  
  B<NOTE>: The grace period is actually up to 1 second longer than that
  given.  This is because the granularity of C<time> is 1 second.  Let me
  know if you need finer granularity, we can leverage Time::HiRes here.
  
  B<Win32>: Win32 does not know how to send real signals, so C<TERM> is
  a full-force kill on Win32.  Thus all talk of grace periods, etc. do
  not apply to Win32.
  
  =cut
  
  sub kill_kill {
      my IPC::Run $self = shift;
  
      my %options = @_;
      my $grace   = $options{grace};
      $grace = 30 unless defined $grace;
      ++$grace;    ## Make grace time a _minimum_
  
      my $coup_d_grace = $options{coup_d_grace};
      $coup_d_grace = "KILL" unless defined $coup_d_grace;
  
      delete $options{$_} for qw( grace coup_d_grace );
      Carp::cluck "Ignoring unknown options for kill_kill: ",
        join " ", keys %options
        if keys %options;
  
      if (Win32_MODE) {
  	# immediate brutal death for Win32
  	# TERM has unfortunate side-effects
  	$self->signal("KILL")
      }
      else {
  	$self->signal("TERM");
      }
  
      my $quitting_time = time + $grace;
      my $delay         = 0.01;
      my $accum_delay;
  
      my $have_killed_before;
  
      while () {
          ## delay first to yield to other processes
          select undef, undef, undef, $delay;
          $accum_delay += $delay;
  
          $self->reap_nb;
          last unless $self->_running_kids;
  
          if ( $accum_delay >= $grace * 0.8 ) {
              ## No point in checking until delay has grown some.
              if ( time >= $quitting_time ) {
                  if ( !$have_killed_before ) {
                      $self->signal($coup_d_grace);
                      $have_killed_before = 1;
                      $quitting_time += $grace;
                      $delay       = 0.01;
                      $accum_delay = 0;
                      next;
                  }
                  croak "Unable to reap all children, even after KILLing them";
              }
          }
  
          $delay *= 2;
          $delay = 0.5 if $delay >= 0.5;
      }
  
      $self->_cleanup;
      return $have_killed_before;
  }
  
  =pod
  
  =item harness
  
  Takes a harness specification and returns a harness.  This harness is
  blessed in to IPC::Run, allowing you to use method call syntax for
  run(), start(), et al if you like.
  
  harness() is provided so that you can pre-build harnesses if you
  would like to, but it's not required..
  
  You may proceed to run(), start() or pump() after calling harness() (pump()
  calls start() if need be).  Alternatively, you may pass your
  harness specification to run() or start() and let them harness() for
  you.  You can't pass harness specifications to pump(), though.
  
  =cut
  
  ##
  ## Notes: I've avoided handling a scalar that doesn't look like an
  ## opcode as a here document or as a filename, though I could DWIM
  ## those.  I'm not sure that the advantages outweigh the danger when
  ## the DWIMer guesses wrong.
  ##
  ## TODO: allow user to spec default shell. Hmm, globally, in the
  ## lexical scope hash, or per instance?  'Course they can do that
  ## now by using a [...] to hold the command.
  ##
  my $harness_id = 0;
  
  sub harness {
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      #   local $IPC::Run::debug = $options->{debug}
      #      if $options && defined $options->{debug};
  
      my @args;
      if ( @_ == 1 && !ref $_[0] ) {
          if (Win32_MODE) {
              my $command = $ENV{ComSpec} || 'cmd';
              @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
          }
          else {
              @args = ( [ qw( sh -c ), @_ ] );
          }
      }
      elsif ( @_ > 1 && !grep ref $_, @_ ) {
          @args = ( [@_] );
      }
      else {
          @args = map { !defined $_ ? bless(\$_, 'IPC::Run::Undef') : $_ } @_;
      }
  
      my @errs;    # Accum errors, emit them when done.
  
      my $succinct;    # set if no redir ops are required yet.  Cleared
                       # if an op is seen.
  
      my $cur_kid;     # references kid or handle being parsed
      my $next_kid_close_stdin = 0;
  
      my $assumed_fd = 0;    # fd to assume in succinct mode (no redir ops)
      my $handle_num = 0;    # 1... is which handle we're parsing
  
      my IPC::Run $self = bless {}, __PACKAGE__;
  
      local $cur_self = $self;
  
      $self->{ID}    = ++$harness_id;
      $self->{IOS}   = [];
      $self->{KIDS}  = [];
      $self->{PIPES} = [];
      $self->{PTYS}  = {};
      $self->{STATE} = _newed;
  
      if ($options) {
          $self->{$_} = $options->{$_} for keys %$options;
      }
  
      _debug "****** harnessing *****" if _debugging;
  
      my $first_parse;
      local $_;
      my $arg_count = @args;
      while (@args) {
          for ( shift @args ) {
              eval {
                  $first_parse = 1;
                  _debug( "parsing ", _debugstrings($_) ) if _debugging;
  
                REPARSE:
                  if (   ref eq 'ARRAY'
                      || UNIVERSAL::isa( $_, 'IPC::Run::Win32Process' )
                      || ( !$cur_kid && ref eq 'CODE' ) ) {
                      croak "Process control symbol ('|', '&') missing" if $cur_kid;
                      croak "Can't spawn a subroutine on Win32"
                        if Win32_MODE && ref eq "CODE";
                      $cur_kid = {
                          TYPE   => 'cmd',
                          VAL    => $_,
                          NUM    => @{ $self->{KIDS} } + 1,
                          OPS    => [],
                          PID    => '',
                          RESULT => undef,
                      };
  
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => 0,
                      } if $next_kid_close_stdin;
                      $next_kid_close_stdin = 0;
  
                      push @{ $self->{KIDS} }, $cur_kid;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
                      push @{ $self->{IOS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
                      push @{ $self->{TIMERS} }, $_;
                      $cur_kid  = undef;
                      $succinct = 1;
                  }
  
                  elsif (/^(\d*)>&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 1,
                      };
                      _debug "redirect operators now required" if _debugging_details;
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&(\d+)$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => $2,
                          KFD2 => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*)<&-$/) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'close',
                          KFD  => length $1 ? $1 : 0,
                      };
                      $succinct = !$first_parse;
                  }
  
                  elsif (/^(\d*) (<pipe)()            ()  ()  $/x
                      || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
                      || /^(\d*) (<)    ()            ()  (.*)$/x ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = $2 . $4;
  
                      my $kfd = length $1 ? $1 : 0;
  
                      my $pty_id;
                      if ( $type eq '<pty<' ) {
                          $pty_id = length $3 ? $3 : '0';
                          ## do the require here to cause early error reporting
                          require IO::Pty;
                          ## Just flag the pyt's existence for now.  It'll be
                          ## converted to a real IO::Pty by _open_pipes.
                          $self->{PTYS}->{$pty_id} = undef;
                      }
  
                      my $source = $5;
  
                      my @filters;
                      my $binmode;
  
                      unless ( length $source ) {
                          if ( !$succinct ) {
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      push @filters, shift @args;
                                  }
                              }
                          }
                          $source = shift @args;
                          croak "'$_' missing a source" if _empty $source;
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s input fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
                      }
  
                      my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $source, $binmode, @filters );
  
                      if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
                          && $type !~ /^<p(ty<|ipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                          _dont_inherit($source) if Win32_MODE;
                      }
  
                      push @{ $cur_kid->{OPS} }, $pipe;
                  }
  
                  elsif (
                         /^()   (>>?)  (&)     ()      (.*)$/x
                      || /^()   (&)    (>pipe) ()      ()  $/x
                      || /^()   (>pipe)(&)     ()      ()  $/x
                      || /^(\d*)()     (>pipe) ()      ()  $/x
                      || /^()   (&)    (>pty)  ( \w*)> ()  $/x
  ## TODO:    ||   /^()   (>pty) (\d*)> (&) ()  $/x
                      || /^(\d*)()     (>pty)  ( \w*)> ()  $/x
                      || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x
                    ) {
                      croak "No command before '$_'" unless $cur_kid;
  
                      $succinct = !$first_parse;
  
                      my $type = (
                            $2 eq '>pipe' || $3 eq '>pipe' ? '>pipe'
                          : $2 eq '>pty'  || $3 eq '>pty'  ? '>pty>'
                          :                                  '>'
                      );
                      my $kfd = length $1 ? $1 : 1;
                      my $trunc = !( $2 eq '>>' || $3 eq '>>' );
                      my $pty_id = (
                            $2 eq '>pty' || $3 eq '>pty'
                          ? length $4
                                ? $4
                                : 0
                          : undef
                      );
  
                      my $stderr_too =
                           $2 eq '&'
                        || $3 eq '&'
                        || ( !length $1 && substr( $type, 0, 4 ) eq '>pty' );
  
                      my $dest = $5;
                      my @filters;
                      my $binmode = 0;
                      unless ( length $dest ) {
                          if ( !$succinct ) {
                              ## unshift...shift: '>' filters source...sink left...right
                              while ( @args > 1
                                  && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
                                  if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
                                      $binmode = shift(@args)->();
                                  }
                                  else {
                                      unshift @filters, shift @args;
                                  }
                              }
                          }
  
  			if ( @args && ref $args[0] eq 'IPC::Run::Undef' ) {
  			    require Symbol;
  			    ${ $args[0] } = $dest = Symbol::gensym();
  			    shift @args;
  			}
  			else {
  			    $dest = shift @args;
  			}
  
                          _debug(
                              'Kid ',  $cur_kid->{NUM},  "'s output fd ", $kfd,
                              ' has ', scalar(@filters), ' filters.'
                          ) if _debugging_details && @filters;
  
                          if ( $type eq '>pty>' ) {
                              ## do the require here to cause early error reporting
                              require IO::Pty;
                              ## Just flag the pyt's existence for now.  _open_pipes()
                              ## will new an IO::Pty for each key.
                              $self->{PTYS}->{$pty_id} = undef;
                          }
                      }
  
                      croak "'$_' missing a destination" if _empty $dest;
                      my $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $dest, $binmode, @filters );
                      $pipe->{TRUNC} = $trunc;
  
                      if ( ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
                          && $type !~ /^>(pty>|pipe)$/ ) {
                          _debug "setting DONT_CLOSE" if _debugging_details;
                          $pipe->{DONT_CLOSE} = 1;    ## this FD is not closed by us.
                      }
                      push @{ $cur_kid->{OPS} }, $pipe;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'dup',
                          KFD1 => 1,
                          KFD2 => 2,
                      } if $stderr_too;
                  }
  
                  elsif ( $_ eq "|" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      unshift @{ $cur_kid->{OPS} }, {
                          TYPE => '|',
                          KFD  => 1,
                      };
                      $succinct   = 1;
                      $assumed_fd = 1;
                      $cur_kid    = undef;
                  }
  
                  elsif ( $_ eq "&" ) {
                      croak "No command before '$_'" unless $cur_kid;
                      $next_kid_close_stdin = 1;
                      $succinct             = 1;
                      $assumed_fd           = 0;
                      $cur_kid              = undef;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( !ref $_ ) {
                      $self->{$_} = shift @args;
                  }
  
                  elsif ( $_ eq 'init' ) {
                      croak "No command before '$_'" unless $cur_kid;
                      push @{ $cur_kid->{OPS} }, {
                          TYPE => 'init',
                          SUB  => shift @args,
                      };
                  }
  
                  elsif ( $succinct && $first_parse ) {
                      ## It's not an opcode, and no explicit opcodes have been
                      ## seen yet, so assume it's a file name.
                      unshift @args, $_;
                      if ( !$assumed_fd ) {
                          $_ = "$assumed_fd<",
                      }
                      else {
                          $_ = "$assumed_fd>",
                      }
                      _debug "assuming '", $_, "'" if _debugging_details;
                      ++$assumed_fd;
                      $first_parse = 0;
                      goto REPARSE;
                  }
  
                  else {
                      croak join(
                          '',
                          'Unexpected ',
                          ( ref() ? $_ : 'scalar' ),
                          ' in harness() parameter ',
                          $arg_count - @args
                      );
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      die join( '', @errs ) if @errs;
  
      $self->{STATE} = _harnessed;
  
      #   $self->timeout( $options->{timeout} ) if exists $options->{timeout};
      return $self;
  }
  
  sub _open_pipes {
      my IPC::Run $self = shift;
  
      my @errs;
  
      my @close_on_fail;
  
      ## When a pipe character is seen, a pipe is created.  $pipe_read_fd holds
      ## the dangling read end of the pipe until we get to the next process.
      my $pipe_read_fd;
  
      ## Output descriptors for the last command are shared by all children.
      ## @output_fds_accum accumulates the current set of output fds.
      my @output_fds_accum;
  
      for ( sort keys %{ $self->{PTYS} } ) {
          _debug "opening pty '", $_, "'" if _debugging_details;
          my $pty = _pty;
          $self->{PTYS}->{$_} = $pty;
      }
  
      for ( @{ $self->{IOS} } ) {
          eval { $_->init; };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
          else {
              push @close_on_fail, $_;
          }
      }
  
      ## Loop through the kids and their OPS, interpreting any that require
      ## parent-side actions.
      for my $kid ( @{ $self->{KIDS} } ) {
          if ( ref $kid->{VAL} eq 'ARRAY' ) {
              $kid->{PATH} = _search_path $kid->{VAL}->[0];
          }
          if ( defined $pipe_read_fd ) {
              _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
                if _debugging_details;
              unshift @{ $kid->{OPS} }, {
                  TYPE => 'PIPE',          ## Prevent next loop from triggering on this
                  KFD  => 0,
                  TFD  => $pipe_read_fd,
              };
              $pipe_read_fd = undef;
          }
          @output_fds_accum = ();
          for my $op ( @{ $kid->{OPS} } ) {
  
              #         next if $op->{IS_DEBUG};
              my $ok = eval {
                  if ( $op->{TYPE} eq '<' ) {
                      my $source = $op->{SOURCE};
                      if ( !ref $source ) {
                          _debug(
                              "kid ",              $kid->{NUM}, " to read ", $op->{KFD},
                              " from '" . $source, "' (read only)"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen( $source, O_RDONLY );
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif (UNIVERSAL::isa( $source, 'GLOB' )
                          || UNIVERSAL::isa( $source, 'IO::Handle' ) ) {
                          croak "Unopened filehandle in input redirect for $op->{KFD}"
                            unless defined fileno $source;
                          $op->{TFD} = fileno $source;
                          _debug(
                              "kid ",      $kid->{NUM}, " to read ", $op->{KFD},
                              " from fd ", $op->{TFD}
                          ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                          _debug(
                              "kid ", $kid->{NUM}, " to read ", $op->{KFD},
                              " from SCALAR"
                          ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                          _debug( 'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE' ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{KFD}, $op->{FD};
  
                          my $s = '';
                          $op->{KIN_REF} = \$s;
                      }
                      else {
                          croak( "'" . ref($source) . "' not allowed as a source for input redirection" );
                      }
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pipe' ) {
                      _debug(
                          'kid to read ', $op->{KFD},
                          ' from a pipe IPC::Run opens and returns',
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
                      _debug "caller will write to ", fileno $op->{SOURCE}
                        if _debugging_details;
  
                      $op->{TFD} = $r;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '<pty<' ) {
                      _debug(
                          'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
                      ) if _debugging_details;
  
                      for my $source ( $op->{SOURCE} ) {
                          if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
                              _debug(
                                  "kid ",                   $kid->{NUM},   " to read ", $op->{KFD},
                                  " from SCALAR via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
  
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
                              _debug(
                                  "kid ",                 $kid->{NUM},   " to read ", $op->{KFD},
                                  " from CODE via pty '", $op->{PTY_ID}, "'"
                              ) if _debugging_details;
                              my $s = '';
                              $op->{KIN_REF} = \$s;
                          }
                          else {
                              croak( "'" . ref($source) . "' not allowed as a source for '<pty<' redirection" );
                          }
                      }
                      $op->{FD}  = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD} = undef;                                      # The fd isn't known until after fork().
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '>' ) {
                      ## N> output redirection.
                      my $dest = $op->{DEST};
                      if ( !ref $dest ) {
                          _debug(
                              "kid ",  $kid->{NUM}, " to write ", $op->{KFD},
                              " to '", $dest,       "' (write only, create, ",
                              ( $op->{TRUNC} ? 'truncate' : 'append' ),
                              ")"
                          ) if _debugging_details;
                          croak "simulated open failure"
                            if $self->{_simulate_open_failure};
                          $op->{TFD} = _sysopen(
                              $dest,
                              ( O_WRONLY | O_CREAT | ( $op->{TRUNC} ? O_TRUNC : O_APPEND ) )
                          );
                          if (Win32_MODE) {
                              ## I have no idea why this is needed to make the current
                              ## file position survive the gyrations TFD must go
                              ## through...
                              POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
                          }
                          push @close_on_fail, $op->{TFD};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
                          croak("Unopened filehandle in output redirect, command $kid->{NUM}") unless defined fileno $dest;
                          ## Turn on autoflush, mostly just to flush out
                          ## existing output.
                          my $old_fh = select($dest);
                          $| = 1;
                          select($old_fh);
                          $op->{TFD} = fileno $dest;
                          _debug( 'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD} ) if _debugging_details;
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug( "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR" ) if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug("kid $kid->{NUM} to write $op->{KFD} to CODE") if _debugging_details;
  
                          $op->open_pipe( $self->_debug_fd );
                          push @close_on_fail, $op->{FD}, $op->{TFD};
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
  
                  elsif ( $op->{TYPE} eq '>pipe' ) {
                      ## N> output redirection to a pipe we open, but don't select()
                      ## on.
                      _debug(
                          "kid ", $kid->{NUM}, " to write ", $op->{KFD},
                          ' to a pipe IPC::Run opens and returns'
                      ) if _debugging_details;
  
                      my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
                      _debug "caller will read from ", fileno $op->{DEST}
                        if _debugging_details;
  
                      $op->{TFD} = $w;
                      $op->{FD}  = undef;    # we don't manage this fd
                      $op->_init_filters;
  
                      $output_fds_accum[ $op->{KFD} ] = $op;
                  }
                  elsif ( $op->{TYPE} eq '>pty>' ) {
                      my $dest = $op->{DEST};
                      if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
                          _debug(
                              "kid ",                 $kid->{NUM},   " to write ", $op->{KFD},
                              " to SCALAR via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
  
                          $$dest = '' if $op->{TRUNC};
                      }
                      elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
                          _debug(
                              "kid ",               $kid->{NUM},   " to write ", $op->{KFD},
                              " to CODE via pty '", $op->{PTY_ID}, "'"
                          ) if _debugging_details;
                      }
                      else {
                          croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
                      }
  
                      $op->{FD}                       = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
                      $op->{TFD}                      = undef;                                      # The fd isn't known until after fork().
                      $output_fds_accum[ $op->{KFD} ] = $op;
                      $op->_init_filters;
                  }
                  elsif ( $op->{TYPE} eq '|' ) {
                      _debug( "pipelining $kid->{NUM} and " . ( $kid->{NUM} + 1 ) ) if _debugging_details;
                      ( $pipe_read_fd, $op->{TFD} ) = _pipe;
                      if (Win32_MODE) {
                          _dont_inherit($pipe_read_fd);
                          _dont_inherit( $op->{TFD} );
                      }
                      @output_fds_accum = ();
                  }
                  elsif ( $op->{TYPE} eq '&' ) {
                      @output_fds_accum = ();
                  }    # end if $op->{TYPE} tree
                  1;
              };    # end eval
              unless ($ok) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }    # end for ( OPS }
      }
  
      if (@errs) {
          for (@close_on_fail) {
              _close($_);
              $_ = undef;
          }
          for ( keys %{ $self->{PTYS} } ) {
              next unless $self->{PTYS}->{$_};
              close $self->{PTYS}->{$_};
              $self->{PTYS}->{$_} = undef;
          }
          die join( '', @errs );
      }
  
      ## give all but the last child all of the output file descriptors
      ## These will be reopened (and thus rendered useless) if the child
      ## dup2s on to these descriptors, since we unshift these.  This way
      ## each process emits output to the same file descriptors that the
      ## last child will write to.  This is probably not quite correct,
      ## since each child should write to the file descriptors inherited
      ## from the parent.
      ## TODO: fix the inheritance of output file descriptors.
      ## NOTE: This sharing of OPS among kids means that we can't easily put
      ## a kid number in each OPS structure to ping the kid when all ops
      ## have closed (when $self->{PIPES} has emptied).  This means that we
      ## need to scan the KIDS whenever @{$self->{PIPES}} is empty to see
      ## if there any of them are still alive.
      for ( my $num = 0; $num < $#{ $self->{KIDS} }; ++$num ) {
          for ( reverse @output_fds_accum ) {
              next unless defined $_;
              _debug(
                  'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
                  ' to ', ref $_->{DEST}
              ) if _debugging_details;
              unshift @{ $self->{KIDS}->[$num]->{OPS} }, $_;
          }
      }
  
      ## Open the debug pipe if we need it
      ## Create the list of PIPES we need to scan and the bit vectors needed by
      ## select().  Do this first so that _cleanup can _clobber() them if an
      ## exception occurs.
      @{ $self->{PIPES} } = ();
      $self->{RIN} = '';
      $self->{WIN} = '';
      $self->{EIN} = '';
      ## PIN is a vec()tor that indicates who's paused.
      $self->{PIN} = '';
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{FD} ) {
                  _debug(
                      'kid ',    $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
                      ' is my ', $_->{FD}
                  ) if _debugging_details;
                  vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $_->{FD}, 1 ) = 1;
                  push @{ $self->{PIPES} }, $_;
              }
          }
      }
  
      for my $io ( @{ $self->{IOS} } ) {
          my $fd = $io->fileno;
          vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
          vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
  
          #      vec( $self->{EIN}, $fd, 1 ) = 1;
          push @{ $self->{PIPES} }, $io;
      }
  
      ## Put filters on the end of the filter chains to read & write the pipes.
      ## Clear pipe states
      for my $pipe ( @{ $self->{PIPES} } ) {
          $pipe->{SOURCE_EMPTY} = 0;
          $pipe->{PAUSED}       = 0;
          if ( $pipe->{TYPE} =~ /^>/ ) {
              my $pipe_reader = sub {
                  my ( undef, $out_ref ) = @_;
  
                  return undef unless defined $pipe->{FD};
                  return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
  
                  vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
  
                  _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
                  my $in = eval { _read( $pipe->{FD} ) };
                  if ($@) {
                      $in = '';
                      ## IO::Pty throws the Input/output error if the kid dies.
                      ## read() throws the bad file descriptor message if the
                      ## kid dies on Win32.
                      die $@
                        unless $@ =~ $_EIO
                        || ( $@ =~ /input or output/ && $^O =~ /aix/ )
                        || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
                  }
  
                  unless ( length $in ) {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  ## Protect the position so /.../g matches may be used.
                  my $pos = pos $$out_ref;
                  $$out_ref .= $in;
                  pos($$out_ref) = $pos;
                  return 1;
              };
              ## Input filters are the last filters
              push @{ $pipe->{FILTERS} },      $pipe_reader;
              push @{ $self->{TEMP_FILTERS} }, $pipe_reader;
          }
          else {
              my $pipe_writer = sub {
                  my ( $in_ref, $out_ref ) = @_;
                  return undef unless defined $pipe->{FD};
                  return 0
                    unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
                    || $pipe->{PAUSED};
  
                  vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
  
                  if ( !length $$in_ref ) {
                      if ( !defined get_more_input ) {
                          $self->_clobber($pipe);
                          return undef;
                      }
                  }
  
                  unless ( length $$in_ref ) {
                      unless ( $pipe->{PAUSED} ) {
                          _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
                          vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
  
                          #		  vec( $self->{EIN}, $pipe->{FD}, 1 ) = 0;
                          vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
                          $pipe->{PAUSED} = 1;
                      }
                      return 0;
                  }
                  _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
  
                  if ( length $$in_ref && $$in_ref ) {
                      my $c = _write( $pipe->{FD}, $$in_ref );
                      substr( $$in_ref, 0, $c, '' );
                  }
                  else {
                      $self->_clobber($pipe);
                      return undef;
                  }
  
                  return 1;
              };
              ## Output filters are the first filters
              unshift @{ $pipe->{FILTERS} }, $pipe_writer;
              push @{ $self->{TEMP_FILTERS} }, $pipe_writer;
          }
      }
  }
  
  sub _dup2_gently {
      ## A METHOD, NOT A FUNCTION, NEEDS $self!
      my IPC::Run $self = shift;
      my ( $files, $fd1, $fd2 ) = @_;
      ## Moves TFDs that are using the destination fd out of the
      ## way before calling _dup2
      for (@$files) {
          next unless defined $_->{TFD};
          $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
      }
      if ( defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2 ) {
          $self->{DEBUG_FD} = _dup $self->{DEBUG_FD};
          $fds{$self->{DEBUG_FD}}{needed} = 1;
      }
      _dup2_rudely( $fd1, $fd2 );
  }
  
  =pod
  
  =item close_terminal
  
  This is used as (or in) an init sub to cast off the bonds of a controlling
  terminal.  It must precede all other redirection ops that affect
  STDIN, STDOUT, or STDERR to be guaranteed effective.
  
  =cut
  
  sub close_terminal {
      ## Cast of the bonds of a controlling terminal
  
      # Just in case the parent (I'm talking to you FCGI) had these tied.
      untie *STDIN;
      untie *STDOUT;
      untie *STDERR;
  
      POSIX::setsid() || croak "POSIX::setsid() failed";
      _debug "closing stdin, out, err"
        if _debugging_details;
      close STDIN;
      close STDERR;
      close STDOUT;
  }
  
  sub _do_kid_and_exit {
      my IPC::Run $self = shift;
      my ($kid) = @_;
  
      my ( $s1, $s2 );
      if ( $] < 5.008 ) {
          ## For unknown reasons, placing these two statements in the eval{}
          ## causes the eval {} to not catch errors after they are executed in
          ## perl 5.6.0, godforsaken version that it is...not sure about 5.6.1.
          ## Part of this could be that these symbols get destructed when
          ## exiting the eval, and that destruction might be what's (wrongly)
          ## confusing the eval{}, allowing the exception to propagate.
          $s1 = Symbol::gensym();
          $s2 = Symbol::gensym();
      }
  
      eval {
          local $cur_self = $self;
  
          if (_debugging) {
              _set_child_debug_name(
                  ref $kid->{VAL} eq "CODE"
                  ? "CODE"
                  : basename( $kid->{VAL}->[0] )
              );
          }
  
          ## close parent FD's first so they're out of the way.
          ## Don't close STDIN, STDOUT, STDERR: they should be inherited or
          ## overwritten below.
          do { $_->{needed} = 1 for @fds{0..2} }
             unless $self->{noinherit};
  
          $fds{$self->{SYNC_WRITER_FD}}{needed} = 1;
          $fds{$self->{DEBUG_FD}}{needed} = 1 if defined $self->{DEBUG_FD};
  
          $fds{$_->{TFD}}{needed} = 1
             foreach grep { defined $_->{TFD} } @{$kid->{OPS} };
  
  
          ## TODO: use the forthcoming IO::Pty to close the terminal and
          ## make the first pty for this child the controlling terminal.
          ## This will also make it so that pty-laden kids don't cause
          ## other kids to lose stdin/stdout/stderr.
  
          if ( %{ $self->{PTYS} } ) {
              ## Clean up the parent's fds.
              for ( keys %{ $self->{PTYS} } ) {
                  _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
                  $self->{PTYS}->{$_}->make_slave_controlling_terminal;
                  my $slave = $self->{PTYS}->{$_}->slave;
   	        delete $fds{$self->{PTYS}->{$_}->fileno};
                  close $self->{PTYS}->{$_};
                  $self->{PTYS}->{$_} = $slave;
              }
  
              close_terminal;
              delete @fds{0..2};
          }
  
          for my $sibling ( @{ $self->{KIDS} } ) {
              for ( @{ $sibling->{OPS} } ) {
                  if ( $_->{TYPE} =~ /^.pty.$/ ) {
                      $_->{TFD} = $self->{PTYS}->{ $_->{PTY_ID} }->fileno;
                      $fds{$_->{TFD}}{needed} = 1;
                  }
  
                  #	    for ( $_->{FD}, ( $sibling != $kid ? $_->{TFD} : () ) ) {
                  #	       if ( defined $_ && ! $closed[$_] && ! $needed[$_] ) {
                  #		  _close( $_ );
                  #		  $closed[$_] = 1;
                  #		  $_ = undef;
                  #	       }
                  #	    }
              }
          }
  
          ## This is crude: we have no way of keeping track of browsing all open
          ## fds, so we scan to a fairly high fd.
          _debug "open fds: ", join " ", keys %fds if _debugging_details;
  
          _close( $_ ) foreach grep { ! $fds{$_}{needed} } keys %fds;
  
          for ( @{ $kid->{OPS} } ) {
              if ( defined $_->{TFD} ) {
  
                  # we're always creating KFD
                  $fds{$_->{KFD}}{needed} = 1;
  
                  unless ( $_->{TFD} == $_->{KFD} ) {
                      $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
                      $fds{$_->{TFD}}{lazy_close} = 1;
                  } else {
                      my $fd = _dup($_->{TFD});
                      $self->_dup2_gently( $kid->{OPS}, $fd, $_->{KFD} );
                      _close($fd);
                  }
              }
              elsif ( $_->{TYPE} eq 'dup' ) {
                  $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
                    unless $_->{KFD1} == $_->{KFD2};
                  $fds{$_->{KFD2}}{needed} = 1;
              }
              elsif ( $_->{TYPE} eq 'close' ) {
                  for ( $_->{KFD} ) {
                      if ( $fds{$_} ) {
                          _close($_);
                          $_ = undef;
                      }
                  }
              }
              elsif ( $_->{TYPE} eq 'init' ) {
                  $_->{SUB}->();
              }
          }
  
          _close( $_ ) foreach grep { $fds{$_}{lazy_close} } keys %fds;
  
          if ( ref $kid->{VAL} ne 'CODE' ) {
              open $s1, ">&=$self->{SYNC_WRITER_FD}"
                or croak "$! setting filehandle to fd SYNC_WRITER_FD";
              fcntl $s1, F_SETFD, 1;
  
              if ( defined $self->{DEBUG_FD} ) {
                  open $s2, ">&=$self->{DEBUG_FD}"
                    or croak "$! setting filehandle to fd DEBUG_FD";
                  fcntl $s2, F_SETFD, 1;
              }
  
              if (_debugging) {
                  my @cmd = ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] );
                  _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
              }
  
              die "exec failed: simulating exec() failure"
                if $self->{_simulate_exec_failure};
  
              _exec $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ];
  
              croak "exec failed: $!";
          }
      };
      if ($@) {
          _write $self->{SYNC_WRITER_FD}, $@;
          ## Avoid DESTROY.
          POSIX::_exit(1);
      }
  
      ## We must be executing code in the child, otherwise exec() would have
      ## prevented us from being here.
      _close $self->{SYNC_WRITER_FD};
      _debug 'calling fork()ed CODE ref' if _debugging;
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      ## TODO: Overload CORE::GLOBAL::exit...
      $kid->{VAL}->();
  
      ## There are bugs in perl closures up to and including 5.6.1
      ## that may keep this next line from having any effect, and it
      ## won't have any effect if our caller has kept a copy of it, but
      ## this may cause the closure to be cleaned up.  Maybe.
      $kid->{VAL} = undef;
  
      ## Use POSIX::_exit to avoid global destruction, since this might
      ## cause DESTROY() to be called on objects created in the parent
      ## and thus cause double cleanup.  For instance, if DESTROY() unlinks
      ## a file in the child, we don't want the parent to suddenly miss
      ## it.
      POSIX::_exit(0);
  }
  
  =pod
  
  =item start
  
     $h = start(
        \@cmd, \$in, \$out, ...,
        timeout( 30, name => "process timeout" ),
        $stall_timeout = timeout( 10, name => "stall timeout"   ),
     );
  
     $h = start \@cmd, '<', \$in, '|', \@cmd2, ...;
  
  start() accepts a harness or harness specification and returns a harness
  after building all of the pipes and launching (via fork()/exec(), or, maybe
  someday, spawn()) all the child processes.  It does not send or receive any
  data on the pipes, see pump() and finish() for that.
  
  You may call harness() and then pass it's result to start() if you like,
  but you only need to if it helps you structure or tune your application.
  If you do call harness(), you may skip start() and proceed directly to
  pump.
  
  start() also starts all timers in the harness.  See L<IPC::Run::Timer>
  for more information.
  
  start() flushes STDOUT and STDERR to help you avoid duplicate output.
  It has no way of asking Perl to flush all your open filehandles, so
  you are going to need to flush any others you have open.  Sorry.
  
  Here's how if you don't want to alter the state of $| for your
  filehandle:
  
     $ofh = select HANDLE; $of = $|; $| = 1; $| = $of; select $ofh;
  
  If you don't mind leaving output unbuffered on HANDLE, you can do
  the slightly shorter
  
     $ofh = select HANDLE; $| = 1; select $ofh;
  
  Or, you can use IO::Handle's flush() method:
  
     use IO::Handle;
     flush HANDLE;
  
  Perl needs the equivalent of C's fflush( (FILE *)NULL ).
  
  =cut
  
  sub start {
  
      # $SIG{__DIE__} = sub { my $s = shift; Carp::cluck $s; die $s };
      my $options;
      if ( @_ && ref $_[-1] eq 'HASH' ) {
          $options = pop;
          require Data::Dumper;
          carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
      }
  
      my IPC::Run $self;
      if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
          $self = shift;
          $self->{$_} = $options->{$_} for keys %$options;
      }
      else {
          $self = harness( @_, $options ? $options : () );
      }
  
      local $cur_self = $self;
  
      $self->kill_kill if $self->{STATE} == _started;
  
      _debug "** starting" if _debugging;
  
      $_->{RESULT} = undef for @{ $self->{KIDS} };
  
      ## Assume we're not being called from &run.  It will correct our
      ## assumption if need be.  This affects whether &_select_loop clears
      ## input queues to '' when they're empty.
      $self->{clear_ins} = 1;
  
      IPC::Run::Win32Helper::optimize $self
        if Win32_MODE && $in_run;
  
      my @errs;
  
      for ( @{ $self->{TIMERS} } ) {
          eval { $_->start };
          if ($@) {
              push @errs, $@;
              _debug 'caught ', $@ if _debugging;
          }
      }
  
      eval { $self->_open_pipes };
      if ($@) {
          push @errs, $@;
          _debug 'caught ', $@ if _debugging;
      }
  
      if ( !@errs ) {
          ## This is a bit of a hack, we should do it for all open filehandles.
          ## Since there's no way I know of to enumerate open filehandles, we
          ## autoflush STDOUT and STDERR.  This is done so that the children don't
          ## inherit output buffers chock full o' redundant data.  It's really
          ## confusing to track that down.
          { my $ofh = select STDOUT; my $of = $|; $| = 1; $| = $of; select $ofh; }
          { my $ofh = select STDERR; my $of = $|; $| = 1; $| = $of; select $ofh; }
          for my $kid ( @{ $self->{KIDS} } ) {
              $kid->{RESULT} = undef;
              _debug "child: ", _debugstrings( $kid->{VAL} )
                if _debugging_details;
              eval {
                  croak "simulated failure of fork"
                    if $self->{_simulate_fork_failure};
                  unless (Win32_MODE) {
                      $self->_spawn($kid);
                  }
                  else {
  ## TODO: Test and debug spawning code.  Someday.
                      _debug(
                          'spawning ',
                          _debugstrings(
                              [
                                  $kid->{PATH},
                                  @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ]
                              ]
                          )
                      ) if $kid->{PATH} && _debugging;
                      ## The external kid wouldn't know what to do with it anyway.
                      ## This is only used by the "helper" pump processes on Win32.
                      _dont_inherit( $self->{DEBUG_FD} );
                      ( $kid->{PID}, $kid->{PROCESS} ) = IPC::Run::Win32Helper::win32_spawn(
                          ref( $kid->{VAL} ) eq "ARRAY"
                          ? [ $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ]
                          : $kid->{VAL},
                          $kid->{OPS},
                      );
                      _debug "spawn() = ", $kid->{PID} if _debugging;
                      if ($self->{_sleep_after_win32_spawn}) {
                        sleep $self->{_sleep_after_win32_spawn};
                        _debug "after sleep $self->{_sleep_after_win32_spawn}"
                            if _debugging;
                      }
                  }
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
          }
      }
  
      ## Close all those temporary filehandles that the kids needed.
      for my $pty ( values %{ $self->{PTYS} } ) {
          close $pty->slave;
      }
  
      my @closed;
      for my $kid ( @{ $self->{KIDS} } ) {
          for ( @{ $kid->{OPS} } ) {
              my $close_it = eval {
                       defined $_->{TFD}
                    && !$_->{DONT_CLOSE}
                    && !$closed[ $_->{TFD} ]
                    && ( !Win32_MODE || !$_->{RECV_THROUGH_TEMP_FILE} )    ## Win32 hack
              };
              if ($@) {
                  push @errs, $@;
                  _debug 'caught ', $@ if _debugging;
              }
              if ( $close_it || $@ ) {
                  eval {
                      _close( $_->{TFD} );
                      $closed[ $_->{TFD} ] = 1;
                      $_->{TFD} = undef;
                  };
                  if ($@) {
                      push @errs, $@;
                      _debug 'caught ', $@ if _debugging;
                  }
              }
          }
      }
      confess "gak!" unless defined $self->{PIPES};
  
      if (@errs) {
          eval { $self->_cleanup };
          warn $@ if $@;
          die join( '', @errs );
      }
  
      $self->{STATE} = _started;
      return $self;
  }
  
  =item adopt
  
  Experimental feature. NOT FUNCTIONAL YET, NEED TO CLOSE FDS BETTER IN CHILDREN.  SEE t/adopt.t for a test suite.
  
  =cut
  
  sub adopt {
      my IPC::Run $self = shift;
  
      for my $adoptee (@_) {
          push @{ $self->{IOS} }, @{ $adoptee->{IOS} };
          ## NEED TO RENUMBER THE KIDS!!
          push @{ $self->{KIDS} },  @{ $adoptee->{KIDS} };
          push @{ $self->{PIPES} }, @{ $adoptee->{PIPES} };
          $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_} for keys %{ $adoptee->{PYTS} };
          push @{ $self->{TIMERS} }, @{ $adoptee->{TIMERS} };
          $adoptee->{STATE} = _finished;
      }
  }
  
  sub _clobber {
      my IPC::Run $self = shift;
      my ($file) = @_;
      _debug_desc_fd( "closing", $file ) if _debugging_details;
      my $doomed = $file->{FD};
      my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
      vec( $self->{$dir}, $doomed, 1 ) = 0;
  
      #   vec( $self->{EIN},  $doomed, 1 ) = 0;
      vec( $self->{PIN}, $doomed, 1 ) = 0;
      if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
          if ( $1 eq '>' ) {
              ## Only close output ptys.  This is so that ptys as inputs are
              ## never autoclosed, which would risk losing data that was
              ## in the slave->parent queue.
              _debug_desc_fd "closing pty", $file if _debugging_details;
              close $self->{PTYS}->{ $file->{PTY_ID} }
                if defined $self->{PTYS}->{ $file->{PTY_ID} };
              $self->{PTYS}->{ $file->{PTY_ID} } = undef;
          }
      }
      elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
          $file->close unless $file->{DONT_CLOSE};
      }
      else {
          _close($doomed);
      }
  
      @{ $self->{PIPES} } = grep
        defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed ),
        @{ $self->{PIPES} };
  
      $file->{FD} = undef;
  }
  
  sub _select_loop {
      my IPC::Run $self = shift;
  
      my $io_occurred;
  
      my $not_forever = 0.01;
  
    SELECT:
      while ( $self->pumpable ) {
          if ( $io_occurred && $self->{break_on_io} ) {
              _debug "exiting _select(): io occurred and break_on_io set"
                if _debugging_details;
              last;
          }
  
          my $timeout = $self->{non_blocking} ? 0 : undef;
  
          if ( @{ $self->{TIMERS} } ) {
              my $now = time;
              my $time_left;
              for ( @{ $self->{TIMERS} } ) {
                  next unless $_->is_running;
                  $time_left = $_->check($now);
                  ## Return when a timer expires
                  return if defined $time_left && !$time_left;
                  $timeout = $time_left
                    if !defined $timeout || $time_left < $timeout;
              }
          }
  
          ##
          ## See if we can unpause any input channels
          ##
          my $paused = 0;
  
          for my $file ( @{ $self->{PIPES} } ) {
              next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
  
              _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
              my $did;
              1 while $did = $file->_do_filters($self);
              if ( defined $file->{FD} && !defined($did) || $did ) {
                  _debug_desc_fd( "unpausing", $file ) if _debugging_details;
                  $file->{PAUSED} = 0;
                  vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
  
                  #	    vec( $self->{EIN}, $file->{FD}, 1 ) = 1;
                  vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
              }
              else {
                  ## This gets incremented occasionally when the IO channel
                  ## was actually closed.  That's a bug, but it seems mostly
                  ## harmless: it causes us to exit if break_on_io, or to set
                  ## the timeout to not be forever.  I need to fix it, though.
                  ++$paused;
              }
          }
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{RIN}, $_, 1 );
                      $out = $out ? 'b' : 'w' if vec( $self->{WIN}, $_, 1 );
                      $out = 'p' if !$out && vec( $self->{PIN}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EIN}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 1024 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug 'fds for select: ', $map if _debugging_details;
          }
  
          ## _do_filters may have closed our last fd, and we need to see if
          ## we have I/O, or are just waiting for children to exit.
          my $p = $self->pumpable;
          last unless $p;
          if ( $p != 0 && ( !defined $timeout || $timeout > 0.1 ) ) {
              ## No I/O will wake the select loop up, but we have children
              ## lingering, so we need to poll them with a short timeout.
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          ## Make sure we don't block forever in select() because inputs are
          ## paused.
          if ( !defined $timeout && !( @{ $self->{PIPES} } - $paused ) ) {
              ## Need to return if we're in pump and all input is paused, or
              ## we'll loop until all inputs are unpaused, which is darn near
              ## forever.  And a day.
              if ( $self->{break_on_io} ) {
                  _debug "exiting _select(): no I/O to do and timeout=forever"
                    if _debugging;
                  last;
              }
  
              ## Otherwise, assume more input will be coming.
              $timeout = $not_forever;
              $not_forever *= 2;
              $not_forever = 0.5 if $not_forever >= 0.5;
          }
  
          _debug 'timeout=', defined $timeout ? $timeout : 'forever'
            if _debugging_details;
  
          my $nfound;
          unless (Win32_MODE) {
              $nfound = select(
                  $self->{ROUT} = $self->{RIN},
                  $self->{WOUT} = $self->{WIN},
                  $self->{EOUT} = $self->{EIN},
                  $timeout
              );
          }
          else {
              my @in = map $self->{$_}, qw( RIN WIN EIN );
              ## Win32's select() on Win32 seems to die if passed vectors of
              ## all 0's.  Need to report this when I get back online.
              for (@in) {
                  $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
              }
  
              $nfound = select(
                  $self->{ROUT} = $in[0],
                  $self->{WOUT} = $in[1],
                  $self->{EOUT} = $in[2],
                  $timeout
              );
  
              for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
                  $_ = "" unless defined $_;
              }
          }
          last if !$nfound && $self->{non_blocking};
  
          if ( $nfound < 0 ) {
              if ( $!{EINTR} ) {
  
                  # Caught a signal before any FD went ready.  Ensure that
                  # the bit fields reflect "no FDs ready".
                  $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
                  $nfound = 0;
              }
              else {
                  croak "$! in select";
              }
          }
          ## TODO: Analyze the EINTR failure mode and see if this patch
          ## is adequate and optimal.
          ## TODO: Add an EINTR test to the test suite.
  
          if (_debugging_details) {
              my $map = join(
                  '',
                  map {
                      my $out;
                      $out = 'r' if vec( $self->{ROUT}, $_, 1 );
                      $out = $out ? 'b'      : 'w' if vec( $self->{WOUT}, $_, 1 );
                      $out = $out ? uc($out) : 'x' if vec( $self->{EOUT}, $_, 1 );
                      $out = '-' unless $out;
                      $out;
                  } ( 0 .. 128 )
              );
              $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
              _debug "selected  ", $map;
          }
  
          ## Need to copy since _clobber alters @{$self->{PIPES}}.
          ## TODO: Rethink _clobber().  Rethink $file->{PAUSED}, too.
          my @pipes = @{ $self->{PIPES} };
          $io_occurred = $_->poll($self) ? 1 : $io_occurred for @pipes;
  
          #   FILE:
          #      for my $pipe ( @pipes ) {
          #         ## Pipes can be shared among kids.  If another kid closes the
          #         ## pipe, then it's {FD} will be undef.  Also, on Win32, pipes can
          #	 ## be optimized to be files, in which case the FD is left undef
          #	 ## so we don't try to select() on it.
          #         if ( $pipe->{TYPE} =~ /^>/
          #            && defined $pipe->{FD}
          #            && vec( $self->{ROUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data from", $pipe ) if _debugging_details;
          #confess "phooey" unless UNIVERSAL::isa( $pipe, "IPC::Run::IO" );
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #	 ## On Win32, pipes to the child can be optimized to be files
          #	 ## and FD left undefined so we won't select on it.
          #         if ( $pipe->{TYPE} =~ /^</
          #            && defined $pipe->{FD}
          #            && vec( $self->{WOUT}, $pipe->{FD}, 1 )
          #         ) {
          #            _debug_desc_fd( "filtering data to", $pipe ) if _debugging_details;
          #            $io_occurred = 1 if $pipe->_do_filters( $self );
          #
          #            next FILE unless defined $pipe->{FD};
          #         }
          #
          #         if ( defined $pipe->{FD} && vec( $self->{EOUT}, $pipe->{FD}, 1 ) ) {
          #            ## BSD seems to sometimes raise the exceptional condition flag
          #            ## when a pipe is closed before we read it's last data.  This
          #            ## causes spurious warnings and generally renders the exception
          #            ## mechanism useless for our purposes.  The exception
          #            ## flag semantics are too variable (they're device driver
          #            ## specific) for me to easily map to any automatic action like
          #            ## warning or croaking (try running v0.42 if you don't believe me
          #            ## :-).
          #            warn "Exception on descriptor $pipe->{FD}";
          #         }
          #      }
      }
  
      return;
  }
  
  sub _cleanup {
      my IPC::Run $self = shift;
      _debug "cleaning up" if _debugging_details;
  
      for ( values %{ $self->{PTYS} } ) {
          next unless ref $_;
          eval {
              _debug "closing slave fd ", fileno $_->slave if _debugging_data;
              close $_->slave;
          };
          carp $@ . " while closing ptys" if $@;
          eval {
              _debug "closing master fd ", fileno $_ if _debugging_data;
              close $_;
          };
          carp $@ . " closing ptys" if $@;
      }
  
      _debug "cleaning up pipes" if _debugging_details;
      ## _clobber modifies PIPES
      $self->_clobber( $self->{PIPES}->[0] ) while @{ $self->{PIPES} };
  
      for my $kid ( @{ $self->{KIDS} } ) {
          _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
          if ( !length $kid->{PID} ) {
              _debug 'never ran child ', $kid->{NUM}, ", can't reap"
                if _debugging;
              for my $op ( @{ $kid->{OPS} } ) {
                  _close( $op->{TFD} )
                    if defined $op->{TFD} && !defined $op->{TEMP_FILE_HANDLE};
              }
          }
          elsif ( !defined $kid->{RESULT} ) {
              _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
                if _debugging;
              my $pid = waitpid $kid->{PID}, 0;
              $kid->{RESULT} = $?;
              _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
                if _debugging;
          }
  
          #      if ( defined $kid->{DEBUG_FD} ) {
          #	 die;
          #         @{$kid->{OPS}} = grep
          #            ! defined $_->{KFD} || $_->{KFD} != $kid->{DEBUG_FD},
          #            @{$kid->{OPS}};
          #         $kid->{DEBUG_FD} = undef;
          #      }
  
          _debug "cleaning up filters" if _debugging_details;
          for my $op ( @{ $kid->{OPS} } ) {
              @{ $op->{FILTERS} } = grep {
                  my $filter = $_;
                  !grep $filter == $_, @{ $self->{TEMP_FILTERS} };
              } @{ $op->{FILTERS} };
          }
  
          for my $op ( @{ $kid->{OPS} } ) {
              $op->_cleanup($self) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
          }
      }
      $self->{STATE} = _finished;
      @{ $self->{TEMP_FILTERS} } = ();
      _debug "done cleaning up" if _debugging_details;
  
      POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
      $self->{DEBUG_FD} = undef;
  }
  
  =pod
  
  =item pump
  
     pump $h;
     $h->pump;
  
  Pump accepts a single parameter harness.  It blocks until it delivers some
  input or receives some output.  It returns TRUE if there is still input or
  output to be done, FALSE otherwise.
  
  pump() will automatically call start() if need be, so you may call harness()
  then proceed to pump() if that helps you structure your application.
  
  If pump() is called after all harnessed activities have completed, a "process
  ended prematurely" exception to be thrown.  This allows for simple scripting
  of external applications without having to add lots of error handling code at
  each step of the script:
  
     $h = harness \@smbclient, \$in, \$out, $err;
  
     $in = "cd /foo\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error cding to /foo:\n$out" if $out =~ "ERR";
     $out = '';
  
     $in = "mget *\n";
     $h->pump until $out =~ /^smb.*> \Z/m;
     die "error retrieving files:\n$out" if $out =~ "ERR";
  
     $h->finish;
  
     warn $err if $err;
  
  =cut
  
  sub pump {
      die "pump() takes only a single harness as a parameter"
        unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
  
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      _debug "** pumping"
        if _debugging;
  
      #   my $r = eval {
      $self->start if $self->{STATE} < _started;
      croak "process ended prematurely" unless $self->pumpable;
  
      $self->{auto_close_ins} = 0;
      $self->{break_on_io}    = 1;
      $self->_select_loop;
      return $self->pumpable;
  
      #   };
      #   if ( $@ ) {
      #      my $x = $@;
      #      _debug $x if _debugging && $x;
      #      eval { $self->_cleanup };
      #      warn $@ if $@;
      #      die $x;
      #   }
      #   return $r;
  }
  
  =pod
  
  =item pump_nb
  
     pump_nb $h;
     $h->pump_nb;
  
  "pump() non-blocking", pumps if anything's ready to be pumped, returns
  immediately otherwise.  This is useful if you're doing some long-running
  task in the foreground, but don't want to starve any child processes.
  
  =cut
  
  sub pump_nb {
      my IPC::Run $self = shift;
  
      $self->{non_blocking} = 1;
      my $r = eval { $self->pump };
      $self->{non_blocking} = 0;
      die $@ if $@;
      return $r;
  }
  
  =pod
  
  =item pumpable
  
  Returns TRUE if calling pump() won't throw an immediate "process ended
  prematurely" exception.  This means that there are open I/O channels or
  active processes. May yield the parent processes' time slice for 0.01
  second if all pipes are to the child and all are paused.  In this case
  we can't tell if the child is dead, so we yield the processor and
  then attempt to reap the child in a nonblocking way.
  
  =cut
  
  ## Undocumented feature (don't depend on it outside this module):
  ## returns -1 if we have I/O channels open, or >0 if no I/O channels
  ## open, but we have kids running.  This allows the select loop
  ## to poll for child exit.
  sub pumpable {
      my IPC::Run $self = shift;
  
      ## There's a catch-22 we can get in to if there is only one pipe left
      ## open to the child and it's paused (ie the SCALAR it's tied to
      ## is '').  It's paused, so we're not select()ing on it, so we don't
      ## check it to see if the child attached to it is alive and it stays
      ## in @{$self->{PIPES}} forever.  So, if all pipes are paused, see if
      ## we can reap the child.
      return -1 if grep !$_->{PAUSED}, @{ $self->{PIPES} };
  
      ## See if the child is dead.
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      ## If we reap_nb and it's not dead yet, yield to it to see if it
      ## exits.
      ##
      ## A better solution would be to unpause all the pipes, but I tried that
      ## and it never errored on linux.  Sigh.
      select undef, undef, undef, 0.0001;
  
      ## try again
      $self->reap_nb;
      return 0 unless $self->_running_kids;
  
      return -1;    ## There are pipes waiting
  }
  
  sub _running_kids {
      my IPC::Run $self = shift;
      return grep
        defined $_->{PID} && !defined $_->{RESULT},
        @{ $self->{KIDS} };
  }
  
  =pod
  
  =item reap_nb
  
  Attempts to reap child processes, but does not block.
  
  Does not currently take any parameters, one day it will allow specific
  children to be reaped.
  
  Only call this from a signal handler if your C<perl> is recent enough
  to have safe signal handling (5.6.1 did not, IIRC, but it was being discussed
  on perl5-porters).  Calling this (or doing any significant work) in a signal
  handler on older C<perl>s is asking for seg faults.
  
  =cut
  
  my $still_runnings;
  
  sub reap_nb {
      my IPC::Run $self = shift;
  
      local $cur_self = $self;
  
      ## No more pipes, look to see if all the kids yet live, reaping those
      ## that haven't.  I'd use $SIG{CHLD}/$SIG{CLD}, but that's broken
      ## on older (SYSV) platforms and perhaps less portable than waitpid().
      ## This could be slow with a lot of kids, but that's rare and, well,
      ## a lot of kids is slow in the first place.
      ## Oh, and this keeps us from reaping other children the process
      ## may have spawned.
      for my $kid ( @{ $self->{KIDS} } ) {
          if (Win32_MODE) {
              next if !defined $kid->{PROCESS} || defined $kid->{RESULT};
              unless ( $kid->{PROCESS}->Wait(0) ) {
                  _debug "kid $kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                if _debugging;
  
              my $native_result;
              $kid->{PROCESS}->GetExitCode($native_result)
                or croak "$! while GetExitCode()ing for Win32 process";
  
              unless ( defined $native_result ) {
                  $kid->{RESULT} = "0 but true";
                  $? = $kid->{RESULT} = 0x0F;
              }
              else {
                  my $win32_full_result = $native_result << 8;
                  if ( $win32_full_result >> 8 != $native_result ) {
  
                      # !USE_64_BIT_INT build and exit code > 0xFFFFFF
                      require Math::BigInt;
                      $win32_full_result = Math::BigInt->new($native_result);
                      $win32_full_result->blsft(8);
                  }
                  $? = $kid->{RESULT} = $win32_full_result;
              }
          }
          else {
              next if !defined $kid->{PID} || defined $kid->{RESULT};
              my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
              unless ($pid) {
                  _debug "$kid->{NUM} ($kid->{PID}) still running"
                    if _debugging_details;
                  next;
              }
  
              if ( $pid < 0 ) {
                  _debug "No such process: $kid->{PID}\n" if _debugging;
                  $kid->{RESULT} = "unknown result, unknown PID";
              }
              else {
                  _debug "kid $kid->{NUM} ($kid->{PID}) exited"
                    if _debugging;
  
                  confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
                    unless $pid == $kid->{PID};
                  _debug "$kid->{PID} returned $?\n" if _debugging;
                  $kid->{RESULT} = $?;
              }
          }
      }
  }
  
  =pod
  
  =item finish
  
  This must be called after the last start() or pump() call for a harness,
  or your system will accumulate defunct processes and you may "leak"
  file descriptors.
  
  finish() returns TRUE if all children returned 0 (and were not signaled and did
  not coredump, ie ! $?), and FALSE otherwise (this is like run(), and the
  opposite of system()).
  
  Once a harness has been finished, it may be run() or start()ed again,
  including by pump()s auto-start.
  
  If this throws an exception rather than a normal exit, the harness may
  be left in an unstable state, it's best to kill the harness to get rid
  of all the child processes, etc.
  
  Specifically, if a timeout expires in finish(), finish() will not
  kill all the children.  Call C<< $h->kill_kill >> in this case if you care.
  This differs from the behavior of L</run>.
  
  =cut
  
  sub finish {
      my IPC::Run $self = shift;
      my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
  
      local $cur_self = $self;
  
      _debug "** finishing" if _debugging;
  
      $self->{non_blocking}   = 0;
      $self->{auto_close_ins} = 1;
      $self->{break_on_io}    = 0;
  
      # We don't alter $self->{clear_ins}, start() and run() control it.
  
      while ( $self->pumpable ) {
          $self->_select_loop($options);
      }
      $self->_cleanup;
  
      return !$self->full_result;
  }
  
  =pod
  
  =item result
  
     $h->result;
  
  Returns the first non-zero result code (ie $? >> 8).  See L</full_result> to 
  get the $? value for a child process.
  
  To get the result of a particular child, do:
  
     $h->result( 0 );  # first child's $? >> 8
     $h->result( 1 );  # second child
  
  or
  
     ($h->results)[0]
     ($h->results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub _assert_finished {
      my IPC::Run $self = $_[0];
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  }
  
  sub _child_result {
      my IPC::Run $self = shift;
  
      my ($which) = @_;
      croak(
          "Only ",
          scalar( @{ $self->{KIDS} } ),
          " child processes, no process $which"
      ) unless $which >= 0 && $which <= $#{ $self->{KIDS} };
      return $self->{KIDS}->[$which]->{RESULT};
  }
  
  sub result {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which) >> 8;
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
          }
      }
  }
  
  =pod
  
  =item results
  
  Returns a list of child exit values.  See L</full_results> if you want to
  know if a signal killed the child.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      # we add 0 here to stop warnings associated with "unknown result, unknown PID"
      return map { ( 0 + $_->{RESULT} ) >> 8 } @{ $self->{KIDS} };
  }
  
  =pod
  
  =item full_result
  
     $h->full_result;
  
  Returns the first non-zero $?.  See L</result> to get the first $? >> 8 
  value for a child process.
  
  To get the result of a particular child, do:
  
     $h->full_result( 0 );  # first child's $?
     $h->full_result( 1 );  # second child
  
  or
  
     ($h->full_results)[0]
     ($h->full_results)[1]
  
  Returns undef if no child processes were spawned and no child number was
  specified.  Throws an exception if an out-of-range child number is passed.
  
  =cut
  
  sub full_result {
      &_assert_finished;
  
      my IPC::Run $self = shift;
  
      if (@_) {
          my ($which) = @_;
          return $self->_child_result($which);
      }
      else {
          return undef unless @{ $self->{KIDS} };
          for ( @{ $self->{KIDS} } ) {
              return $_->{RESULT} if $_->{RESULT};
          }
      }
  }
  
  =pod
  
  =item full_results
  
  Returns a list of child exit values as returned by C<wait>.  See L</results>
  if you don't care about coredumps or signals.
  
  Throws an exception if the harness is not in a finished state.
   
  =cut
  
  sub full_results {
      &_assert_finished;
      my IPC::Run $self = shift;
  
      croak "Harness not run" unless $self->{STATE} >= _finished;
      croak "Harness not finished running" unless $self->{STATE} == _finished;
  
      return map $_->{RESULT}, @{ $self->{KIDS} };
  }
  
  ##
  ## Filter Scaffolding
  ##
  use vars (
      '$filter_op',     ## The op running a filter chain right now
      '$filter_num',    ## Which filter is being run right now.
  );
  
  ##
  ## A few filters and filter constructors
  ##
  
  =pod
  
  =back
  
  =back
  
  =head1 FILTERS
  
  These filters are used to modify input our output between a child
  process and a scalar or subroutine endpoint.
  
  =over
  
  =item binary
  
     run \@cmd, ">", binary, \$out;
     run \@cmd, ">", binary, \$out;  ## Any TRUE value to enable
     run \@cmd, ">", binary 0, \$out;  ## Any FALSE value to disable
  
  This is a constructor for a "binmode" "filter" that tells IPC::Run to keep
  the carriage returns that would ordinarily be edited out for you (binmode
  is usually off).  This is not a real filter, but an option masquerading as
  a filter.
  
  It's not named "binmode" because you're likely to want to call Perl's binmode
  in programs that are piping binary data around.
  
  =cut
  
  sub binary(;$) {
      my $enable = @_ ? shift : 1;
      return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
  }
  
  =pod
  
  =item new_chunker
  
  This breaks a stream of data in to chunks, based on an optional
  scalar or regular expression parameter.  The default is the Perl
  input record separator in $/, which is a newline be default.
  
     run \@cmd, '>', new_chunker, \&lines_handler;
     run \@cmd, '>', new_chunker( "\r\n" ), \&lines_handler;
  
  Because this uses $/ by default, you should always pass in a parameter
  if you are worried about other code (modules, etc) modifying $/.
  
  If this filter is last in a filter chain that dumps in to a scalar,
  the scalar must be set to '' before a new chunk will be written to it.
  
  As an example of how a filter like this can be written, here's a
  chunker that splits on newlines:
  
     sub line_splitter {
        my ( $in_ref, $out_ref ) = @_;
  
        return 0 if length $$out_ref;
  
        return input_avail && do {
           while (1) {
              if ( $$in_ref =~ s/\A(.*?\n)// ) {
                 $$out_ref .= $1;
                 return 1;
              }
              my $hmm = get_more_input;
              unless ( defined $hmm ) {
                 $$out_ref = $$in_ref;
                 $$in_ref = '';
                 return length $$out_ref ? 1 : 0;
              }
              return 0 if $hmm eq 0;
           }
        }
     };
  
  =cut
  
  sub new_chunker(;$) {
      my ($re) = @_;
      $re = $/ if _empty $re;
      $re = quotemeta($re) unless ref $re eq 'Regexp';
      $re = qr/\A(.*?$re)/s;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return 0 if length $$out_ref;
  
          return input_avail && do {
              while (1) {
                  if ( $$in_ref =~ s/$re// ) {
                      $$out_ref .= $1;
                      return 1;
                  }
                  my $hmm = get_more_input;
                  unless ( defined $hmm ) {
                      $$out_ref = $$in_ref;
                      $$in_ref  = '';
                      return length $$out_ref ? 1 : 0;
                  }
                  return 0 if $hmm eq 0;
              }
            }
      };
  }
  
  =pod
  
  =item new_appender
  
  This appends a fixed string to each chunk of data read from the source
  scalar or sub.  This might be useful if you're writing commands to a
  child process that always must end in a fixed string, like "\n":
  
     run( \@cmd,
        '<', new_appender( "\n" ), \&commands,
     );
  
  Here's a typical filter sub that might be created by new_appender():
  
     sub newline_appender {
        my ( $in_ref, $out_ref ) = @_;
  
        return input_avail && do {
           $$out_ref = join( '', $$out_ref, $$in_ref, "\n" );
           $$in_ref = '';
           1;
        }
     };
  
  =cut
  
  sub new_appender($) {
      my ($suffix) = @_;
      croak "\$suffix undefined" unless defined $suffix;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
              $$in_ref = '';
              1;
            }
      };
  }
  
  =item new_string_source
  
  TODO: Needs confirmation. Was previously undocumented. in this module.
  
  This is a filter which is exportable. Returns a sub which appends the data passed in to the output buffer and returns 1 if data was appended. 0 if it was an empty string and undef if no data was passed. 
  
  NOTE: Any additional variables passed to new_string_source will be passed to the sub every time it's called and appended to the output. 
  
  =cut
  
  sub new_string_source {
      my $ref;
      if ( @_ > 1 ) {
          $ref = [@_],
      }
      else {
          $ref = shift;
      }
  
      return ref $ref eq 'SCALAR'
        ? sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return defined $$ref
            ? do {
              $$out_ref .= $$ref;
              my $r = length $$ref ? 1 : 0;
              $$ref = undef;
              $r;
            }
            : undef;
        }
        : sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return @$ref
            ? do {
              my $s = shift @$ref;
              $$out_ref .= $s;
              length $s ? 1 : 0;
            }
            : undef;
        }
  }
  
  =item new_string_sink
  
  TODO: Needs confirmation. Was previously undocumented.
  
  This is a filter which is exportable. Returns a sub which pops the data out of the input stream and pushes it onto the string.
  
  =cut
  
  sub new_string_sink {
      my ($string_ref) = @_;
  
      return sub {
          my ( $in_ref, $out_ref ) = @_;
  
          return input_avail && do {
              $$string_ref .= $$in_ref;
              $$in_ref = '';
              1;
            }
      };
  }
  
  #=item timeout
  #
  #This function defines a time interval, starting from when start() is
  #called, or when timeout() is called.  If all processes have not finished
  #by the end of the timeout period, then a "process timed out" exception
  #is thrown.
  #
  #The time interval may be passed in seconds, or as an end time in
  #"HH:MM:SS" format (any non-digit other than '.' may be used as
  #spacing and punctuation).  This is probably best shown by example:
  #
  #   $h->timeout( $val );
  #
  #   $val                     Effect
  #   ======================== =====================================
  #   undef                    Timeout timer disabled
  #   ''                       Almost immediate timeout
  #   0                        Almost immediate timeout
  #   0.000001                 timeout > 0.0000001 seconds
  #   30                       timeout > 30 seconds
  #   30.0000001               timeout > 30 seconds
  #   10:30                    timeout > 10 minutes, 30 seconds
  #
  #Timeouts are currently evaluated with a 1 second resolution, though
  #this may change in the future.  This means that setting
  #timeout($h,1) will cause a pokey child to be aborted sometime after
  #one second has elapsed and typically before two seconds have elapsed.
  #
  #This sub does not check whether or not the timeout has expired already.
  #
  #Returns the number of seconds set as the timeout (this does not change
  #as time passes, unless you call timeout( val ) again).
  #
  #The timeout does not include the time needed to fork() or spawn()
  #the child processes, though some setup time for the child processes can
  #included.  It also does not include the length of time it takes for
  #the children to exit after they've closed all their pipes to the
  #parent process.
  #
  #=cut
  #
  #sub timeout {
  #   my IPC::Run $self = shift;
  #
  #   if ( @_ ) {
  #      ( $self->{TIMEOUT} ) = @_;
  #      $self->{TIMEOUT_END} = undef;
  #      if ( defined $self->{TIMEOUT} ) {
  #	 if ( $self->{TIMEOUT} =~ /[^\d.]/ ) {
  #	    my @f = split( /[^\d\.]+/i, $self->{TIMEOUT} );
  #	    unshift @f, 0 while @f < 3;
  #	    $self->{TIMEOUT} = (($f[0]*60)+$f[1])*60+$f[2];
  #	 }
  #	 elsif ( $self->{TIMEOUT} =~ /^(\d*)(?:\.(\d*))/ ) {
  #	    $self->{TIMEOUT} = $1 + 1;
  #	 }
  #	 $self->_calc_timeout_end if $self->{STATE} >= _started;
  #      }
  #   }
  #   return $self->{TIMEOUT};
  #}
  #
  #
  #sub _calc_timeout_end {
  #   my IPC::Run $self = shift;
  #
  #   $self->{TIMEOUT_END} = defined $self->{TIMEOUT}
  #      ? time + $self->{TIMEOUT}
  #      : undef;
  #
  #   ## We add a second because we might be at the very end of the current
  #   ## second, and we want to guarantee that we don't have a timeout even
  #   ## one second less then the timeout period.
  #   ++$self->{TIMEOUT_END} if $self->{TIMEOUT};
  #}
  
  =pod
  
  =item io
  
  Takes a filename or filehandle, a redirection operator, optional filters,
  and a source or destination (depends on the redirection operator).  Returns
  an IPC::Run::IO object suitable for harness()ing (including via start()
  or run()).
  
  This is shorthand for 
  
  
     require IPC::Run::IO;
  
        ... IPC::Run::IO->new(...) ...
  
  =cut
  
  sub io {
      require IPC::Run::IO;
      IPC::Run::IO->new(@_);
  }
  
  =pod
  
  =item timer
  
     $h = start( \@cmd, \$in, \$out, $t = timer( 5 ) );
  
     pump $h until $out =~ /expected stuff/ || $t->is_expired;
  
  Instantiates a non-fatal timer.  pump() returns once each time a timer
  expires.  Has no direct effect on run(), but you can pass a subroutine
  to fire when the timer expires. 
  
  See L</timeout> for building timers that throw exceptions on
  expiration.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timer;
  *timer = \&IPC::Run::Timer::timer;
  
  =pod
  
  =item timeout
  
     $h = start( \@cmd, \$in, \$out, $t = timeout( 5 ) );
  
     pump $h until $out =~ /expected stuff/;
  
  Instantiates a timer that throws an exception when it expires.
  If you don't provide an exception, a default exception that matches
  /^IPC::Run: .*timed out/ is thrown by default.  You can pass in your own
  exception scalar or reference:
  
     $h = start(
        \@cmd, \$in, \$out,
        $t = timeout( 5, exception => 'slowpoke' ),
     );
  
  or set the name used in debugging message and in the default exception
  string:
  
     $h = start(
        \@cmd, \$in, \$out,
        timeout( 50, name => 'process timer' ),
        $stall_timer = timeout( 5, name => 'stall timer' ),
     );
  
     pump $h until $out =~ /started/;
  
     $in = 'command 1';
     $stall_timer->start;
     pump $h until $out =~ /command 1 finished/;
  
     $in = 'command 2';
     $stall_timer->start;
     pump $h until $out =~ /command 2 finished/;
  
     $in = 'very slow command 3';
     $stall_timer->start( 10 );
     pump $h until $out =~ /command 3 finished/;
  
     $stall_timer->start( 5 );
     $in = 'command 4';
     pump $h until $out =~ /command 4 finished/;
  
     $stall_timer->reset; # Prevent restarting or expirng
     finish $h;
  
  See L</timer> for building non-fatal timers.
  
  See L<IPC::Run::Timer/timer> for details.
  
  =cut
  
  # Doing the prototype suppresses 'only used once' on older perls.
  sub timeout;
  *timeout = \&IPC::Run::Timer::timeout;
  
  =pod
  
  =back
  
  =head1 FILTER IMPLEMENTATION FUNCTIONS
  
  These functions are for use from within filters.
  
  =over
  
  =item input_avail
  
  Returns TRUE if input is available.  If none is available, then 
  &get_more_input is called and its result is returned.
  
  This is usually used in preference to &get_more_input so that the
  calling filter removes all data from the $in_ref before more data
  gets read in to $in_ref.
  
  C<input_avail> is usually used as part of a return expression:
  
     return input_avail && do {
        ## process the input just gotten
        1;
     };
  
  This technique allows input_avail to return the undef or 0 that a
  filter normally returns when there's no input to process.  If a filter
  stores intermediate values, however, it will need to react to an
  undef:
  
     my $got = input_avail;
     if ( ! defined $got ) {
        ## No more input ever, flush internal buffers to $out_ref
     }
     return $got unless $got;
     ## Got some input, move as much as need be
     return 1 if $added_to_out_ref;
  
  =cut
  
  sub input_avail() {
      confess "Undefined FBUF ref for $filter_num+1"
        unless defined $filter_op->{FBUFS}->[ $filter_num + 1 ];
      length ${ $filter_op->{FBUFS}->[ $filter_num + 1 ] } || get_more_input;
  }
  
  =pod
  
  =item get_more_input
  
  This is used to fetch more input in to the input variable.  It returns
  undef if there will never be any more input, 0 if there is none now,
  but there might be in the future, and TRUE if more input was gotten.
  
  C<get_more_input> is usually used as part of a return expression,
  see L</input_avail> for more information.
  
  =cut
  
  ##
  ## Filter implementation interface
  ##
  sub get_more_input() {
      ++$filter_num;
      my $r = eval {
          confess "get_more_input() called and no more filters in chain"
            unless defined $filter_op->{FILTERS}->[$filter_num];
          $filter_op->{FILTERS}->[$filter_num]->(
              $filter_op->{FBUFS}->[ $filter_num + 1 ],
              $filter_op->{FBUFS}->[$filter_num],
          );    # if defined ${$filter_op->{FBUFS}->[$filter_num+1]};
      };
      --$filter_num;
      die $@ if $@;
      return $r;
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 TODO
  
  These will be addressed as needed and as time allows.
  
  Stall timeout.
  
  Expose a list of child process objects.  When I do this,
  each child process is likely to be blessed into IPC::Run::Proc.
  
  $kid->abort(), $kid->kill(), $kid->signal( $num_or_name ).
  
  Write tests for /(full_)?results?/ subs.
  
  Currently, pump() and run() only work on systems where select() works on the
  filehandles returned by pipe().  This does *not* include ActiveState on Win32,
  although it does work on cygwin under Win32 (thought the tests whine a bit).
  I'd like to rectify that, suggestions and patches welcome.
  
  Likewise start() only fully works on fork()/exec() machines (well, just
  fork() if you only ever pass perl subs as subprocesses).  There's
  some scaffolding for calling Open3::spawn_with_handles(), but that's
  untested, and not that useful with limited select().
  
  Support for C<\@sub_cmd> as an argument to a command which
  gets replaced with /dev/fd or the name of a temporary file containing foo's
  output.  This is like <(sub_cmd ...) found in bash and csh (IIRC).
  
  Allow multiple harnesses to be combined as independent sets of processes
  in to one 'meta-harness'.
  
  Allow a harness to be passed in place of an \@cmd.  This would allow
  multiple harnesses to be aggregated.
  
  Ability to add external file descriptors w/ filter chains and endpoints.
  
  Ability to add timeouts and timing generators (i.e. repeating timeouts).
  
  High resolution timeouts.
  
  =head1 Win32 LIMITATIONS
  
  =over
  
  =item argument-passing rules are program-specific
  
  Win32 programs receive all arguments in a single "command line" string.
  IPC::Run assembles this string so programs using L<standard command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>
  will see an C<argv> that matches the array reference specifying the command.
  Some programs use different rules to parse their command line.  Notable examples
  include F<cmd.exe>, F<cscript.exe>, and Cygwin programs called from non-Cygwin
  programs.  Use L<IPC::Run::Win32Process> to call these and other nonstandard
  programs.
  
  =item batch files
  
  Properly escaping a batch file argument depends on how the script will use that
  argument, because some uses experience multiple levels of caret (escape
  character) removal.  Avoid calling batch files with arguments, particularly when
  the argument values originate outside your program or contain non-alphanumeric
  characters.  Perl scripts and PowerShell scripts are sound alternatives.  If you
  do use batch file arguments, IPC::Run escapes them so the batch file can pass
  them, unquoted, to a program having standard command line parsing rules.  If the
  batch file enables delayed environment variable expansion, it must disable that
  feature before expanding its arguments.  For example, if F<foo.cmd> contains
  C<perl %*>, C<run ['foo.cmd', @list]> will create a Perl process in which
  C<@ARGV> matches C<@list>.  Prepending a C<setlocal enabledelayedexpansion> line
  would make the batch file malfunction, silently.  Another silent-malfunction
  example is C<run ['outer.bat', @list]> for F<outer.bat> containing C<foo.cmd
  %*>.
  
  =item Fails on Win9X
  
  If you want Win9X support, you'll have to debug it or fund me because I
  don't use that system any more.  The Win32 subsysem has been extended to
  use temporary files in simple run() invocations and these may actually
  work on Win9X too, but I don't have time to work on it.
  
  =item May deadlock on Win2K (but not WinNT4 or WinXPPro)
  
  Spawning more than one subprocess on Win2K causes a deadlock I haven't
  figured out yet, but simple uses of run() often work.  Passes all tests
  on WinXPPro and WinNT.
  
  =item no support yet for <pty< and >pty>
  
  These are likely to be implemented as "<" and ">" with binmode on, not
  sure.
  
  =item no support for file descriptors higher than 2 (stderr)
  
  Win32 only allows passing explicit fds 0, 1, and 2.  If you really, really need to pass file handles, us Win32API:: GetOsFHandle() or ::FdGetOsFHandle() to
  get the integer handle and pass it to the child process using the command
  line, environment, stdin, intermediary file, or other IPC mechanism.  Then
  use that handle in the child (Win32API.pm provides ways to reconstitute
  Perl file handles from Win32 file handles).
  
  =item no support for subroutine subprocesses (CODE refs)
  
  Can't fork(), so the subroutines would have no context, and closures certainly
  have no meaning
  
  Perhaps with Win32 fork() emulation, this can be supported in a limited
  fashion, but there are other very serious problems with that: all parent
  fds get dup()ed in to the thread emulating the forked process, and that
  keeps the parent from being able to close all of the appropriate fds.
  
  =item no support for init => sub {} routines.
  
  Win32 processes are created from scratch, there is no way to do an init
  routine that will affect the running child.  Some limited support might
  be implemented one day, do chdir() and %ENV changes can be made.
  
  =item signals
  
  Win32 does not fully support signals.  signal() is likely to cause errors
  unless sending a signal that Perl emulates, and C<kill_kill()> is immediately
  fatal (there is no grace period).
  
  =item C<$?> cannot represent all Win32 exit codes
  
  Prefer C<full_result( ... )>, C<result( ... )>, or other IPC::Run methods.
  
  =item helper processes
  
  IPC::Run uses helper processes, one per redirected file, to adapt between the
  anonymous pipe connected to the child and the TCP socket connected to the
  parent.  This is a waste of resources and will change in the future to either
  use threads (instead of helper processes) or a WaitForMultipleObjects call
  (instead of select).  Please contact me if you can help with the
  WaitForMultipleObjects() approach; I haven't figured out how to get at it
  without C code.
  
  =item shutdown pause
  
  There seems to be a pause of up to 1 second between when a child program exits
  and the corresponding sockets indicate that they are closed in the parent.
  Not sure why.
  
  =item binmode
  
  binmode is not supported yet.  The underpinnings are implemented, just ask
  if you need it.
  
  =item IPC::Run::IO
  
  IPC::Run::IO objects can be used on Unix to read or write arbitrary files.  On
  Win32, they will need to use the same helper processes to adapt from
  non-select()able filehandles to select()able ones (or perhaps
  WaitForMultipleObjects() will work with them, not sure).
  
  =item startup race conditions
  
  There seems to be an occasional race condition between child process startup
  and pipe closings.  It seems like if the child is not fully created by the time
  CreateProcess returns and we close the TCP socket being handed to it, the
  parent socket can also get closed.  This is seen with the Win32 pumper
  applications, not the "real" child process being spawned.
  
  I assume this is because the kernel hasn't gotten around to incrementing the
  reference count on the child's end (since the child was slow in starting), so
  the parent's closing of the child end causes the socket to be closed, thus
  closing the parent socket.
  
  Being a race condition, it's hard to reproduce, but I encountered it while
  testing this code on a drive share to a samba box.  In this case, it takes
  t/run.t a long time to spawn it's child processes (the parent hangs in the
  first select for several seconds until the child emits any debugging output).
  
  I have not seen it on local drives, and can't reproduce it at will,
  unfortunately.  The symptom is a "bad file descriptor in select()" error, and,
  by turning on debugging, it's possible to see that select() is being called on
  a no longer open file descriptor that was returned from the _socket() routine
  in Win32Helper.  There's a new confess() that checks for this ("PARENT_HANDLE
  no longer open"), but I haven't been able to reproduce it (typically).
  
  =back
  
  =head1 LIMITATIONS
  
  On Unix, requires a system that supports C<waitpid( $pid, WNOHANG )> so
  it can tell if a child process is still running.
  
  PTYs don't seem to be non-blocking on some versions of Solaris. Here's a
  test script contributed by Borislav Deianov <borislav@ensim.com> to see
  if you have the problem.  If it dies, you have the problem.
  
     #!/usr/bin/perl
  
     use IPC::Run qw(run);
     use Fcntl;
     use IO::Pty;
  
     sub makecmd {
         return ['perl', '-e', 
                 '<STDIN>, print "\n" x '.$_[0].'; while(<STDIN>){last if /end/}'];
     }
  
     #pipe R, W;
     #fcntl(W, F_SETFL, O_NONBLOCK);
     #while (syswrite(W, "\n", 1)) { $pipebuf++ };
     #print "pipe buffer size is $pipebuf\n";
     my $pipebuf=4096;
     my $in = "\n" x ($pipebuf * 2) . "end\n";
     my $out;
  
     $SIG{ALRM} = sub { die "Never completed!\n" };
  
     print "reading from scalar via pipe...";
     alarm( 2 );
     run(makecmd($pipebuf * 2), '<', \$in, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     print "reading from code via pipe... ";
     alarm( 2 );
     run(makecmd($pipebuf * 3), '<', sub { $t = $in; undef $in; $t}, '>', \$out);
     alarm( 0 );
     print "done\n";
  
     $pty = IO::Pty->new();
     $pty->blocking(0);
     $slave = $pty->slave();
     while ($pty->syswrite("\n", 1)) { $ptybuf++ };
     print "pty buffer size is $ptybuf\n";
     $in = "\n" x ($ptybuf * 3) . "end\n";
  
     print "reading via pty... ";
     alarm( 2 );
     run(makecmd($ptybuf * 3), '<pty<', \$in, '>', \$out);
     alarm(0);
     print "done\n";
  
  No support for ';', '&&', '||', '{ ... }', etc: use perl's, since run()
  returns TRUE when the command exits with a 0 result code.
  
  Does not provide shell-like string interpolation.
  
  No support for C<cd>, C<setenv>, or C<export>: do these in an init() sub
  
     run(
        \cmd,
           ...
           init => sub {
              chdir $dir or die $!;
              $ENV{FOO}='BAR'
           }
     );
  
  Timeout calculation does not allow absolute times, or specification of
  days, months, etc.
  
  B<WARNING:> Function coprocesses (C<run \&foo, ...>) suffer from two
  limitations.  The first is that it is difficult to close all filehandles the
  child inherits from the parent, since there is no way to scan all open
  FILEHANDLEs in Perl and it both painful and a bit dangerous to close all open
  file descriptors with C<POSIX::close()>. Painful because we can't tell which
  fds are open at the POSIX level, either, so we'd have to scan all possible fds
  and close any that we don't want open (normally C<exec()> closes any
  non-inheritable but we don't C<exec()> for &sub processes.
  
  The second problem is that Perl's DESTROY subs and other on-exit cleanup gets
  run in the child process.  If objects are instantiated in the parent before the
  child is forked, the DESTROY will get run once in the parent and once in
  the child.  When coprocess subs exit, POSIX::_exit is called to work around this,
  but it means that objects that are still referred to at that time are not
  cleaned up.  So setting package vars or closure vars to point to objects that
  rely on DESTROY to affect things outside the process (files, etc), will
  lead to bugs.
  
  I goofed on the syntax: "<pipe" vs. "<pty<" and ">filename" are both
  oddities.
  
  =head1 TODO
  
  =over
  
  =item Allow one harness to "adopt" another:
  
     $new_h = harness \@cmd2;
     $h->adopt( $new_h );
  
  =item Close all filehandles not explicitly marked to stay open.
  
  The problem with this one is that there's no good way to scan all open
  FILEHANDLEs in Perl, yet you don't want child processes inheriting handles
  willy-nilly.
  
  =back
  
  =head1 INSPIRATION
  
  Well, select() and waitpid() badly needed wrapping, and open3() isn't
  open-minded enough for me.
  
  The shell-like API inspired by a message Russ Allbery sent to perl5-porters,
  which included:
  
     I've thought for some time that it would be
     nice to have a module that could handle full Bourne shell pipe syntax
     internally, with fork and exec, without ever invoking a shell.  Something
     that you could give things like:
  
     pipeopen (PIPE, [ qw/cat file/ ], '|', [ 'analyze', @args ], '>&3');
  
  Message ylln51p2b6.fsf@windlord.stanford.edu, on 2000/02/04.
  
  =head1 SUPPORT
  
  Bugs should always be submitted via the GitHub bug tracker
  
  L<https://github.com/toddr/IPC-Run/issues>
  
  =head1 AUTHORS
  
  Adam Kennedy <adamk@cpan.org>
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 COPYRIGHT
  
  Some parts copyright 2008 - 2009 Adam Kennedy.
  
  Copyright 1999 Barrie Slaymaker.
  
  You may distribute under the terms of either the GNU General Public
  License or the Artistic License, as specified in the README file.
  
  =cut
IPC_RUN

$fatpacked{"IPC/Run/Debug.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_DEBUG';
  package IPC::Run::Debug;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Debug - debugging routines for IPC::Run
  
  =head1 SYNOPSIS
  
     ##
     ## Environment variable usage
     ##
     ## To force debugging off and shave a bit of CPU and memory
     ## by compile-time optimizing away all debugging code in IPC::Run
     ## (debug => ...) options to IPC::Run will be ignored.
     export IPCRUNDEBUG=none
  
     ## To force debugging on (levels are from 0..10)
     export IPCRUNDEBUG=basic
  
     ## Leave unset or set to "" to compile in debugging support and
     ## allow runtime control of it using the debug option.
  
  =head1 DESCRIPTION
  
  Controls IPC::Run debugging.  Debugging levels are now set by using words,
  but the numbers shown are still supported for backwards compatibility:
  
     0  none         disabled (special, see below)
     1  basic        what's running
     2  data         what's being sent/received
     3  details      what's going on in more detail
     4  gory         way too much detail for most uses
     10 all          use this when submitting bug reports
        noopts       optimizations forbidden due to inherited STDIN
  
  The C<none> level is special when the environment variable IPCRUNDEBUG
  is set to this the first time IPC::Run::Debug is loaded: it prevents
  the debugging code from being compiled in to the remaining IPC::Run modules,
  saving a bit of cpu.
  
  To do this in a script, here's a way that allows it to be overridden:
  
     BEGIN {
        unless ( defined $ENV{IPCRUNDEBUG} ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	    or die $@;
        }
     }
  
  This should force IPC::Run to not be debuggable unless somebody sets
  the IPCRUNDEBUG flag; modify this formula to grep @ARGV if need be:
  
     BEGIN {
        unless ( grep /^--debug/, @ARGV ) {
  	 eval 'local $ENV{IPCRUNDEBUG} = "none"; require IPC::Run::Debug"'
  	 or die $@;
     }
  
  Both of those are untested.
  
  =cut
  
  ## We use @EXPORT for the end user's convenience: there's only one function
  ## exported, it's homonymous with the module, it's an unusual name, and
  ## it can be suppressed by "use IPC::Run ();".
  
  use strict;
  use warnings;
  use Exporter;
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
  
  BEGIN {
      $VERSION = '20231003.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        _debug
        _debug_desc_fd
        _debugging
        _debugging_data
        _debugging_details
        _debugging_gory_details
        _debugging_not_optimized
        _set_child_debug_name
      );
  
      @EXPORT_OK = qw(
        _debug_init
        _debugging_level
        _map_fds
      );
      %EXPORT_TAGS = (
          default => \@EXPORT,
          all => [ @EXPORT, @EXPORT_OK ],
      );
  }
  
  my $disable_debugging = defined $ENV{IPCRUNDEBUG}
    && ( !$ENV{IPCRUNDEBUG}
      || lc $ENV{IPCRUNDEBUG} eq "none" );
  
  eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
  sub _map_fds()                 { "" }
  sub _debug                     {}
  sub _debug_desc_fd             {}
  sub _debug_init                {}
  sub _set_child_debug_name      {}
  sub _debugging()               { 0 }
  sub _debugging_level()         { 0 }
  sub _debugging_data()          { 0 }
  sub _debugging_details()       { 0 }
  sub _debugging_gory_details()  { 0 }
  sub _debugging_not_optimized() { 0 }
  
  1;
  STUBS
  
  use POSIX ();
  use constant Win32_MODE => $^O =~ /os2|Win32/i;
  
  # Replace Win32API::File::INVALID_HANDLE_VALUE, which does not match the C ABI
  # on 64-bit builds (https://github.com/chorny/Win32API-File/issues/13).
  use constant C_ABI_INVALID_HANDLE_VALUE => length( pack 'P', undef ) == 4
    ? 0xffffffff
    : 0xffffffff << 32 | 0xffffffff;
  
  sub _fd_is_open {
     my ($fd) = @_;
     if (Win32_MODE) {
        # Many OS functions can crash on closed FDs.  POSIX::close() can hang on
        # the read end of a pipe (https://github.com/Perl/perl5/issues/19963).
        # Borrow Gnulib's strategy.
        require Win32API::File;
        return Win32API::File::FdGetOsFHandle($fd) != C_ABI_INVALID_HANDLE_VALUE;
     }
     else {
        ## I'd like a quicker way (less user, cpu & especially sys and kernel
        ## calls) to detect open file descriptors.  Let me know...
        ## Hmmm, could do a 0 length read and check for bad file descriptor...
        my $test_fd = POSIX::dup( $fd );
        my $in_use = defined $test_fd;
        POSIX::close $test_fd if $in_use;
        return $in_use;
     }
  }
  
  sub _map_fds {
     my $map = '';
     my $digit = 0;
     my $dummy;
     for my $fd (0..63) {
        $map .= _fd_is_open($fd) ? $digit : '-';
        $digit = 0 if ++$digit > 9;
     }
     warn "No fds open???" unless $map =~ /\d/;
     $map =~ s/(.{1,12})-*$/$1/;
     return $map;
  }
  
  use vars qw( $parent_pid );
  
  $parent_pid = $$;
  
  ## TODO: move debugging to its own module and make it compile-time
  ## optimizable.
  
  ## Give kid process debugging nice names
  my $debug_name;
  
  sub _set_child_debug_name {
     $debug_name = shift;
  }
  
  ## There's a bit of hackery going on here.
  ##
  ## We want to have any code anywhere be able to emit
  ## debugging statements without knowing what harness the code is
  ## being called in/from, since we'd need to pass a harness around to
  ## everything.
  ##
  ## Thus, $cur_self was born.
  #
  my %debug_levels = (
     none    => 0,
     basic   => 1,
     data    => 2,
     details => 3,
     gore           => 4,
     gory_details   => 4,
     "gory details" => 4,
     gory           => 4,
     gorydetails    => 4,
     all     => 10,
     notopt  => 0,
  );
  
  my $warned;
  
  sub _debugging_level() {
     my $level = 0;
  
     $level = $IPC::Run::cur_self->{debug} || 0
        if $IPC::Run::cur_self
           && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
  
     if ( defined $ENV{IPCRUNDEBUG} ) {
        my $v = $ENV{IPCRUNDEBUG};
        $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
        unless ( defined $v ) {
  	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
  	 $v = 1;
        }
        $level = $v if $v > $level;
     }
     return $level;
  }
  
  sub _debugging_atleast($) {
     my $min_level = shift || 1;
  
     my $level = _debugging_level;
     
     return $level >= $min_level ? $level : 0;
  }
  
  sub _debugging()               { _debugging_atleast 1 }
  sub _debugging_data()          { _debugging_atleast 2 }
  sub _debugging_details()       { _debugging_atleast 3 }
  sub _debugging_gory_details()  { _debugging_atleast 4 }
  sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
  
  sub _debug_init {
     ## This routine is called only in spawned children to fake out the
     ## debug routines so they'll emit debugging info.
     $IPC::Run::cur_self = {};
     (  $parent_pid,
        $^T, 
        $IPC::Run::cur_self->{debug}, 
        $IPC::Run::cur_self->{DEBUG_FD}, 
        $debug_name 
     ) = @_;
  }
  
  
  sub _debug {
  #   return unless _debugging || _debugging_not_optimized;
  
     my $fd = defined &IPC::Run::_debug_fd
        ? IPC::Run::_debug_fd()
        : fileno STDERR;
  
     my $s;
     my $debug_id;
     $debug_id = join( 
        " ",
        join(
           "",
           defined $IPC::Run::cur_self && defined $IPC::Run::cur_self->{ID}
           ? "#$IPC::Run::cur_self->{ID}"
           : (),
           "($$)",
        ),
        defined $debug_name && length $debug_name ? $debug_name        : (),
     );
     my $prefix = join(
        "",
        "IPC::Run",
        sprintf( " %04d", time - $^T ),
        ( _debugging_details ? ( " ", _map_fds ) : () ),
        length $debug_id ? ( " [", $debug_id, "]" ) : (),
        ": ",
     );
  
     my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
     chomp $msg;
     $msg =~ s{^}{$prefix}gm;
     $msg .= "\n";
     POSIX::write( $fd, $msg, length $msg );
  }
  
  
  my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
  
  sub _debug_desc_fd {
     return unless _debugging;
     my $text = shift;
     my $op = pop;
     my $kid = $_[0];
  
  Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
  
     _debug(
        $text,
        ' ',
        ( defined $op->{FD}
           ? $op->{FD} < 3
              ? ( $fd_descs[$op->{FD}] )
              : ( 'fd ', $op->{FD} )
           : $op->{FD}
        ),
        ( defined $op->{KFD}
           ? (
              ' (kid',
              ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
              "'s ",
              ( $op->{KFD} < 3
                 ? $fd_descs[$op->{KFD}]
                 : defined $kid
                    && defined $kid->{DEBUG_FD}
                    && $op->{KFD} == $kid->{DEBUG_FD}
                    ? ( 'debug (', $op->{KFD}, ')' )
                    : ( 'fd ', $op->{KFD} )
              ),
              ')',
           )
           : ()
        ),
     );
  }
  
  1;
  
  SUBS
  
  =pod
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>, with numerous suggestions by p5p.
  
  =cut
IPC_RUN_DEBUG

$fatpacked{"IPC/Run/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_IO';
  package IPC::Run::IO;
  
  =head1 NAME
  
  IPC::Run::IO -- I/O channels for IPC::Run.
  
  =head1 SYNOPSIS
  
  B<NOT IMPLEMENTED YET ON Win32! Win32 does not allow select() on
  normal file descriptors; IPC::RUN::IO needs to use IPC::Run::Win32Helper
  to do this.>
  
     use IPC::Run qw( io );
  
     ## The sense of '>' and '<' is opposite of perl's open(),
     ## but agrees with IPC::Run.
     $io = io( "filename", '>',  \$recv );
     $io = io( "filename", 'r',  \$recv );
  
     ## Append to $recv:
     $io = io( "filename", '>>', \$recv );
     $io = io( "filename", 'ra', \$recv );
  
     $io = io( "filename", '<',  \$send );
     $io = io( "filename", 'w',  \$send );
  
     $io = io( "filename", '<<', \$send );
     $io = io( "filename", 'wa', \$send );
  
     ## Handles / IO objects that the caller opens:
     $io = io( \*HANDLE,   '<',  \$send );
  
     $f = IO::Handle->new( ... ); # Any subclass of IO::Handle
     $io = io( $f, '<', \$send );
  
     require IPC::Run::IO;
     $io = IPC::Run::IO->new( ... );
  
     ## Then run(), harness(), or start():
     run $io, ...;
  
     ## You can, of course, use io() or IPC::Run::IO->new() as an
     ## argument to run(), harness, or start():
     run io( ... );
  
  =head1 DESCRIPTION
  
  This class and module allows filehandles and filenames to be harnessed for
  I/O when used IPC::Run, independent of anything else IPC::Run is doing
  (except that errors & exceptions can affect all things that IPC::Run is
  doing).
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: due to the awkwardness introduced in ripping pseudohashes
  out of Perl, this class I<no longer> uses the fields pragma.
  
  =cut
  
  ## This class is also used internally by IPC::Run in a very intimate way,
  ## since this is a partial factoring of code from IPC::Run plus some code
  ## needed to do standalone channels.  This factoring process will continue
  ## at some point.  Don't know how far how fast.
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  
  use IPC::Run::Debug;
  use IPC::Run qw( Win32_MODE );
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20231003.0';
      if (Win32_MODE) {
          eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
            or ( $@ && die )
            or die "$!";
      }
  }
  
  sub _empty($);
  *_empty = \&IPC::Run::_empty;
  
  =head1 SUBROUTINES
  
  =over 4
  
  =item new
  
  I think it takes >> or << along with some other data.
  
  TODO: Needs more thorough documentation. Patches welcome.
  
  =cut
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my ( $external, $type, $internal ) = ( shift, shift, pop );
  
      croak "$class: '$_' is not a valid I/O operator"
        unless $type =~ /^(?:<<?|>>?)$/;
  
      my IPC::Run::IO $self = $class->_new_internal( $type, undef, undef, $internal, undef, @_ );
  
      if ( !ref $external ) {
          $self->{FILENAME} = $external;
      }
      elsif ( ref $external eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
          $self->{HANDLE}     = $external;
          $self->{DONT_CLOSE} = 1;
      }
      else {
          croak "$class: cannot accept " . ref($external) . " to do I/O with";
      }
  
      return $self;
  }
  
  ## IPC::Run uses this ctor, since it preparses things and needs more
  ## smarts.
  sub _new_internal {
      my $class = shift;
      $class = ref $class || $class;
  
      $class = "IPC::Run::Win32IO"
        if Win32_MODE && $class eq "IPC::Run::IO";
  
      my IPC::Run::IO $self;
      $self = bless {}, $class;
  
      my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
  
      # Older perls (<=5.00503, at least) don't do list assign to
      # pseudo-hashes well.
      $self->{TYPE}   = $type;
      $self->{KFD}    = $kfd;
      $self->{PTY_ID} = $pty_id;
      $self->binmode($binmode);
      $self->{FILTERS} = [@filters];
  
      ## Add an adapter to the end of the filter chain (which is usually just the
      ## read/writer sub pushed by IPC::Run) to the DEST or SOURCE, if need be.
      if ( $self->op =~ />/ ) {
          croak "'$_' missing a destination" if _empty $internal;
          $self->{DEST} = $internal;
          if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
              ## Put a filter on the end of the filter chain to pass the
              ## output on to the CODE ref.  For SCALAR refs, the last
              ## filter in the chain writes directly to the scalar itself.  See
              ## _init_filters().  For CODE refs, however, we need to adapt from
              ## the SCALAR to calling the CODE.
              unshift(
                  @{ $self->{FILTERS} },
                  sub {
                      my ($in_ref) = @_;
  
                      return IPC::Run::input_avail() && do {
                          $self->{DEST}->($$in_ref);
                          $$in_ref = '';
                          1;
                        }
                  }
              );
          }
      }
      else {
          croak "'$_' missing a source" if _empty $internal;
          $self->{SOURCE} = $internal;
          if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      return undef
                        if $self->{SOURCE_EMPTY};
  
                      my $in = $internal->();
                      unless ( defined $in ) {
                          $self->{SOURCE_EMPTY} = 1;
                          return undef;
                      }
                      return 0 unless length $in;
                      $$out_ref = $in;
  
                      return 1;
                  }
              );
          }
          elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
              push(
                  @{ $self->{FILTERS} },
                  sub {
                      my ( $in_ref, $out_ref ) = @_;
                      return 0 if length $$out_ref;
  
                      ## pump() clears auto_close_ins, finish() sets it.
                      return $self->{HARNESS}->{auto_close_ins} ? undef : 0
                        if IPC::Run::_empty ${ $self->{SOURCE} }
                        || $self->{SOURCE_EMPTY};
  
                      $$out_ref = $$internal;
                      eval { $$internal = '' }
                        if $self->{HARNESS}->{clear_ins};
  
                      $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
  
                      return 1;
                  }
              );
          }
      }
  
      return $self;
  }
  
  =item filename
  
  Gets/sets the filename.  Returns the value after the name change, if
  any.
  
  =cut
  
  sub filename {
      my IPC::Run::IO $self = shift;
      $self->{FILENAME} = shift if @_;
      return $self->{FILENAME};
  }
  
  =item init
  
  Does initialization required before this can be run.  This includes open()ing
  the file, if necessary, and clearing the destination scalar if necessary.
  
  =cut
  
  sub init {
      my IPC::Run::IO $self = shift;
  
      $self->{SOURCE_EMPTY} = 0;
      ${ $self->{DEST} } = ''
        if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
  
      $self->open if defined $self->filename;
      $self->{FD} = $self->fileno;
  
      if ( !$self->{FILTERS} ) {
          $self->{FBUFS} = undef;
      }
      else {
          @{ $self->{FBUFS} } = map {
              my $s = "";
              \$s;
          } ( @{ $self->{FILTERS} }, '' );
  
          $self->{FBUFS}->[0] = $self->{DEST}
            if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
          push @{ $self->{FBUFS} }, $self->{SOURCE};
      }
  
      return undef;
  }
  
  =item open
  
  If a filename was passed in, opens it.  Determines if the handle is open
  via fileno().  Throws an exception on error.
  
  =cut
  
  my %open_flags = (
      '>'  => O_RDONLY,
      '>>' => O_RDONLY,
      '<'  => O_WRONLY | O_CREAT | O_TRUNC,
      '<<' => O_WRONLY | O_CREAT | O_APPEND,
  );
  
  sub open {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: Can't open() a file with no name"
        unless defined $self->{FILENAME};
      $self->{HANDLE} = gensym unless $self->{HANDLE};
  
      _debug "opening '", $self->filename, "' mode '", $self->mode, "'"
        if _debugging_data;
      sysopen(
          $self->{HANDLE},
          $self->filename,
          $open_flags{ $self->op },
      ) or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
  
      return undef;
  }
  
  =item open_pipe
  
  If this is a redirection IO object, this opens the pipe in a platform
  independent manner.
  
  =cut
  
  sub _do_open {
      my $self = shift;
      my ( $child_debug_fd, $parent_handle ) = @_;
  
      if ( $self->dir eq "<" ) {
          ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
          if ($parent_handle) {
              CORE::open $parent_handle, ">&=$self->{FD}"
                or croak "$! duping write end of pipe for caller";
          }
      }
      else {
          ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
          if ($parent_handle) {
              CORE::open $parent_handle, "<&=$self->{FD}"
                or croak "$! duping read end of pipe for caller";
          }
      }
  }
  
  sub open_pipe {
      my IPC::Run::IO $self = shift;
  
      ## Hmmm, Maybe allow named pipes one day.  But until then...
      croak "IPC::Run::IO: Can't pipe() when a file name has been set"
        if defined $self->{FILENAME};
  
      $self->_do_open(@_);
  
      ## return ( child_fd, parent_fd )
      return $self->dir eq "<"
        ? ( $self->{TFD}, $self->{FD} )
        : ( $self->{FD}, $self->{TFD} );
  }
  
  sub _cleanup {    ## Called from Run.pm's _cleanup
      my $self = shift;
      undef $self->{FAKE_PIPE};
  }
  
  =item close
  
  Closes the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub close {
      my IPC::Run::IO $self = shift;
  
      if ( defined $self->{HANDLE} ) {
          close $self->{HANDLE}
            or croak(
              "IPC::Run::IO: $! closing "
                . (
                  defined $self->{FILENAME}
                  ? "'$self->{FILENAME}'"
                  : "handle"
                )
            );
      }
      else {
          IPC::Run::_close( $self->{FD} );
      }
  
      $self->{FD} = undef;
  
      return undef;
  }
  
  =item fileno
  
  Returns the fileno of the handle.  Throws an exception on failure.
  
  
  =cut
  
  sub fileno {
      my IPC::Run::IO $self = shift;
  
      my $fd = fileno $self->{HANDLE};
      croak(
          "IPC::Run::IO: $! "
            . (
              defined $self->{FILENAME}
              ? "'$self->{FILENAME}'"
              : "handle"
            )
      ) unless defined $fd;
  
      return $fd;
  }
  
  =item mode
  
  Returns the operator in terms of 'r', 'w', and 'a'.  There is a state
  'ra', unlike Perl's open(), which indicates that data read from the
  handle or file will be appended to the output if the output is a scalar.
  This is only meaningful if the output is a scalar, it has no effect if
  the output is a subroutine.
  
  The redirection operators can be a little confusing, so here's a reference
  table:
  
     >      r      Read from handle in to process
     <      w      Write from process out to handle
     >>     ra     Read from handle in to process, appending it to existing
                   data if the destination is a scalar.
     <<     wa     Write from process out to handle, appending to existing
                   data if IPC::Run::IO opened a named file.
  
  =cut
  
  sub mode {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
  
      ## TODO: Optimize this
      return ( $self->{TYPE} =~ /</ ? 'w' : 'r' ) . ( $self->{TYPE} =~ /<<|>>/ ? 'a' : '' );
  }
  
  =item op
  
  Returns the operation: '<', '>', '<<', '>>'.  See L</mode> if you want
  to spell these 'r', 'w', etc.
  
  =cut
  
  sub op {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
  
      return $self->{TYPE};
  }
  
  =item binmode
  
  Sets/gets whether this pipe is in binmode or not.  No effect off of Win32
  OSs, of course, and on Win32, no effect after the harness is start()ed.
  
  =cut
  
  sub binmode {
      my IPC::Run::IO $self = shift;
  
      $self->{BINMODE} = shift if @_;
  
      return $self->{BINMODE};
  }
  
  =item dir
  
  Returns the first character of $self->op.  This is either "<" or ">".
  
  =cut
  
  sub dir {
      my IPC::Run::IO $self = shift;
  
      croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
  
      return substr $self->{TYPE}, 0, 1;
  }
  
  ##
  ## Filter Scaffolding
  ##
  #my $filter_op ;        ## The op running a filter chain right now
  #my $filter_num;        ## Which filter is being run right now.
  
  use vars (
      '$filter_op',    ## The op running a filter chain right now
      '$filter_num'    ## Which filter is being run right now.
  );
  
  sub _init_filters {
      my IPC::Run::IO $self = shift;
  
      confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
      $self->{FBUFS} = [];
  
      $self->{FBUFS}->[0] = $self->{DEST}
        if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
  
      return unless $self->{FILTERS} && @{ $self->{FILTERS} };
  
      push @{ $self->{FBUFS} }, map {
          my $s = "";
          \$s;
      } ( @{ $self->{FILTERS} }, '' );
  
      push @{ $self->{FBUFS} }, $self->{SOURCE};
  }
  
  =item poll
  
  TODO: Needs confirmation that this is correct. Was previously undocumented.
  
  I believe this is polling the IO for new input and then returns undef if there will never be any more input, 0 if there is none now, but there might be in the future, and TRUE if more input was gotten.
  
  =cut
  
  sub poll {
      my IPC::Run::IO $self = shift;
      my ($harness) = @_;
  
      if ( defined $self->{FD} ) {
          my $d = $self->dir;
          if ( $d eq "<" ) {
              if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data to", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
          elsif ( $d eq ">" ) {
              if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
                  _debug_desc_fd( "filtering data from", $self )
                    if _debugging_details;
                  return $self->_do_filters($harness);
              }
          }
      }
      return 0;
  }
  
  sub _do_filters {
      my IPC::Run::IO $self = shift;
  
      ( $self->{HARNESS} ) = @_;
  
      my ( $saved_op, $saved_num ) = ( $IPC::Run::filter_op, $IPC::Run::filter_num );
      $IPC::Run::filter_op  = $self;
      $IPC::Run::filter_num = -1;
      my $redos = 0;
      my $r;
      {
          $@ = '';
          $r = eval { IPC::Run::get_more_input(); };
  
          # Detect Resource temporarily unavailable and re-try 200 times (2 seconds),  assuming select behaves (which it doesn't always? need ref)
          if ( ( $@ || '' ) =~ $IPC::Run::_EAGAIN && $redos++ < 200 ) {
              select( undef, undef, undef, 0.01 );
              redo;
          }
      }
      ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
      $self->{HARNESS} = undef;
      die "ack ", $@ if $@;
      return $r;
  }
  
  =back
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =head1 TODO
  
  Implement bidirectionality.
  
  =cut
  
  1;
IPC_RUN_IO

$fatpacked{"IPC/Run/Timer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_TIMER';
  package IPC::Run::Timer;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Timer -- Timer channels for IPC::Run.
  
  =head1 SYNOPSIS
  
     use IPC::Run qw( run  timer timeout );
     ## or IPC::Run::Timer ( timer timeout );
     ## or IPC::Run::Timer ( :all );
  
     ## A non-fatal timer:
     $t = timer( 5 ); # or...
     $t = IO::Run::Timer->new( 5 );
     run $t, ...;
  
     ## A timeout (which is a timer that dies on expiry):
     $t = timeout( 5 ); # or...
     $t = IO::Run::Timer->new( 5, exception => "harness timed out" );
  
  =head1 DESCRIPTION
  
  This class and module allows timers and timeouts to be created for use
  by IPC::Run.  A timer simply expires when it's time is up.  A timeout
  is a timer that throws an exception when it expires.
  
  Timeouts are usually a bit simpler to use  than timers: they throw an
  exception on expiration so you don't need to check them:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timeout( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/;
  
  You do need to check timers:
  
     ## Give @cmd 10 seconds to get started, then 5 seconds to respond
     my $t = timer( 10 );
     $h = start(
        \@cmd, \$in, \$out,
        $t,
     );
     pump $h until $t->is_expired || $out =~ /prompt/;
  
     $in = "some stimulus";
     $out = '';
     $t->time( 5 )
     pump $h until $out =~ /expected response/ || $t->is_expired;
  
  Timers and timeouts that are reset get started by start() and
  pump().  Timers change state only in pump().  Since run() and
  finish() both call pump(), they act like pump() with respect to
  timers.
  
  Timers and timeouts have three states: reset, running, and expired.
  Setting the timeout value resets the timer, as does calling
  the reset() method.  The start() method starts (or restarts) a
  timer with the most recently set time value, no matter what state
  it's in.
  
  =head2 Time values
  
  All time values are in seconds.  Times may be any kind of perl number,
  e.g. as integer or floating point seconds, optionally preceded by
  punctuation-separated days, hours, and minutes.
  
  Examples:
  
     1           1 second
     1.1         1.1 seconds
     60          60 seconds
     1:0         1 minute
     1:1         1 minute, 1 second
     1:90        2 minutes, 30 seconds
     1:2:3:4.5   1 day, 2 hours, 3 minutes, 4.5 seconds
     'inf'       the infinity perl special number (the timer never finishes)
  
  Absolute date/time strings are *not* accepted: year, month and
  day-of-month parsing is not available (patches welcome :-).
  
  =head2 Interval fudging
  
  When calculating an end time from a start time and an interval, IPC::Run::Timer
  instances add a little fudge factor.  This is to ensure that no time will
  expire before the interval is up.
  
  First a little background.  Time is sampled in discrete increments.  We'll
  call the
  exact moment that the reported time increments from one interval to the
  next a tick, and the interval between ticks as the time period.  Here's
  a diagram of three ticks and the periods between them:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                   ^                   ^
      |<--- period 0 ---->|<--- period 1 ---->|
      |                   |                   |
    tick 0              tick 1              tick 2
  
  To see why the fudge factor is necessary, consider what would happen
  when a timer with an interval of 1 second is started right at the end of
  period 0:
  
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^                   ^
      |                |  |                   |
      |                |  |                   |
    tick 0             |tick 1              tick 2
                       |
                   start $t
  
  Assuming that check() is called many times per period, then the timer
  is likely to expire just after tick 1, since the time reported will have
  lept from the value '0' to the value '1':
  
      -0-0-0-0-0-0-0-0-0-0-1-1-1-1-1-1-1-1-1-1-2-...
      ^                ^  ^   ^               ^
      |                |  |   |               |
      |                |  |   |               |
    tick 0             |tick 1|             tick 2
                       |      |
                   start $t   |
  		            |
  			check $t
  
  Adding a fudge of '1' in this example means that the timer is guaranteed
  not to expire before tick 2.
  
  The fudge is not added to an interval of '0'.
  
  This means that intervals guarantee a minimum interval.  Given that
  the process running perl may be suspended for some period of time, or that
  it gets busy doing something time-consuming, there are no other guarantees on
  how long it will take a timer to expire.
  
  =head1 SUBCLASSING
  
  INCOMPATIBLE CHANGE: Due to the awkwardness introduced by ripping
  pseudohashes out of Perl, this class I<no longer> uses the fields
  pragma.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use Fcntl;
  use Symbol;
  use Exporter;
  use Scalar::Util ();
  use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
  
  BEGIN {
      $VERSION   = '20231003.0';
      @ISA       = qw( Exporter );
      @EXPORT_OK = qw(
        check
        end_time
        exception
        expire
        interval
        is_expired
        is_reset
        is_running
        name
        reset
        start
        timeout
        timer
      );
  
      %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
  }
  
  require IPC::Run;
  use IPC::Run::Debug;
  
  ##
  ## Some helpers
  ##
  my $resolution = 1;
  
  sub _parse_time {
      for ( $_[0] ) {
          my $val;
          if ( not defined $_ ) {
              $val = $_;
          }
          else {
              my @f = split( /:/, $_, -1 );
              if ( scalar @f > 4 ) {
                  croak "IPC::Run: expected <= 4 elements in time string '$_'";
              }
              for (@f) {
                  if ( not Scalar::Util::looks_like_number($_) ) {
                      croak "IPC::Run: non-numeric element '$_' in time string '$_'";
                  }
              }
              my ( $s, $m, $h, $d ) = reverse @f;
              $val = ( ( ( $d || 0 ) * 24 + ( $h || 0 ) ) * 60 + ( $m || 0 ) ) * 60 + ( $s || 0 );
          }
          return $val;
      }
  }
  
  sub _calc_end_time {
      my IPC::Run::Timer $self = shift;
      my $interval = $self->interval;
      $interval += $resolution if $interval;
      $self->end_time( $self->start_time + $interval );
  }
  
  =item timer
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timer( 5 );
     $t = timer( 5, name => 'stall timer', debug => 1 );
  
     $t = timer;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timer( 5 );
  
  This convenience function is a shortened spelling of
  
     IPC::Run::Timer->new( ... );
     
  .  It returns a timer in the reset state with a given interval.
  
  If an exception is provided, it will be thrown when the timer notices that
  it has expired (in check()).  The name is for debugging usage, if you plan on
  having multiple timers around.  If no name is provided, a name like "timer #1"
  will be provided.
  
  =cut
  
  sub timer {
      return IPC::Run::Timer->new(@_);
  }
  
  =item timeout
  
  A constructor function (not method) of IPC::Run::Timer instances:
  
     $t = timeout( 5 );
     $t = timeout( 5, exception => "kablooey" );
     $t = timeout( 5, name => "stall", exception => "kablooey" );
  
     $t = timeout;
     $t->interval( 5 );
  
     run ..., $t;
     run ..., $t = timeout( 5 );
  
  A This convenience function is a shortened spelling of 
  
     IPC::Run::Timer->new( exception => "IPC::Run: timeout ...", ... );
     
  .  It returns a timer in the reset state that will throw an
  exception when it expires.
  
  Takes the same parameters as L</timer>, any exception passed in overrides
  the default exception.
  
  =cut
  
  sub timeout {
      my $t = IPC::Run::Timer->new(@_);
      $t->exception( "IPC::Run: timeout on " . $t->name )
        unless defined $t->exception;
      return $t;
  }
  
  =item new
  
     IPC::Run::Timer->new()  ;
     IPC::Run::Timer->new( 5 )  ;
     IPC::Run::Timer->new( 5, exception => 'kablooey' )  ;
  
  Constructor.  See L</timer> for details.
  
  =cut
  
  my $timer_counter;
  
  sub new {
      my $class = shift;
      $class = ref $class || $class;
  
      my IPC::Run::Timer $self = bless {}, $class;
  
      $self->{STATE} = 0;
      $self->{DEBUG} = 0;
      $self->{NAME}  = "timer #" . ++$timer_counter;
  
      while (@_) {
          my $arg = shift;
          if ( $arg eq 'exception' ) {
              $self->exception(shift);
          }
          elsif ( $arg eq 'name' ) {
              $self->name(shift);
          }
          elsif ( $arg eq 'debug' ) {
              $self->debug(shift);
          }
          else {
              $self->interval($arg);
          }
      }
  
      _debug $self->name . ' constructed'
        if $self->{DEBUG} || _debugging_details;
  
      return $self;
  }
  
  =item check
  
     check $t;
     check $t, $now;
     $t->check;
  
  Checks to see if a timer has expired since the last check.  Has no effect
  on non-running timers.  This will throw an exception if one is defined.
  
  IPC::Run::pump() calls this routine for any timers in the harness.
  
  You may pass in a version of now, which is useful in case you have
  it lying around or you want to check several timers with a consistent
  concept of the current time.
  
  Returns the time left before end_time or 0 if end_time is no longer
  in the future or the timer is not running
  (unless, of course, check() expire()s the timer and this
  results in an exception being thrown).
  
  Returns undef if the timer is not running on entry, 0 if check() expires it,
  and the time left if it's left running.
  
  =cut
  
  sub check {
      my IPC::Run::Timer $self = shift;
      return undef if !$self->is_running;
      return 0     if $self->is_expired;
  
      my ($now) = @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      _debug( "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now ) if $self->{DEBUG} || _debugging_details;
  
      my $left = $self->end_time - $now;
      return $left if $left > 0;
  
      $self->expire;
      return 0;
  }
  
  =item debug
  
  Sets/gets the current setting of the debugging flag for this timer.  This
  has no effect if debugging is not enabled for the current harness.
  
  =cut
  
  sub debug {
      my IPC::Run::Timer $self = shift;
      $self->{DEBUG} = shift if @_;
      return $self->{DEBUG};
  }
  
  =item end_time
  
     $et = $t->end_time;
     $et = end_time $t;
  
     $t->end_time( time + 10 );
  
  Returns the time when this timer will or did expire.  Even if this time is
  in the past, the timer may not be expired, since check() may not have been
  called yet.
  
  Note that this end_time is not start_time($t) + interval($t), since some
  small extra amount of time is added to make sure that the timer does not
  expire before interval() elapses.  If this were not so, then 
  
  Changing end_time() while a timer is running will set the expiration time.
  Changing it while it is expired has no affect, since reset()ing a timer always
  clears the end_time().
  
  =cut
  
  sub end_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{END_TIME} = shift;
          _debug $self->name, ' end_time set to ', $self->{END_TIME}
            if $self->{DEBUG} > 2 || _debugging_details;
      }
      return $self->{END_TIME};
  }
  
  =item exception
  
     $x = $t->exception;
     $t->exception( $x );
     $t->exception( undef );
  
  Sets/gets the exception to throw, if any.  'undef' means that no
  exception will be thrown.  Exception does not need to be a scalar: you 
  may ask that references be thrown.
  
  =cut
  
  sub exception {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{EXCEPTION} = shift;
          _debug $self->name, ' exception set to ', $self->{EXCEPTION}
            if $self->{DEBUG} || _debugging_details;
      }
      return $self->{EXCEPTION};
  }
  
  =item interval
  
     $i = interval $t;
     $i = $t->interval;
     $t->interval( $i );
  
  Sets the interval.  Sets the end time based on the start_time() and the
  interval (and a little fudge) if the timer is running.
  
  =cut
  
  sub interval {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{INTERVAL} = _parse_time(shift);
          _debug $self->name, ' interval set to ', $self->{INTERVAL}
            if $self->{DEBUG} > 2 || _debugging_details;
  
          $self->_calc_end_time if $self->state;
      }
      return $self->{INTERVAL};
  }
  
  =item expire
  
     expire $t;
     $t->expire;
  
  Sets the state to expired (undef).
  Will throw an exception if one
  is defined and the timer was not already expired.  You can expire a
  reset timer without starting it.
  
  =cut
  
  sub expire {
      my IPC::Run::Timer $self = shift;
      if ( defined $self->state ) {
          _debug $self->name . ' expired'
            if $self->{DEBUG} || _debugging;
  
          $self->state(undef);
          croak $self->exception if $self->exception;
      }
      return undef;
  }
  
  =item is_running
  
  =cut
  
  sub is_running {
      my IPC::Run::Timer $self = shift;
      return $self->state ? 1 : 0;
  }
  
  =item is_reset
  
  =cut
  
  sub is_reset {
      my IPC::Run::Timer $self = shift;
      return defined $self->state && $self->state == 0;
  }
  
  =item is_expired
  
  =cut
  
  sub is_expired {
      my IPC::Run::Timer $self = shift;
      return !defined $self->state;
  }
  
  =item name
  
  Sets/gets this timer's name.  The name is only used for debugging
  purposes so you can tell which freakin' timer is doing what.
  
  =cut
  
  sub name {
      my IPC::Run::Timer $self = shift;
  
      $self->{NAME} = shift if @_;
      return
          defined $self->{NAME}      ? $self->{NAME}
        : defined $self->{EXCEPTION} ? 'timeout'
        :                              'timer';
  }
  
  =item reset
  
     reset $t;
     $t->reset;
  
  Resets the timer to the non-running, non-expired state and clears
  the end_time().
  
  =cut
  
  sub reset {
      my IPC::Run::Timer $self = shift;
      $self->state(0);
      $self->end_time(undef);
      _debug $self->name . ' reset'
        if $self->{DEBUG} || _debugging;
  
      return undef;
  }
  
  =item start
  
     start $t;
     $t->start;
     start $t, $interval;
     start $t, $interval, $now;
  
  Starts or restarts a timer.  This always sets the start_time.  It sets the
  end_time based on the interval if the timer is running or if no end time
  has been set.
  
  You may pass an optional interval or current time value.
  
  Not passing a defined interval causes the previous interval setting to be
  re-used unless the timer is reset and an end_time has been set
  (an exception is thrown if no interval has been set).  
  
  Not passing a defined current time value causes the current time to be used.
  
  Passing a current time value is useful if you happen to have a time value
  lying around or if you want to make sure that several timers are started
  with the same concept of start time.  You might even need to lie to an
  IPC::Run::Timer, occasionally.
  
  =cut
  
  sub start {
      my IPC::Run::Timer $self = shift;
  
      my ( $interval, $now ) = map { _parse_time($_) } @_;
      $now = _parse_time($now);
      $now = time unless defined $now;
  
      $self->interval($interval) if defined $interval;
  
      ## start()ing a running or expired timer clears the end_time, so that the
      ## interval is used.  So does specifying an interval.
      $self->end_time(undef) if !$self->is_reset || $interval;
  
      croak "IPC::Run: no timer interval or end_time defined for " . $self->name
        unless defined $self->interval || defined $self->end_time;
  
      $self->state(1);
      $self->start_time($now);
      ## The "+ 1" is in case the START_TIME was sampled at the end of a
      ## tick (which are one second long in this module).
      $self->_calc_end_time
        unless defined $self->end_time;
  
      _debug(
          $self->name, " started at ", $self->start_time,
          ", with interval ", $self->interval, ", end_time ", $self->end_time
      ) if $self->{DEBUG} || _debugging;
      return undef;
  }
  
  =item start_time
  
  Sets/gets the start time, in seconds since the epoch.  Setting this manually
  is a bad idea, it's better to call L</start>() at the correct time.
  
  =cut
  
  sub start_time {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{START_TIME} = _parse_time(shift);
          _debug $self->name, ' start_time set to ', $self->{START_TIME}
            if $self->{DEBUG} > 2 || _debugging;
      }
  
      return $self->{START_TIME};
  }
  
  =item state
  
     $s = state $t;
     $t->state( $s );
  
  Get/Set the current state.  Only use this if you really need to transfer the
  state to/from some variable.
  Use L</expire>, L</start>, L</reset>, L</is_expired>, L</is_running>,
  L</is_reset>.
  
  Note:  Setting the state to 'undef' to expire a timer will not throw an
  exception.
  
  =back
  
  =cut
  
  sub state {
      my IPC::Run::Timer $self = shift;
      if (@_) {
          $self->{STATE} = shift;
          _debug $self->name, ' state set to ', $self->{STATE}
            if $self->{DEBUG} > 2 || _debugging;
      }
      return $self->{STATE};
  }
  
  1;
  
  =pod
  
  =head1 TODO
  
  use Time::HiRes; if it's present.
  
  Add detection and parsing of [[[HH:]MM:]SS formatted times and intervals.
  
  =head1 AUTHOR
  
  Barrie Slaymaker <barries@slaysys.com>
  
  =cut
IPC_RUN_TIMER

$fatpacked{"IPC/Run/Win32Helper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32HELPER';
  package IPC::Run::Win32Helper;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Helper - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32Helper;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select() loop
  will work on Win32. This seems to only work on WinNT and Win2K at this time, not
  sure if it will ever work on Win95 or Win98. If you have experience in this area, please
  contact me at barries@slaysys.com, thanks!.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use vars qw{ $VERSION @ISA @EXPORT };
  
  BEGIN {
      $VERSION = '20231003.0';
      @ISA     = qw( Exporter );
      @EXPORT  = qw(
        win32_spawn
        win32_parse_cmd_line
        _dont_inherit
        _inherit
      );
  }
  
  require POSIX;
  
  use File::Spec ();
  use Text::ParseWords;
  use Win32 ();
  use Win32::Process;
  use Win32::ShellQuote ();
  use IPC::Run::Debug;
  use Win32API::File qw(
    FdGetOsFHandle
    SetHandleInformation
    HANDLE_FLAG_INHERIT
  );
  
  # Replace Win32API::File::INVALID_HANDLE_VALUE, which does not match the C ABI
  # on 64-bit builds (https://github.com/chorny/Win32API-File/issues/13).
  use constant C_ABI_INVALID_HANDLE_VALUE => length( pack 'P', undef ) == 4
    ? 0xffffffff
    : 0xffffffff << 32 | 0xffffffff;
  
  ## Takes an fd or a GLOB ref, never never never a Win32 handle.
  sub _dont_inherit {
      for (@_) {
          next unless defined $_;
          my $fd = $_;
          $fd = fileno $fd if ref $fd;
          _debug "disabling inheritance of ", $fd if _debugging_details;
          my $osfh = FdGetOsFHandle $fd;
  
          # Contrary to documentation, $! has the failure reason
          # (https://github.com/chorny/Win32API-File/issues/14)
          croak "$!: FdGetOsFHandle( $fd )"
            if !defined $osfh || $osfh == C_ABI_INVALID_HANDLE_VALUE;
  
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
      }
  }
  
  sub _inherit {    #### REMOVE
      for (@_) {    #### REMOVE
          next unless defined $_;    #### REMOVE
          my $fd = $_;               #### REMOVE
          $fd = fileno $fd if ref $fd;    #### REMOVE
          _debug "enabling inheritance of ", $fd if _debugging_details;    #### REMOVE
          my $osfh = FdGetOsFHandle $fd;                                   #### REMOVE
  
          # Contrary to documentation, $! has the failure reason
          # (https://github.com/chorny/Win32API-File/issues/14)
          croak "$!: FdGetOsFHandle( $fd )"
            if !defined $osfh || $osfh == C_ABI_INVALID_HANDLE_VALUE;
          #### REMOVE
          SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );           #### REMOVE
      }    #### REMOVE
  }    #### REMOVE
  #### REMOVE
  #sub _inherit {
  #   for ( @_ ) {
  #      next unless defined $_;
  #      my $osfh = GetOsFHandle $_;
  #      croak $^E if ! defined $osfh || $osfh == INVALID_HANDLE_VALUE;
  #      SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, HANDLE_FLAG_INHERIT );
  #   }
  #}
  
  =pod
  
  =head1 FUNCTIONS
  
  =over
  
  =item optimize()
  
  Most common incantations of C<run()> (I<not> C<harness()>, C<start()>,
  or C<finish()>) now use temporary files to redirect input and output
  instead of pumper processes.
  
  Temporary files are used when sending to child processes if input is
  taken from a scalar with no filter subroutines.  This is the only time
  we can assume that the parent is not interacting with the child's
  redirected input as it runs.
  
  Temporary files are used when receiving from children when output is
  to a scalar or subroutine with or without filters, but only if
  the child in question closes its inputs or takes input from 
  unfiltered SCALARs or named files.  Normally, a child inherits its STDIN
  from its parent; to close it, use "0<&-" or the C<< noinherit => 1 >> option.
  If data is sent to the child from CODE refs, filehandles or from
  scalars through filters than the child's outputs will not be optimized
  because C<optimize()> assumes the parent is interacting with the child.
  It is ok if the output is filtered or handled by a subroutine, however.
  
  This assumes that all named files are real files (as opposed to named
  pipes) and won't change; and that a process is not communicating with
  the child indirectly (through means not visible to IPC::Run).
  These can be an invalid assumptions, but are the 99% case.
  Write me if you need an option to enable or disable optimizations; I
  suspect it will work like the C<binary()> modifier.
  
  To detect cases that you might want to optimize by closing inputs, try
  setting the C<IPCRUNDEBUG> environment variable to the special C<notopt>
  value:
  
     C:> set IPCRUNDEBUG=notopt
     C:> my_app_that_uses_IPC_Run.pl
  
  =item optimizer() rationalizations
  
  Only for that limited case can we be sure that it's ok to batch all the
  input in to a temporary file.  If STDIN is from a SCALAR or from a named
  file or filehandle (again, only in C<run()>), then outputs to CODE refs
  are also assumed to be safe enough to batch through a temp file,
  otherwise only outputs to SCALAR refs are batched.  This can cause a bit
  of grief if the parent process benefits from or relies on a bit of
  "early returns" coming in before the child program exits.  As long as
  the output is redirected to a SCALAR ref, this will not be visible.
  When output is redirected to a subroutine or (deprecated) filters, the
  subroutine will not get any data until after the child process exits,
  and it is likely to get bigger chunks of data at once.
  
  The reason for the optimization is that, without it, "pumper" processes
  are used to overcome the inconsistencies of the Win32 API.  We need to
  use anonymous pipes to connect to the child processes' stdin, stdout,
  and stderr, yet select() does not work on these.  select() only works on
  sockets on Win32.  So for each redirected child handle, there is
  normally a "pumper" process that connects to the parent using a
  socket--so the parent can select() on that fd--and to the child on an
  anonymous pipe--so the child can read/write a pipe.
  
  Using a socket to connect directly to the child (as at least one MSDN
  article suggests) seems to cause the trailing output from most children
  to be lost.  I think this is because child processes rarely close their
  stdout and stderr explicitly, and the winsock dll does not seem to flush
  output when a process that uses it exits without explicitly closing
  them.
  
  Because of these pumpers and the inherent slowness of Win32
  CreateProcess(), child processes with redirects are quite slow to
  launch; so this routine looks for the very common case of
  reading/writing to/from scalar references in a run() routine and
  converts such reads and writes in to temporary file reads and writes.
  
  Such files are marked as FILE_ATTRIBUTE_TEMPORARY to increase speed and
  as FILE_FLAG_DELETE_ON_CLOSE so it will be cleaned up when the child
  process exits (for input files).  The user's default permissions are
  used for both the temporary files and the directory that contains them,
  hope your Win32 permissions are secure enough for you.  Files are
  created with the Win32API::File defaults of
  FILE_SHARE_READ|FILE_SHARE_WRITE.
  
  Setting the debug level to "details" or "gory" will give detailed
  information about the optimization process; setting it to "basic" or
  higher will tell whether or not a given call is optimized.  Setting
  it to "notopt" will highlight those calls that aren't optimized.
  
  =cut
  
  sub optimize {
      my ($h) = @_;
  
      my @kids = @{ $h->{KIDS} };
  
      my $saw_pipe;
  
      my ( $ok_to_optimize_outputs, $veto_output_optimization );
  
      for my $kid (@kids) {
          ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
            unless $saw_pipe;
  
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
            if _debugging_details && $ok_to_optimize_outputs;
          _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
            if _debugging_details && $veto_output_optimization;
  
          if ( $h->{noinherit} && !$ok_to_optimize_outputs ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
                if _debugging_details && $ok_to_optimize_outputs;
              $ok_to_optimize_outputs = 1;
          }
  
          for ( @{ $kid->{OPS} } ) {
              if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
                  if ( $_->{TYPE} eq "<" ) {
                      if ( @{ $_->{FILTERS} } > 1 ) {
                          ## Can't assume that the filters are idempotent.
                      }
                      elsif (ref $_->{SOURCE} eq "SCALAR"
                          || ref $_->{SOURCE} eq "GLOB"
                          || UNIVERSAL::isa( $_, "IO::Handle" ) ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
                                ref $_->{SOURCE},
                                ", ok to optimize outputs"
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          $_->{SEND_THROUGH_TEMP_FILE} = 1;
                          next;
                      }
                      elsif ( !ref $_->{SOURCE} && defined $_->{SOURCE} ) {
                          if ( $_->{KFD} == 0 ) {
                              _debug
                                "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
                                if _debugging_details;
                              $ok_to_optimize_outputs = 1;
                          }
                          next;
                      }
                  }
                  _debug
                    "Win32 optimizer: (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{SOURCE}
                    ? ref $_->{SOURCE}
                        ? ref $_->{SOURCE}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } > 1 ? " with filters" : (),
                    ", VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
                  $veto_output_optimization = 1;
              }
              elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
                  $ok_to_optimize_outputs = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
                    if _debugging_details;
              }
              elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
                  $veto_output_optimization = 1;
                  _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
                    if _debugging_details || _debugging_not_optimized;
              }
              elsif ( $_->{TYPE} eq "|" ) {
                  $saw_pipe = 1;
              }
          }
  
          if ( !$ok_to_optimize_outputs && !$veto_output_optimization ) {
              _debug "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
                if _debugging_details || _debugging_not_optimized;
              $veto_output_optimization = 1;
          }
  
          if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
              $ok_to_optimize_outputs = 0;
              _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
                if _debugging_details || _debugging_not_optimized;
          }
  
          ## SOURCE/DEST ARRAY means it's a filter.
          ## TODO: think about checking to see if the final input/output of
          ## a filter chain (an ARRAY SOURCE or DEST) is a scalar...but
          ## we may be deprecating filters.
  
          for ( @{ $kid->{OPS} } ) {
              if ( $_->{TYPE} eq ">" ) {
                  if (
                      ref $_->{DEST} eq "SCALAR"
                      || (
                          (
                                 @{ $_->{FILTERS} } > 1
                              || ref $_->{DEST} eq "CODE"
                              || ref $_->{DEST} eq "ARRAY"    ## Filters?
                          )
                          && ( $ok_to_optimize_outputs && !$veto_output_optimization )
                      )
                    ) {
                      $_->{RECV_THROUGH_TEMP_FILE} = 1;
                      next;
                  }
                  _debug
                    "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
                    $_->{KFD},
                    $_->{TYPE},
                    defined $_->{DEST}
                    ? ref $_->{DEST}
                        ? ref $_->{DEST}
                        : $_->{SOURCE}
                    : defined $_->{FILENAME} ? $_->{FILENAME}
                    : "",
                    @{ $_->{FILTERS} } ? " with filters" : (),
                    if _debugging_details;
              }
          }
      }
  
  }
  
  =pod
  
  =item win32_parse_cmd_line
  
     @words = win32_parse_cmd_line( q{foo bar 'baz baz' "bat bat"} );
  
  returns 4 words. This parses like the bourne shell (see
  the bit about shellwords() in L<Text::ParseWords>), assuming we're
  trying to be a little cross-platform here.  The only difference is
  that "\" is *not* treated as an escape except when it precedes 
  punctuation, since it's used all over the place in DOS path specs.
  
  TODO: strip caret escapes?
  
  TODO: use
  https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments
  
  TODO: globbing? probably not (it's unDOSish).
  
  TODO: shebang emulation? Probably, but perhaps that should be part
  of Run.pm so all spawned processes get the benefit.
  
  LIMITATIONS: shellwords dies silently on malformed input like 
  
     a\"
  
  =cut
  
  sub win32_parse_cmd_line {
      my $line = shift;
      $line =~ s{(\\[\w\s])}{\\$1}g;
      return shellwords $line;
  }
  
  =pod
  
  =item win32_spawn
  
  Spawns a child process, possibly with STDIN, STDOUT, and STDERR (file descriptors 0, 1, and 2, respectively) redirected.
  
  B<LIMITATIONS>.
  
  Cannot redirect higher file descriptors due to lack of support for this in the
  Win32 environment.
  
  This can be worked around by marking a handle as inheritable in the
  parent (or leaving it marked; this is the default in perl), obtaining it's
  Win32 handle with C<Win32API::GetOSFHandle(FH)> or
  C<Win32API::FdGetOsFHandle($fd)> and passing it to the child using the command
  line, the environment, or any other IPC mechanism (it's a plain old integer).
  The child can then use C<OsFHandleOpen()> or C<OsFHandleOpenFd()> and possibly
  C<<open FOO ">&BAR">> or C<<open FOO ">&$fd>> as need be.  Ach, the pain!
  
  =cut
  
  sub _save {
      my ( $saved, $saved_as, $fd ) = @_;
  
      ## We can only save aside the original fds once.
      return if exists $saved->{$fd};
  
      my $saved_fd = IPC::Run::_dup($fd);
      _dont_inherit $saved_fd;
  
      $saved->{$fd}          = $saved_fd;
      $saved_as->{$saved_fd} = $fd;
  
      _dont_inherit $saved->{$fd};
  }
  
  sub _dup2_gently {
      my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
      _save $saved, $saved_as, $fd2;
  
      if ( exists $saved_as->{$fd2} ) {
          ## The target fd is colliding with a saved-as fd, gotta bump
          ## the saved-as fd to another fd.
          my $orig_fd  = delete $saved_as->{$fd2};
          my $saved_fd = IPC::Run::_dup($fd2);
          _dont_inherit $saved_fd;
  
          $saved->{$orig_fd}     = $saved_fd;
          $saved_as->{$saved_fd} = $orig_fd;
      }
      _debug "moving $fd1 to kid's $fd2" if _debugging_details;
      IPC::Run::_dup2_rudely( $fd1, $fd2 );
  }
  
  sub win32_spawn {
      my ( $cmd, $ops ) = @_;
  
      my ( $app, $cmd_line );
      my $need_pct = 0;
      if ( UNIVERSAL::isa( $cmd, 'IPC::Run::Win32Process' ) ) {
          $app      = $cmd->{lpApplicationName};
          $cmd_line = $cmd->{lpCommandLine};
      }
      elsif ( $cmd->[0] !~ /\.(bat|cmd) *$/i ) {
          $app      = $cmd->[0];
          $cmd_line = Win32::ShellQuote::quote_native(@$cmd);
      }
      else {
          # Batch file, so follow the batch-specific guidance of
          # https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa
          # There's no one true way to locate cmd.exe.  In the unlikely event that
          # %COMSPEC% is missing, fall back on a Windows API.  We could search
          # %PATH% like _wsystem() does.  That would be prone to security bugs,
          # and one fallback is enough.
          $app = (
              $ENV{COMSPEC}
                || File::Spec->catfile(
                  Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                  'cmd.exe'
                )
          );
  
          # Win32 rejects attempts to create files with names containing certain
          # characters.  Ignore most, but reject the subset that might otherwise
          # cause us to execute the wrong file instead of failing cleanly.
          if ( $cmd->[0] =~ /["\r\n\0]/ ) {
              croak "invalid batch file name";
          }
  
          # Make cmd.exe see the batch file name as quoted.  Suppose we instead
          # used caret escapes, as we do for arguments.  cmd.exe could then "break
          # the command token at the first occurrence of <space> , ; or ="
          # (https://stackoverflow.com/a/4095133).
          my @parts = qq{"$cmd->[0]"};
  
          # cmd.exe will strip escapes once when parsing our $cmd_line and again
          # where the batch file injects the argument via %*, %1, etc.  Compensate
          # by adding one extra cmd_escape layer.
          if ( @$cmd > 1 ) {
              my @q = Win32::ShellQuote::quote_cmd( @{$cmd}[ 1 .. $#{$cmd} ] );
              push @parts, map { Win32::ShellQuote::cmd_escape($_) } @q;
          }
  
          # One can't stop cmd.exe from expanding %var%, so inject each literal %
          # via an environment variable.  Delete that variable before the real
          # child can see it.  See
          # https://www.dostips.com/forum/viewtopic.php?f=3&t=10131 for more on
          # this technique and the limitations of alternatives.
          $cmd_line = join ' ', @parts;
          if ( $cmd_line =~ s/%/%ipcrunpct%/g ) {
              $cmd_line = qq{/c "set "ipcrunpct=" & $cmd_line"};
              $need_pct = 1;
          }
          else {
              $cmd_line = qq{/c "$cmd_line"};
          }
      }
      _debug "app: ", $app
        if _debugging;
      _debug "cmd line: ", $cmd_line
        if _debugging;
  
      ## NOTE: The debug pipe write handle is passed to pump processes as STDOUT.
      ## and is not to the "real" child process, since they would not know
      ## what to do with it...unlike Unix, we have no code executing in the
      ## child before the "real" child is exec()ed.
  
      my %saved;       ## Map of parent's orig fd -> saved fd
      my %saved_as;    ## Map of parent's saved fd -> orig fd, used to
      ## detect collisions between a KFD and the fd a
      ## parent's fd happened to be saved to.
  
      for my $op (@$ops) {
          _dont_inherit $op->{FD} if defined $op->{FD};
  
          if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
              ## TODO: Detect this in harness()
              ## TODO: enable temporary redirections if ever necessary, not
              ## sure why they would be...
              ## 4>&1 1>/dev/null 1>&4 4>&-
              croak "Can't redirect fd #", $op->{KFD}, " on Win32";
          }
  
          ## This is very similar logic to IPC::Run::_do_kid_and_exit().
          if ( defined $op->{TFD} ) {
              unless ( $op->{TFD} == $op->{KFD} ) {
                  _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
                  _dont_inherit $op->{TFD};
              }
          }
          elsif ( $op->{TYPE} eq "dup" ) {
              _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
                unless $op->{KFD1} == $op->{KFD2};
          }
          elsif ( $op->{TYPE} eq "close" ) {
              _save \%saved, \%saved_as, $op->{KFD};
              IPC::Run::_close( $op->{KFD} );
          }
          elsif ( $op->{TYPE} eq "init" ) {
              ## TODO: detect this in harness()
              croak "init subs not allowed on Win32";
          }
      }
  
      local $ENV{ipcrunpct} = '%' if $need_pct;
      my $process;
      Win32::Process::Create(
          $process,
          $app,
          $cmd_line,
          1,    ## Inherit handles
          0,    ## Inherit parent priority class. Was NORMAL_PRIORITY_CLASS
          ".",
        )
        or do {
          my $err = Win32::FormatMessage( Win32::GetLastError() );
          $err =~ s/\r?\n$//s;
          croak "$err: Win32::Process::Create()";
        };
  
      for my $orig_fd ( keys %saved ) {
          IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
          IPC::Run::_close( $saved{$orig_fd} );
      }
  
      return ( $process->GetProcessID(), $process );
  }
  
  1;
  
  =pod
  
  =back
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32HELPER

$fatpacked{"IPC/Run/Win32IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32IO';
  package IPC::Run::Win32IO;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32IO - helper routines for IPC::Run on Win32 platforms.
  
  =head1 SYNOPSIS
  
      use IPC::Run::Win32IO;   # Exports all by default
  
  =head1 DESCRIPTION
  
  IPC::Run needs to use sockets to redirect subprocess I/O so that the select()
  loop will work on Win32. This seems to only work on WinNT and Win2K at this
  time, not sure if it will ever work on Win95 or Win98. If you have experience
  in this area, please contact me at barries@slaysys.com, thanks!.
  
  =head1 DESCRIPTION
  
  A specialized IO class used on Win32.
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  use IO::Handle;
  use Socket;
  require POSIX;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20231003.0';
  }
  
  use Socket qw( IPPROTO_TCP TCP_NODELAY );
  use Symbol;
  use Text::ParseWords;
  use Win32::Process;
  use IPC::Run::Debug qw( :default _debugging_level );
  use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
  use Fcntl qw( O_TEXT O_RDONLY );
  
  use base qw( IPC::Run::IO );
  my @cleanup_fields;
  
  BEGIN {
      ## These fields will be set to undef in _cleanup to close
      ## the handles.
      @cleanup_fields = (
          'SEND_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'RECV_THROUGH_TEMP_FILE',    ## Set by WinHelper::optimize()
          'TEMP_FILE_NAME',            ## The name of the temp file, needed for
          ## error reporting / debugging only.
  
          'PARENT_HANDLE',             ## The handle of the socket for the parent
          'PUMP_SOCKET_HANDLE',        ## The socket handle for the pump
          'PUMP_PIPE_HANDLE',          ## The anon pipe handle for the pump
          'CHILD_HANDLE',              ## The anon pipe handle for the child
  
          'TEMP_FILE_HANDLE',          ## The Win32 filehandle for the temp file
      );
  }
  
  ## REMOVE OSFHandleOpen
  use Win32API::File qw(
    GetOsFHandle
    OsFHandleOpenFd
    OsFHandleOpen
    FdGetOsFHandle
    SetHandleInformation
    SetFilePointer
    HANDLE_FLAG_INHERIT
  
    createFile
    WriteFile
    ReadFile
    CloseHandle
  
    FILE_ATTRIBUTE_TEMPORARY
    FILE_FLAG_DELETE_ON_CLOSE
    FILE_FLAG_WRITE_THROUGH
  
    FILE_BEGIN
  );
  
  #   FILE_ATTRIBUTE_HIDDEN
  #   FILE_ATTRIBUTE_SYSTEM
  
  BEGIN {
      ## Force AUTOLOADED constants to be, well, constant by getting them
      ## to AUTOLOAD before compilation continues.  Sigh.
      () = (
          SOL_SOCKET,
          SO_REUSEADDR,
          IPPROTO_TCP,
          TCP_NODELAY,
          HANDLE_FLAG_INHERIT,
      );
  }
  
  use constant temp_file_flags => ( FILE_ATTRIBUTE_TEMPORARY() | FILE_FLAG_DELETE_ON_CLOSE() | FILE_FLAG_WRITE_THROUGH() );
  
  #   FILE_ATTRIBUTE_HIDDEN()    |
  #   FILE_ATTRIBUTE_SYSTEM()    |
  my $tmp_file_counter;
  my $tmp_dir;
  
  sub _cleanup {
      my IPC::Run::Win32IO $self = shift;
      my ($harness) = @_;
  
      $self->_recv_through_temp_file($harness)
        if $self->{RECV_THROUGH_TEMP_FILE};
  
      CloseHandle( $self->{TEMP_FILE_HANDLE} )
        if defined $self->{TEMP_FILE_HANDLE};
  
      close( $self->{CHILD_HANDLE} )
        if defined $self->{CHILD_HANDLE};
  
      $self->{$_} = undef for @cleanup_fields;
  }
  
  sub _create_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## Create a hidden temp file that Win32 will delete when we close
      ## it.
      unless ( defined $tmp_dir ) {
          $tmp_dir = File::Spec->catdir( File::Spec->tmpdir, "IPC-Run.tmp" );
  
          ## Trust in the user's umask.
          ## This could possibly be a security hole, perhaps
          ## we should offer an option.  Hmmmm, really, people coding
          ## security conscious apps should audit this code and
          ## tell me how to make it better.  Nice cop-out :).
          unless ( -d $tmp_dir ) {
              mkdir $tmp_dir or croak "$!: $tmp_dir";
          }
      }
  
      $self->{TEMP_FILE_NAME} = File::Spec->catfile(
          ## File name is designed for easy sorting and not conflicting
          ## with other processes.  This should allow us to use "t"runcate
          ## access in CreateFile in case something left some droppings
          ## around (which should never happen because we specify
          ## FLAG_DELETE_ON_CLOSE.
          ## heh, belt and suspenders are better than bug reports; God forbid
          ## that NT should ever crash before a temp file gets deleted!
          $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
      );
  
      $self->{TEMP_FILE_HANDLE} = createFile(
          $self->{TEMP_FILE_NAME},
          "trw",    ## new, truncate, read, write
          {
              Flags => temp_file_flags,
          },
      ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
  
      $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
      $self->{FD} = undef;
  
      _debug
        "Win32 Optimizer: temp file (",
        $self->{KFD},
        $self->{TYPE},
        $self->{TFD},
        ", fh ",
        $self->{TEMP_FILE_HANDLE},
        "): ",
        $self->{TEMP_FILE_NAME}
        if _debugging_details;
  }
  
  sub _reset_temp_file_pointer {
      my $self = shift;
      SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
        or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
  }
  
  sub _send_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      _debug "Win32 optimizer: optimizing " . " $self->{KFD} $self->{TYPE} temp file instead of ",
        ref $self->{SOURCE} || $self->{SOURCE}
        if _debugging_details;
  
      $self->_create_temp_file;
  
      if ( defined ${ $self->{SOURCE} } ) {
          my $bytes_written = 0;
          my $data_ref;
          if ( $self->binmode ) {
              $data_ref = $self->{SOURCE};
          }
          else {
              my $data = ${ $self->{SOURCE} };    # Ugh, a copy.
              $data =~ s/(?<!\r)\n/\r\n/g;
              $data_ref = \$data;
          }
  
          WriteFile(
              $self->{TEMP_FILE_HANDLE},
              $$data_ref,
              0,                                  ## Write entire buffer
              $bytes_written,
              [],                                 ## Not overlapped.
          ) or croak "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
          _debug "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
            if _debugging_data;
  
          $self->_reset_temp_file_pointer;
  
      }
  
      _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
        if _debugging_details;
  }
  
  sub _init_recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      $self->_create_temp_file;
  }
  
  ## TODO: Use the Win32 API in the select loop to see if the file has grown
  ## and read it incrementally if it has.
  sub _recv_through_temp_file {
      my IPC::Run::Win32IO $self = shift;
  
      ## This next line kicks in if the run() never got to initting things
      ## and needs to clean up.
      return undef unless defined $self->{TEMP_FILE_HANDLE};
  
      push @{ $self->{FILTERS} }, sub {
          my ( undef, $out_ref ) = @_;
  
          return undef unless defined $self->{TEMP_FILE_HANDLE};
  
          my $r;
          my $s;
          ReadFile(
              $self->{TEMP_FILE_HANDLE},
              $s,
              999_999,    ## Hmmm, should read the size.
              $r,
              []
          ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
  
          _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
  
          return undef unless $r;
  
          $s =~ s/\r\n/\n/g unless $self->binmode;
  
          my $pos = pos $$out_ref;
          $$out_ref .= $s;
          pos($out_ref) = $pos;
          return 1;
      };
  
      my ($harness) = @_;
  
      $self->_reset_temp_file_pointer;
  
      1 while $self->_do_filters($harness);
  
      pop @{ $self->{FILTERS} };
  
      IPC::Run::_close( $self->{TFD} );
  }
  
  =head1 SUBROUTINES
  
  =over
  
  =item poll
  
  Windows version of IPC::Run::IP::poll.
  
  =back
  
  =cut
  
  sub poll {
      my IPC::Run::Win32IO $self = shift;
  
      return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
  
      return $self->SUPER::poll(@_);
  }
  
  ## When threaded Perls get good enough, we should use threads here.
  ## The problem with threaded perls is that they dup() all sorts of
  ## filehandles and fds and don't allow sufficient control over
  ## closing off the ones we don't want.
  
  sub _spawn_pumper {
      my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
      my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
  
      _debug "pumper stdin = ",  $stdin_fd  if _debugging_details;
      _debug "pumper stdout = ", $stdout_fd if _debugging_details;
      _inherit $stdin_fd, $stdout_fd, $debug_fd;
      my @I_options = map qq{"-I$_"}, @INC;
  
      my $cmd_line = join(
          " ",
          qq{"$^X"},
          @I_options,
          qw(-MIPC::Run::Win32Pump -e 1 ),
  ## I'm using this clunky way of passing filehandles to the child process
  ## in order to avoid some kind of premature closure of filehandles
  ## problem I was having with VCP's test suite when passing them
  ## via CreateProcess.  All of the ## REMOVE code is stuff I'd like
  ## to be rid of and the ## ADD code is what I'd like to use.
          FdGetOsFHandle($stdin_fd),     ## REMOVE
          FdGetOsFHandle($stdout_fd),    ## REMOVE
          FdGetOsFHandle($debug_fd),     ## REMOVE
          $binmode ? 1 : 0,
          $$, $^T, _debugging_level, qq{"$child_label"},
          @opts
      );
  
      #   open SAVEIN,  "<&STDIN"  or croak "$! saving STDIN";       #### ADD
      #   open SAVEOUT, ">&STDOUT" or croak "$! saving STDOUT";       #### ADD
      #   open SAVEERR, ">&STDERR" or croak "$! saving STDERR";       #### ADD
      #   _dont_inherit \*SAVEIN;       #### ADD
      #   _dont_inherit \*SAVEOUT;       #### ADD
      #   _dont_inherit \*SAVEERR;       #### ADD
      #   open STDIN,  "<&$stdin_fd"  or croak "$! dup2()ing $stdin_fd (pumper's STDIN)";       #### ADD
      #   open STDOUT, ">&$stdout_fd" or croak "$! dup2()ing $stdout_fd (pumper's STDOUT)";       #### ADD
      #   open STDERR, ">&$debug_fd" or croak "$! dup2()ing $debug_fd (pumper's STDERR/debug_fd)";       #### ADD
  
      _debug "pump cmd line: ", $cmd_line if _debugging_details;
  
      my $process;
      Win32::Process::Create(
          $process,
          $^X,
          $cmd_line,
          1,    ## Inherit handles
          NORMAL_PRIORITY_CLASS,
          ".",
      ) or croak "$!: Win32::Process::Create()";
  
      #   open STDIN,  "<&SAVEIN"  or croak "$! restoring STDIN";       #### ADD
      #   open STDOUT, ">&SAVEOUT" or croak "$! restoring STDOUT";       #### ADD
      #   open STDERR, ">&SAVEERR" or croak "$! restoring STDERR";       #### ADD
      #   close SAVEIN             or croak "$! closing SAVEIN";       #### ADD
      #   close SAVEOUT            or croak "$! closing SAVEOUT";       #### ADD
      #   close SAVEERR            or croak "$! closing SAVEERR";       #### ADD
  
      # In case of a sleep right here, need the IPC::Run::_close() treatment.
      IPC::Run::_close fileno($stdin);
      close $stdin;
      IPC::Run::_close fileno($stdout);
      close $stdout;
  
      # Don't close $debug_fd, we need it, as do other pumpers.
  
      # Pause a moment to allow the child to get up and running and emit
      # debug messages.  This does not always work.
      #   select undef, undef, undef, 1 if _debugging_details;
  
      _debug "_spawn_pumper pid = ", $process->GetProcessID
        if _debugging_data;
  }
  
  my $loopback  = inet_aton "127.0.0.1";
  my $tcp_proto = getprotobyname('tcp');
  croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
  
  sub _socket {
      my ($server) = @_;
      $server ||= gensym;
      my $client = gensym;
  
      my $listener = gensym;
      socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
        or croak "$!: socket()";
      setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack( "l", 0 )
        or croak "$!: setsockopt()";
  
      unless ( bind $listener, sockaddr_in( 0, $loopback ) ) {
          croak "Error binding: $!";
      }
  
      my ($port) = sockaddr_in( getsockname($listener) );
  
      _debug "win32 port = $port" if _debugging_details;
  
      listen $listener, my $queue_size = 1
        or croak "$!: listen()";
  
      {
          socket $client, PF_INET, SOCK_STREAM, $tcp_proto
            or croak "$!: socket()";
  
          my $paddr = sockaddr_in( $port, $loopback );
  
          connect $client, $paddr
            or croak "$!: connect()";
  
          croak "$!: accept" unless defined $paddr;
  
          ## The windows "default" is SO_DONTLINGER, which should make
          ## sure all socket data goes through.  I have my doubts based
          ## on experimentation, but nothing prompts me to set SO_LINGER
          ## at this time...
          setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack( "l", 0 )
            or croak "$!: setsockopt()";
      }
  
      {
          _debug "accept()ing on port $port" if _debugging_details;
          my $paddr = accept( $server, $listener );
          croak "$!: accept()" unless defined $paddr;
      }
  
      _debug "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port"
        if _debugging_details;
      return ( $server, $client );
  }
  
  sub _open_socket_pipe {
      my IPC::Run::Win32IO $self = shift;
      my ( $debug_fd, $parent_handle ) = @_;
  
      my $is_send_to_child = $self->dir eq "<";
  
      $self->{CHILD_HANDLE}     = gensym;
      $self->{PUMP_PIPE_HANDLE} = gensym;
  
      (
          $self->{PARENT_HANDLE},
          $self->{PUMP_SOCKET_HANDLE}
      ) = _socket $parent_handle;
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{PARENT_HANDLE}      or die $!;
      binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
  
      _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
        if _debugging_details;
  ##my $buf;
  ##$buf = "write on child end of " . fileno( $self->{WRITE_HANDLE} ) . "\n\n\n\n\n";
  ##POSIX::write(fileno $self->{WRITE_HANDLE}, $buf, length $buf) or warn "$! in syswrite";
  ##$buf = "write on parent end of " . fileno( $self->{CHILD_HANDLE} ) . "\r\n";
  ##POSIX::write(fileno $self->{CHILD_HANDLE},$buf, length $buf) or warn "$! in syswrite";
  ##   $self->{CHILD_HANDLE}->autoflush( 1 );
  ##   $self->{WRITE_HANDLE}->autoflush( 1 );
  
      ## Now fork off a data pump and arrange to return the correct fds.
      if ($is_send_to_child) {
          pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
      else {
          pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
            or croak "$! opening child pipe";
          _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
            if _debugging_details;
          _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
            if _debugging_details;
      }
  
      ## These binmodes seem to have no effect on Win2K, but just to be safe
      ## I do them.
      binmode $self->{CHILD_HANDLE};
      binmode $self->{PUMP_PIPE_HANDLE};
  
      ## No child should ever see this.
      _dont_inherit $self->{PARENT_HANDLE};
  
      ## We clear the inherit flag so these file descriptors are not inherited.
      ## It'll be dup()ed on to STDIN/STDOUT/STDERR before CreateProcess is
      ## called and *that* fd will be inheritable.
      _dont_inherit $self->{PUMP_SOCKET_HANDLE};
      _dont_inherit $self->{PUMP_PIPE_HANDLE};
      _dont_inherit $self->{CHILD_HANDLE};
  
      ## Need to return $self so the HANDLEs don't get freed.
      ## Return $self, $parent_fd, $child_fd
      my ( $parent_fd, $child_fd ) = (
          fileno $self->{PARENT_HANDLE},
          fileno $self->{CHILD_HANDLE}
      );
  
      ## Both PUMP_..._HANDLEs will be closed, no need to worry about
      ## inheritance.
      _debug "binmode on" if _debugging_data && $self->binmode;
      _spawn_pumper(
          $is_send_to_child
          ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
          : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
          $debug_fd,
          $self->binmode,
          $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
      );
  
      {
          my $foo;
          confess "PARENT_HANDLE no longer open"
            unless POSIX::read( $parent_fd, $foo, 0 );
      }
  
      _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
        if _debugging_details;
  
      $self->{FD}  = $parent_fd;
      $self->{TFD} = $child_fd;
  }
  
  sub _do_open {
      my IPC::Run::Win32IO $self = shift;
  
      if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
          return $self->_send_through_temp_file(@_);
      }
      elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
          return $self->_init_recv_through_temp_file(@_);
      }
      else {
          return $self->_open_socket_pipe(@_);
      }
  }
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 or the Artistic License.
  
  =cut
IPC_RUN_WIN32IO

$fatpacked{"IPC/Run/Win32Process.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PROCESS';
  package IPC::Run::Win32Process;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Process -- deliver nonstandard command lines via IPC::Run.
  
  =head1 SYNOPSIS
  
     use File::Spec ();
     use IPC::Run qw(run);
     use IPC::Run::Win32Process ();
     use Win32 ();
  
     $find_exe = File::Spec->catfile(Win32::GetFolderPath(Win32::CSIDL_SYSTEM),
                                     'find.exe');
     run(IPC::Run::Win32Process->new($ENV{COMSPEC}, q{cmd.exe /c echo ""}),
         '|', IPC::Run::Win32Process->new($find_exe, q{find_exe """"""}),
         '>', \$out);
  
  =head1 DESCRIPTION
  
  This class facilitates executing Windows programs that don't use L<standard
  command line parsing
  rules|https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args#parsing-c-command-line-arguments>.
  Notable programs having nonstandard rules include F<cmd.exe>, F<cscript.exe>,
  and Cygwin programs called from non-Cygwin programs.  IPC::Run will use the two
  strings, verbatim, as the lpApplicationName and lpCommandLine arguments of
  CreateProcessA().  This furnishes unfiltered control over the child process
  command line.
  
  =head1 FUNCTIONS & METHODS
  
  =over
  
  =cut
  
  use strict;
  use warnings;
  use Carp;
  
  use overload '""' => sub {
      my ($self) = @_;
      return join(
          '',
          'IPC::Run::Win32Process(',
          $self->{lpApplicationName},
          ', ',
          $self->{lpCommandLine},
          ')'
      );
  };
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20231003.0';
  }
  
  =item new
  
     IPC::Run::Win32Process->new( $lpApplicationName, $lpCommandLine );
     IPC::Run::Win32Process->new( $ENV{COMSPEC}, q{cmd.exe /c echo ""} );
  
  Constructor.
  
  =back
  
  =cut
  
  sub new {
      my ( $class, $lpApplicationName, $lpCommandLine ) = @_;
      $class = ref $class || $class;
  
      croak "missing lpApplicationName" if !defined $lpApplicationName;
      croak "missing lpCommandLine"     if !defined $lpCommandLine;
  
      my IPC::Run::Win32Process $self = bless {}, $class;
      $self->{lpApplicationName} = $lpApplicationName;
      $self->{lpCommandLine}     = $lpCommandLine;
  
      return $self;
  }
  
  1;
IPC_RUN_WIN32PROCESS

$fatpacked{"IPC/Run/Win32Pump.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'IPC_RUN_WIN32PUMP';
  package IPC::Run::Win32Pump;
  
  =pod
  
  =head1 NAME
  
  IPC::Run::Win32Pump - helper processes to shovel data to/from parent, child
  
  =head1 SYNOPSIS
  
  Internal use only; see IPC::Run::Win32IO and best of luck to you.
  
  =head1 DESCRIPTION
  
  See L<IPC::Run::Win32Helper|IPC::Run::Win32Helper> for details.  This
  module is used in subprocesses that are spawned to shovel data to/from
  parent processes from/to their child processes.  Where possible, pumps
  are optimized away.
  
  NOTE: This is not a real module: it's a script in module form, designed
  to be run like
  
     $^X -MIPC::Run::Win32Pumper -e 1 ...
  
  It parses a bunch of command line parameters from IPC::Run::Win32IO.
  
  =cut
  
  use strict;
  use warnings;
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '20231003.0';
  }
  
  use Win32API::File qw(
    OsFHandleOpen
  );
  
  my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
  
  BEGIN {
      ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
      ## Rather than letting IPC::Run::Debug export all-0 constants
      ## when not debugging, we do it manually in order to not even
      ## load IPC::Run::Debug.
      if ($debug) {
          eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
            or die $@;
      }
      else {
          eval <<STUBS_END or die $@;
  	 sub _debug {}
  	 sub _debug_init {}
  	 sub _debugging() { 0 }
  	 sub _debugging_data() { 0 }
  	 sub _debugging_details() { 0 }
  	 sub _debugging_gory_details() { 0 }
  	 1;
  STUBS_END
      }
  }
  
  ## For some reason these get created with binmode on.  AAargh, gotta       #### REMOVE
  ## do it by hand below.       #### REMOVE
  if ($debug) {    #### REMOVE
      close STDERR;    #### REMOVE
      OsFHandleOpen( \*STDERR, $debug_fh, "w" )    #### REMOVE
        or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";    #### REMOVE
  }               #### REMOVE
  close STDIN;    #### REMOVE
  OsFHandleOpen( \*STDIN, $stdin_fh, "r" )    #### REMOVE
    or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";    #### REMOVE
  close STDOUT;                                                          #### REMOVE
  OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )                             #### REMOVE
    or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";  #### REMOVE
  
  binmode STDIN;
  binmode STDOUT;
  $| = 1;
  select STDERR;
  $| = 1;
  select STDOUT;
  
  $child_label ||= "pump";
  _debug_init(
      $parent_pid,
      $parent_start_time,
      $debug,
      fileno STDERR,
      $child_label,
  );
  
  _debug "Entered" if _debugging_details;
  
  # No need to close all fds; win32 doesn't seem to pass any on to us.
  $| = 1;
  my $buf;
  my $total_count = 0;
  while (1) {
      my $count = sysread STDIN, $buf, 10_000;
      last unless $count;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars revc: ", $count ), $msg;
      }
      $total_count += $count;
      $buf =~ s/\r//g unless $binmode;
      if (_debugging_gory_details) {
          my $msg = "'$buf'";
          substr( $msg, 100, -1 ) = '...' if length $msg > 100;
          $msg =~ s/\n/\\n/g;
          $msg =~ s/\r/\\r/g;
          $msg =~ s/\t/\\t/g;
          $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
          _debug sprintf( "%5d chars sent: ", $count ), $msg;
      }
      print $buf;
  }
  
  _debug "Exiting, transferred $total_count chars" if _debugging_details;
  
  ## Perform a graceful socket shutdown.  Windows defaults to SO_DONTLINGER,
  ## which should cause a "graceful shutdown in the background" on sockets.
  ## but that's only true if the process closes the socket manually, it
  ## seems; if the process exits and lets the OS clean up, the OS is not
  ## so kind.  STDOUT is not always a socket, of course, but it won't hurt
  ## to close a pipe and may even help.  With a closed source OS, who
  ## can tell?
  ##
  ## In any case, this close() is one of the main reasons we have helper
  ## processes; if the OS closed socket fds gracefully when an app exits,
  ## we'd just redirect the client directly to what is now the pump end
  ## of the socket.  As it is, however, we need to let the client play with
  ## pipes, which don't have the abort-on-app-exit behavior, and then
  ## adapt to the sockets in the helper processes to allow the parent to
  ## select.
  ##
  ## Possible alternatives / improvements:
  ##
  ## 1) use helper threads instead of processes.  I don't trust perl's threads
  ## as of 5.005 or 5.6 enough (which may be myopic of me).
  ##
  ## 2) figure out if/how to get at WaitForMultipleObjects() with pipe
  ## handles.  May be able to take the Win32 handle and pass it to
  ## Win32::Event::wait_any, dunno.
  ##
  ## 3) Use Inline::C or a hand-tooled XS module to do helper threads.
  ## This would be faster than #1, but would require a ppm distro.
  ##
  close STDOUT;
  close STDERR;
  
  1;
  
  =pod
  
  =head1 AUTHOR
  
  Barries Slaymaker <barries@slaysys.com>.  Funded by Perforce Software, Inc.
  
  =head1 COPYRIGHT
  
  Copyright 2001, Barrie Slaymaker, All Rights Reserved.
  
  You may use this under the terms of either the GPL 2.0 ir the Artistic License.
  
  =cut
IPC_RUN_WIN32PUMP

$fatpacked{"x86_64-linux-gnu-thread-multi/Cwd.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_CWD';
  package Cwd;
  use strict;
  use Exporter;
  
  
  our $VERSION = '3.75';
  my $xs_version = $VERSION;
  $VERSION =~ tr/_//d;
  
  our @ISA = qw/ Exporter /;
  our @EXPORT = qw(cwd getcwd fastcwd fastgetcwd);
  push @EXPORT, qw(getdcwd) if $^O eq 'MSWin32';
  our @EXPORT_OK = qw(chdir abs_path fast_abs_path realpath fast_realpath);
  
  # sys_cwd may keep the builtin command
  
  # All the functionality of this module may provided by builtins,
  # there is no sense to process the rest of the file.
  # The best choice may be to have this in BEGIN, but how to return from BEGIN?
  
  if ($^O eq 'os2') {
      local $^W = 0;
  
      *cwd                = defined &sys_cwd ? \&sys_cwd : \&_os2_cwd;
      *getcwd             = \&cwd;
      *fastgetcwd         = \&cwd;
      *fastcwd            = \&cwd;
  
      *fast_abs_path      = \&sys_abspath if defined &sys_abspath;
      *abs_path           = \&fast_abs_path;
      *realpath           = \&fast_abs_path;
      *fast_realpath      = \&fast_abs_path;
  
      return 1;
  }
  
  # Need to look up the feature settings on VMS.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_vms_feature;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__};
                     local @INC = @INC;
                     pop @INC if $INC[-1] eq '.';
                     require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i; 
      }
      return $efs;
  }
  
  
  # If loading the XS stuff doesn't work, we can fall back to pure perl
  if(! defined &getcwd && defined &DynaLoader::boot_DynaLoader) { # skipped on miniperl
      require XSLoader;
      XSLoader::load( __PACKAGE__, $xs_version);
  }
  
  # Big nasty table of function aliases
  my %METHOD_MAP =
    (
     VMS =>
     {
      cwd			=> '_vms_cwd',
      getcwd		=> '_vms_cwd',
      fastcwd		=> '_vms_cwd',
      fastgetcwd		=> '_vms_cwd',
      abs_path		=> '_vms_abs_path',
      fast_abs_path	=> '_vms_abs_path',
     },
  
     MSWin32 =>
     {
      # We assume that &_NT_cwd is defined as an XSUB or in the core.
      cwd			=> '_NT_cwd',
      getcwd		=> '_NT_cwd',
      fastcwd		=> '_NT_cwd',
      fastgetcwd		=> '_NT_cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     dos => 
     {
      cwd			=> '_dos_cwd',
      getcwd		=> '_dos_cwd',
      fastgetcwd		=> '_dos_cwd',
      fastcwd		=> '_dos_cwd',
      abs_path		=> 'fast_abs_path',
     },
  
     # QNX4.  QNX6 has a $os of 'nto'.
     qnx =>
     {
      cwd			=> '_qnx_cwd',
      getcwd		=> '_qnx_cwd',
      fastgetcwd		=> '_qnx_cwd',
      fastcwd		=> '_qnx_cwd',
      abs_path		=> '_qnx_abs_path',
      fast_abs_path	=> '_qnx_abs_path',
     },
  
     cygwin =>
     {
      getcwd		=> 'cwd',
      fastgetcwd		=> 'cwd',
      fastcwd		=> 'cwd',
      abs_path		=> 'fast_abs_path',
      realpath		=> 'fast_abs_path',
     },
  
     amigaos =>
     {
      getcwd              => '_backtick_pwd',
      fastgetcwd          => '_backtick_pwd',
      fastcwd             => '_backtick_pwd',
      abs_path            => 'fast_abs_path',
     }
    );
  
  $METHOD_MAP{NT} = $METHOD_MAP{MSWin32};
  
  
  # Find the pwd command in the expected locations.  We assume these
  # are safe.  This prevents _backtick_pwd() consulting $ENV{PATH}
  # so everything works under taint mode.
  my $pwd_cmd;
  if($^O ne 'MSWin32') {
      foreach my $try ('/bin/pwd',
  		     '/usr/bin/pwd',
  		     '/QOpenSys/bin/pwd', # OS/400 PASE.
  		    ) {
  	if( -x $try ) {
  	    $pwd_cmd = $try;
  	    last;
  	}
      }
  }
  
  # Android has a built-in pwd. Using $pwd_cmd will DTRT if
  # this perl was compiled with -Dd_useshellcmds, which is the
  # default for Android, but the block below is needed for the
  # miniperl running on the host when cross-compiling, and
  # potentially for native builds with -Ud_useshellcmds.
  if ($^O =~ /android/) {
      # If targetsh is executable, then we're either a full
      # perl, or a miniperl for a native build.
      if (-x $Config::Config{targetsh}) {
          $pwd_cmd = "$Config::Config{targetsh} -c pwd"
      }
      else {
          my $sh = $Config::Config{sh} || (-x '/system/bin/sh' ? '/system/bin/sh' : 'sh');
          $pwd_cmd = "$sh -c pwd"
      }
  }
  
  my $found_pwd_cmd = defined($pwd_cmd);
  unless ($pwd_cmd) {
      # Isn't this wrong?  _backtick_pwd() will fail if someone has
      # pwd in their path but it is not /bin/pwd or /usr/bin/pwd?
      # See [perl #16774]. --jhi
      $pwd_cmd = 'pwd';
  }
  
  # Lazy-load Carp
  sub _carp  { require Carp; Carp::carp(@_)  }
  sub _croak { require Carp; Carp::croak(@_) }
  
  # The 'natural and safe form' for UNIX (pwd may be setuid root)
  sub _backtick_pwd {
  
      # Localize %ENV entries in a way that won't create new hash keys.
      # Under AmigaOS we don't want to localize as it stops perl from
      # finding 'sh' in the PATH.
      my @localize = grep exists $ENV{$_}, qw(PATH IFS CDPATH ENV BASH_ENV) if $^O ne "amigaos";
      local @ENV{@localize} if @localize;
      
      my $cwd = `$pwd_cmd`;
      # Belt-and-suspenders in case someone said "undef $/".
      local $/ = "\n";
      # `pwd` may fail e.g. if the disk is full
      chomp($cwd) if defined $cwd;
      $cwd;
  }
  
  # Since some ports may predefine cwd internally (e.g., NT)
  # we take care not to override an existing definition for cwd().
  
  unless ($METHOD_MAP{$^O}{cwd} or defined &cwd) {
      # The pwd command is not available in some chroot(2)'ed environments
      my $sep = $Config::Config{path_sep} || ':';
      my $os = $^O;  # Protect $^O from tainting
  
  
      # Try again to find a pwd, this time searching the whole PATH.
      if (defined $ENV{PATH} and $os ne 'MSWin32') {  # no pwd on Windows
  	my @candidates = split($sep, $ENV{PATH});
  	while (!$found_pwd_cmd and @candidates) {
  	    my $candidate = shift @candidates;
  	    $found_pwd_cmd = 1 if -x "$candidate/pwd";
  	}
      }
  
      if( $found_pwd_cmd )
      {
  	*cwd = \&_backtick_pwd;
      }
      else {
  	*cwd = \&getcwd;
      }
  }
  
  if ($^O eq 'cygwin') {
    # We need to make sure cwd() is called with no args, because it's
    # got an arg-less prototype and will die if args are present.
    local $^W = 0;
    my $orig_cwd = \&cwd;
    *cwd = sub { &$orig_cwd() }
  }
  
  
  # set a reasonable (and very safe) default for fastgetcwd, in case it
  # isn't redefined later (20001212 rspier)
  *fastgetcwd = \&cwd;
  
  # A non-XS version of getcwd() - also used to bootstrap the perl build
  # process, when miniperl is running and no XS loading happens.
  sub _perl_getcwd
  {
      abs_path('.');
  }
  
  # By John Bazik
  #
  # Usage: $cwd = &fastcwd;
  #
  # This is a faster version of getcwd.  It's also more dangerous because
  # you might chdir out of a directory that you can't chdir back into.
      
  sub fastcwd_ {
      my($odev, $oino, $cdev, $cino, $tdev, $tino);
      my(@path, $path);
      local(*DIR);
  
      my($orig_cdev, $orig_cino) = stat('.');
      ($cdev, $cino) = ($orig_cdev, $orig_cino);
      for (;;) {
  	my $direntry;
  	($odev, $oino) = ($cdev, $cino);
  	CORE::chdir('..') || return undef;
  	($cdev, $cino) = stat('.');
  	last if $odev == $cdev && $oino == $cino;
  	opendir(DIR, '.') || return undef;
  	for (;;) {
  	    $direntry = readdir(DIR);
  	    last unless defined $direntry;
  	    next if $direntry eq '.';
  	    next if $direntry eq '..';
  
  	    ($tdev, $tino) = lstat($direntry);
  	    last unless $tdev != $odev || $tino != $oino;
  	}
  	closedir(DIR);
  	return undef unless defined $direntry; # should never happen
  	unshift(@path, $direntry);
      }
      $path = '/' . join('/', @path);
      if ($^O eq 'apollo') { $path = "/".$path; }
      # At this point $path may be tainted (if tainting) and chdir would fail.
      # Untaint it then check that we landed where we started.
      $path =~ /^(.*)\z/s		# untaint
  	&& CORE::chdir($1) or return undef;
      ($cdev, $cino) = stat('.');
      die "Unstable directory path, current directory changed unexpectedly"
  	if $cdev != $orig_cdev || $cino != $orig_cino;
      $path;
  }
  if (not defined &fastcwd) { *fastcwd = \&fastcwd_ }
  
  
  # Keeps track of current working directory in PWD environment var
  # Usage:
  #	use Cwd 'chdir';
  #	chdir $newdir;
  
  my $chdir_init = 0;
  
  sub chdir_init {
      if ($ENV{'PWD'} and $^O ne 'os2' and $^O ne 'dos' and $^O ne 'MSWin32') {
  	my($dd,$di) = stat('.');
  	my($pd,$pi) = stat($ENV{'PWD'});
  	if (!defined $dd or !defined $pd or $di != $pi or $dd != $pd) {
  	    $ENV{'PWD'} = cwd();
  	}
      }
      else {
  	my $wd = cwd();
  	$wd = Win32::GetFullPathName($wd) if $^O eq 'MSWin32';
  	$ENV{'PWD'} = $wd;
      }
      # Strip an automounter prefix (where /tmp_mnt/foo/bar == /foo/bar)
      if ($^O ne 'MSWin32' and $ENV{'PWD'} =~ m|(/[^/]+(/[^/]+/[^/]+))(.*)|s) {
  	my($pd,$pi) = stat($2);
  	my($dd,$di) = stat($1);
  	if (defined $pd and defined $dd and $di == $pi and $dd == $pd) {
  	    $ENV{'PWD'}="$2$3";
  	}
      }
      $chdir_init = 1;
  }
  
  sub chdir {
      my $newdir = @_ ? shift : '';	# allow for no arg (chdir to HOME dir)
      if ($^O eq "cygwin") {
        $newdir =~ s|\A///+|//|;
        $newdir =~ s|(?<=[^/])//+|/|g;
      }
      elsif ($^O ne 'MSWin32') {
        $newdir =~ s|///*|/|g;
      }
      chdir_init() unless $chdir_init;
      my $newpwd;
      if ($^O eq 'MSWin32') {
  	# get the full path name *before* the chdir()
  	$newpwd = Win32::GetFullPathName($newdir);
      }
  
      return 0 unless CORE::chdir $newdir;
  
      if ($^O eq 'VMS') {
  	return $ENV{'PWD'} = $ENV{'DEFAULT'}
      }
      elsif ($^O eq 'MSWin32') {
  	$ENV{'PWD'} = $newpwd;
  	return 1;
      }
  
      if (ref $newdir eq 'GLOB') { # in case a file/dir handle is passed in
  	$ENV{'PWD'} = cwd();
      } elsif ($newdir =~ m#^/#s) {
  	$ENV{'PWD'} = $newdir;
      } else {
  	my @curdir = split(m#/#,$ENV{'PWD'});
  	@curdir = ('') unless @curdir;
  	my $component;
  	foreach $component (split(m#/#, $newdir)) {
  	    next if $component eq '.';
  	    pop(@curdir),next if $component eq '..';
  	    push(@curdir,$component);
  	}
  	$ENV{'PWD'} = join('/',@curdir) || '/';
      }
      1;
  }
  
  
  sub _perl_abs_path
  {
      my $start = @_ ? shift : '.';
      my($dotdots, $cwd, @pst, @cst, $dir, @tst);
  
      unless (@cst = stat( $start ))
      {
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
          # NOTE that this routine assumes that '/' is the only directory separator.
  	
          my ($dir, $file) = $start =~ m{^(.*)/(.+)$}
  	    or return cwd() . '/' . $start;
  	
  	# Can't use "-l _" here, because the previous stat was a stat(), not an lstat().
  	if (-l $start) {
  	    my $link_target = readlink($start);
  	    die "Can't resolve link $start: $!" unless defined $link_target;
  	    
  	    require File::Spec;
              $link_target = $dir . '/' . $link_target
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return abs_path($link_target);
  	}
  	
  	return $dir ? abs_path($dir) . "/$file" : "/$file";
      }
  
      $cwd = '';
      $dotdots = $start;
      do
      {
  	$dotdots .= '/..';
  	@pst = @cst;
  	local *PARENT;
  	unless (opendir(PARENT, $dotdots))
  	{
  	    return undef;
  	}
  	unless (@cst = stat($dotdots))
  	{
  	    my $e = $!;
  	    closedir(PARENT);
  	    $! = $e;
  	    return undef;
  	}
  	if ($pst[0] == $cst[0] && $pst[1] == $cst[1])
  	{
  	    $dir = undef;
  	}
  	else
  	{
  	    do
  	    {
  		unless (defined ($dir = readdir(PARENT)))
  	        {
  		    closedir(PARENT);
  		    require Errno;
  		    $! = Errno::ENOENT();
  		    return undef;
  		}
  		$tst[0] = $pst[0]+1 unless (@tst = lstat("$dotdots/$dir"))
  	    }
  	    while ($dir eq '.' || $dir eq '..' || $tst[0] != $pst[0] ||
  		   $tst[1] != $pst[1]);
  	}
  	$cwd = (defined $dir ? "$dir" : "" ) . "/$cwd" ;
  	closedir(PARENT);
      } while (defined $dir);
      chop($cwd) unless $cwd eq '/'; # drop the trailing /
      $cwd;
  }
  
  
  my $Curdir;
  sub fast_abs_path {
      local $ENV{PWD} = $ENV{PWD} || ''; # Guard against clobberage
      my $cwd = getcwd();
      defined $cwd or return undef;
      require File::Spec;
      my $path = @_ ? shift : ($Curdir ||= File::Spec->curdir);
  
      # Detaint else we'll explode in taint mode.  This is safe because
      # we're not doing anything dangerous with it.
      ($path) = $path =~ /(.*)/s;
      ($cwd)  = $cwd  =~ /(.*)/s;
  
      unless (-e $path) {
  	require Errno;
  	$! = Errno::ENOENT();
  	return undef;
      }
  
      unless (-d _) {
          # Make sure we can be invoked on plain files, not just directories.
  	
  	my ($vol, $dir, $file) = File::Spec->splitpath($path);
  	return File::Spec->catfile($cwd, $path) unless length $dir;
  
  	if (-l $path) {
  	    my $link_target = readlink($path);
  	    defined $link_target or return undef;
  	    
  	    $link_target = File::Spec->catpath($vol, $dir, $link_target)
                  unless File::Spec->file_name_is_absolute($link_target);
  	    
  	    return fast_abs_path($link_target);
  	}
  	
  	return $dir eq File::Spec->rootdir
  	  ? File::Spec->catpath($vol, $dir, $file)
  	  : fast_abs_path(File::Spec->catpath($vol, $dir, '')) . '/' . $file;
      }
  
      if (!CORE::chdir($path)) {
  	return undef;
      }
      my $realpath = getcwd();
      if (! ((-d $cwd) && (CORE::chdir($cwd)))) {
   	_croak("Cannot chdir back to $cwd: $!");
      }
      $realpath;
  }
  
  # added function alias to follow principle of least surprise
  # based on previous aliasing.  --tchrist 27-Jan-00
  *fast_realpath = \&fast_abs_path;
  
  
  # --- PORTING SECTION ---
  
  # VMS: $ENV{'DEFAULT'} points to default directory at all times
  # 06-Mar-1996  Charles Bailey  bailey@newman.upenn.edu
  # Note: Use of Cwd::chdir() causes the logical name PWD to be defined
  #   in the process logical name table as the default device and directory
  #   seen by Perl. This may not be the same as the default device
  #   and directory seen by DCL after Perl exits, since the effects
  #   the CRTL chdir() function persist only until Perl exits.
  
  sub _vms_cwd {
      return $ENV{'DEFAULT'};
  }
  
  sub _vms_abs_path {
      return $ENV{'DEFAULT'} unless @_;
      my $path = shift;
  
      my $efs = _vms_efs;
      my $unix_rpt = _vms_unix_rpt;
  
      if (defined &VMS::Filespec::vmsrealpath) {
          my $path_unix = 0;
          my $path_vms = 0;
  
          $path_unix = 1 if ($path =~ m#(?<=\^)/#);
          $path_unix = 1 if ($path =~ /^\.\.?$/);
          $path_vms = 1 if ($path =~ m#[\[<\]]#);
          $path_vms = 1 if ($path =~ /^--?$/);
  
          my $unix_mode = $path_unix;
          if ($efs) {
              # In case of a tie, the Unix report mode decides.
              if ($path_vms == $path_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = 0 if $path_vms;
              }
          }
  
          if ($unix_mode) {
              # Unix format
              return VMS::Filespec::unixrealpath($path);
          }
  
  	# VMS format
  
  	my $new_path = VMS::Filespec::vmsrealpath($path);
  
  	# Perl expects directories to be in directory format
  	$new_path = VMS::Filespec::pathify($new_path) if -d $path;
  	return $new_path;
      }
  
      # Fallback to older algorithm if correct ones are not
      # available.
  
      if (-l $path) {
          my $link_target = readlink($path);
          die "Can't resolve link $path: $!" unless defined $link_target;
  
          return _vms_abs_path($link_target);
      }
  
      # may need to turn foo.dir into [.foo]
      my $pathified = VMS::Filespec::pathify($path);
      $path = $pathified if defined $pathified;
  	
      return VMS::Filespec::rmsexpand($path);
  }
  
  sub _os2_cwd {
      my $pwd = `cmd /c cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd_simple {
      my $pwd = `cd`;
      chomp $pwd;
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _win32_cwd {
      my $pwd;
      $pwd = Win32::GetCwd();
      $pwd =~ s:\\:/:g ;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  *_NT_cwd = defined &Win32::GetCwd ? \&_win32_cwd : \&_win32_cwd_simple;
  
  sub _dos_cwd {
      my $pwd;
      if (!defined &Dos::GetCwd) {
          chomp($pwd = `command /c cd`);
          $pwd =~ s:\\:/:g ;
      } else {
          $pwd = Dos::GetCwd();
      }
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_cwd {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $pwd = `/usr/bin/fullpath -t`;
      chomp $pwd;
      $ENV{'PWD'} = $pwd;
      return $pwd;
  }
  
  sub _qnx_abs_path {
  	local $ENV{PATH} = '';
  	local $ENV{CDPATH} = '';
  	local $ENV{ENV} = '';
      my $path = @_ ? shift : '.';
      local *REALPATH;
  
      defined( open(REALPATH, '-|') || exec '/usr/bin/fullpath', '-t', $path ) or
        die "Can't open /usr/bin/fullpath: $!";
      my $realpath = <REALPATH>;
      close REALPATH;
      chomp $realpath;
      return $realpath;
  }
  
  # Now that all the base-level functions are set up, alias the
  # user-level functions to the right places
  
  if (exists $METHOD_MAP{$^O}) {
    my $map = $METHOD_MAP{$^O};
    foreach my $name (keys %$map) {
      local $^W = 0;  # assignments trigger 'subroutine redefined' warning
      no strict 'refs';
      *{$name} = \&{$map->{$name}};
    }
  }
  
  # In case the XS version doesn't load.
  *abs_path = \&_perl_abs_path unless defined &abs_path;
  *getcwd = \&_perl_getcwd unless defined &getcwd;
  
  # added function alias for those of us more
  # used to the libc function.  --tchrist 27-Jan-00
  *realpath = \&abs_path;
  
  1;
  __END__
  
  =head1 NAME
  
  Cwd - get pathname of current working directory
  
  =head1 SYNOPSIS
  
      use Cwd;
      my $dir = getcwd;
  
      use Cwd 'abs_path';
      my $abs_path = abs_path($file);
  
  =head1 DESCRIPTION
  
  This module provides functions for determining the pathname of the
  current working directory.  It is recommended that getcwd (or another
  *cwd() function) be used in I<all> code to ensure portability.
  
  By default, it exports the functions cwd(), getcwd(), fastcwd(), and
  fastgetcwd() (and, on Win32, getdcwd()) into the caller's namespace.  
  
  
  =head2 getcwd and friends
  
  Each of these functions are called without arguments and return the
  absolute path of the current working directory.
  
  =over 4
  
  =item getcwd
  
      my $cwd = getcwd();
  
  Returns the current working directory.  On error returns C<undef>,
  with C<$!> set to indicate the error.
  
  Exposes the POSIX function getcwd(3) or re-implements it if it's not
  available.
  
  =item cwd
  
      my $cwd = cwd();
  
  The cwd() is the most natural form for the current architecture.  For
  most systems it is identical to `pwd` (but without the trailing line
  terminator).
  
  =item fastcwd
  
      my $cwd = fastcwd();
  
  A more dangerous version of getcwd(), but potentially faster.
  
  It might conceivably chdir() you out of a directory that it can't
  chdir() you back into.  If fastcwd encounters a problem it will return
  undef but will probably leave you in a different directory.  For a
  measure of extra security, if everything appears to have worked, the
  fastcwd() function will check that it leaves you in the same directory
  that it started in.  If it has changed it will C<die> with the message
  "Unstable directory path, current directory changed
  unexpectedly".  That should never happen.
  
  =item fastgetcwd
  
    my $cwd = fastgetcwd();
  
  The fastgetcwd() function is provided as a synonym for cwd().
  
  =item getdcwd
  
      my $cwd = getdcwd();
      my $cwd = getdcwd('C:');
  
  The getdcwd() function is also provided on Win32 to get the current working
  directory on the specified drive, since Windows maintains a separate current
  working directory for each drive.  If no drive is specified then the current
  drive is assumed.
  
  This function simply calls the Microsoft C library _getdcwd() function.
  
  =back
  
  
  =head2 abs_path and friends
  
  These functions are exported only on request.  They each take a single
  argument and return the absolute pathname for it.  If no argument is
  given they'll use the current working directory.
  
  =over 4
  
  =item abs_path
  
    my $abs_path = abs_path($file);
  
  Uses the same algorithm as getcwd().  Symbolic links and relative-path
  components ("." and "..") are resolved to return the canonical
  pathname, just like realpath(3).  On error returns C<undef>, with C<$!>
  set to indicate the error.
  
  =item realpath
  
    my $abs_path = realpath($file);
  
  A synonym for abs_path().
  
  =item fast_abs_path
  
    my $abs_path = fast_abs_path($file);
  
  A more dangerous, but potentially faster version of abs_path.
  
  =back
  
  =head2 $ENV{PWD}
  
  If you ask to override your chdir() built-in function, 
  
    use Cwd qw(chdir);
  
  then your PWD environment variable will be kept up to date.  Note that
  it will only be kept up to date if all packages which use chdir import
  it from Cwd.
  
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  Since the path separators are different on some operating systems ('/'
  on Unix, ':' on MacPerl, etc...) we recommend you use the File::Spec
  modules wherever portability is a concern.
  
  =item *
  
  Actually, on Mac OS, the C<getcwd()>, C<fastgetcwd()> and C<fastcwd()>
  functions are all aliases for the C<cwd()> function, which, on Mac OS,
  calls `pwd`.  Likewise, the C<abs_path()> function is an alias for
  C<fast_abs_path()>.
  
  =back
  
  =head1 AUTHOR
  
  Originally by the perl5-porters.
  
  Maintained by Ken Williams <KWILLIAMS@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Portions of the C code in this library are copyright (c) 1994 by the
  Regents of the University of California.  All rights reserved.  The
  license on this code is compatible with the licensing of the rest of
  the distribution - please see the source code in F<Cwd.xs> for the
  details.
  
  =head1 SEE ALSO
  
  L<File::chdir>
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_CWD

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC';
  package File::Spec;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  my %module = (
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin',
  	      amigaos => 'AmigaOS');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  our @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of files in a directory (such as from C<readdir()>),
  strip out C<'.'> and C<'..'>.
  
  B<SECURITY NOTE:> This does NOT filter paths containing C<'..'>, like
  C<'../../../../etc/passwd'>, only literal matches to C<'.'> and C<'..'>.
  
      @paths = File::Spec->no_upwards( readdir $dirhandle );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/AmigaOS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_AMIGAOS';
  package File::Spec::AmigaOS;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::AmigaOS - File::Spec for AmigaOS
  
  =head1 SYNOPSIS
  
   require File::Spec::AmigaOS; # Done automatically by File::Spec
                                # if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item tmpdir
  
  Returns $ENV{TMPDIR} or if that is unset, "/t".
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
    return $tmpdir if defined $tmpdir;
    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/t" );
  }
  
  =item file_name_is_absolute
  
  Returns true if there's a colon in the file name,
  or if it begins with a slash.
  
  =cut
  
  sub file_name_is_absolute {
    my ($self, $file) = @_;
  
    # Not 100% robust as a "/" must not preceded a ":"
    # but this cannot happen in a well formed path.
    return $file =~ m{^/|:}s;
  }
  
  =back
  
  All the other methods are from L<File::Spec::Unix>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_AMIGAOS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Cygwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TMP TEMP');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir(
          $_[0]->_tmpdir(
              $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp'
          ),
          qw 'TMPDIR TMP TEMP'
      );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval {
        local @INC = @INC;
        pop @INC if $INC[-1] eq '.';
        require Win32API::File;
    } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_CYGWIN

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Epoc.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require File::Spec::Unix;
  our @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there.  This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still a work in progress. ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path.  On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_EPOC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Functions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  require Exporter;
  
  our @ISA = qw(Exporter);
  
  our @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  our @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  require File::Spec::Unix;
  my %udeps = (
      canonpath => [],
      catdir => [qw(canonpath)],
      catfile => [qw(canonpath catdir)],
      case_tolerant => [],
      curdir => [],
      devnull => [],
      rootdir => [],
      updir => [],
  );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      if (exists($udeps{$meth}) && $sub == File::Spec::Unix->can($meth) &&
  	    !(grep {
  		File::Spec->can($_) != File::Spec::Unix->can($_)
  	    } @{$udeps{$meth}}) &&
  	    defined(&{"File::Spec::Unix::_fn_$meth"})) {
  	*{$meth} = \&{"File::Spec::Unix::_fn_$meth"};
      } else {
  	*{$meth} = sub {&$sub('File::Spec', @_)};
      }
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_FUNCTIONS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Mac.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  L<File::Spec::Unix/canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see L<File::Spec::Unix/canonpath()>. If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns the empty string.  Mac OS has no real root directory.
  
  =cut
  
  sub rootdir { '' }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR} ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_MAC

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/OS2.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir(qw 'TMPDIR TEMP TMP');
      return $cached if defined $cached;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $_[0]->_cache_tmpdir(
  	$_[0]->_tmpdir( @d, '/tmp', '/' ), qw 'TMPDIR TEMP TMP'
      );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = Cwd::getcwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_OS2

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use Cwd ();
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub _pp_canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  *canonpath = \&_pp_canonpath unless defined &canonpath;
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub _pp_catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  *catdir = \&_pp_catdir unless defined &catdir;
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub _pp_catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  *catfile = \&_pp_catfile unless defined &catfile;
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  use constant _fn_curdir => ".";
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  use constant _fn_devnull => "/dev/null";
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  use constant _fn_rootdir => "/";
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my ($tmpdir, %tmpenv);
  # Cache and return the calculated tmpdir, recording which env vars
  # determined it.
  sub _cache_tmpdir {
      @tmpenv{@_[2..$#_]} = @ENV{@_[2..$#_]};
      return $tmpdir = $_[1];
  }
  # Retrieve the cached tmpdir, checking first whether relevant env vars have
  # changed and invalidated the cache.
  sub _cached_tmpdir {
      shift;
      local $^W;
      return if grep $ENV{$_} ne $tmpenv{$_}, @_;
      return $tmpdir;
  }
  sub _tmpdir {
      my $self = shift;
      my @dirlist = @_;
      my $taint = do { no strict 'refs'; ${"\cTAINT"} };
      if ($taint) { # Check for taint mode on perl >= 5.8.0
  	require Scalar::Util;
  	@dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
      }
      elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	@dirlist = grep { !defined($_) || eval { eval('1'.substr $_,0,0) } }
  			@dirlist;
      }
      
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      if ( !$self->file_name_is_absolute($tmpdir) ) {
          # See [perl #120593] for the full details
          # If possible, return a full path, rather than '.' or 'lib', but
          # jump through some hoops to avoid returning a tainted value.
          ($tmpdir) = grep {
              $taint     ? ! Scalar::Util::tainted($_) :
              $] < 5.007 ? eval { eval('1'.substr $_,0,0) } : 1
          } $self->rel2abs($tmpdir), $tmpdir;
      }
      return $tmpdir;
  }
  
  sub tmpdir {
      my $cached = $_[0]->_cached_tmpdir('TMPDIR');
      return $cached if defined $cached;
      $_[0]->_cache_tmpdir($_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" ), 'TMPDIR');
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  use constant _fn_updir => "..";
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  use constant _fn_case_tolerant => 0;
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath(Cwd::getcwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_UNIX

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicitly requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__};
                 local @INC = @INC;
                 pop @INC if $INC[-1] eq '.';
                 require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])(?:\^.|[^\]\.])+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.(?:\^.|[^\]\.])+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[(?:\^.|[^\]\.])+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$rslt = vmspath( unixify($spath) . '/' . unixify($sdir));
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = unixify($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $xfile : vmsify($xfile);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  sub tmpdir {
      my $self = shift @_;
      my $tmpdir = $self->_cached_tmpdir('TMPDIR');
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
      }
      else {
          $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
      }
      $self->_cache_tmpdir($tmpdir, 'TMPDIR');
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /^[A-Za-z0-9_\$\-\~]+(?<!\^):/);
  }
  
  =item splitpath (override)
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      my($path,$base) = @_;
  
      $base = Cwd::getcwd() unless defined $base and length $base;
  
      # If there is no device or directory syntax on $base, make sure it
      # is treated as a directory.
      $base = vmspath($base) unless $base =~ m{(?<!\^)[\[<:]};
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $self->canonpath( $path ) unless lc($path_volume) eq lc($base_volume);
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = Cwd::getcwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-14 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_VMS

$fatpacked{"x86_64-linux-gnu-thread-multi/File/Spec/Win32.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use Cwd ();
  require File::Spec::Unix;
  
  our $VERSION = '3.75';
  $VERSION =~ tr/_//d;
  
  our @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  If running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  sub tmpdir {
      my $tmpdir = $_[0]->_cached_tmpdir(qw(TMPDIR TEMP TMP));
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
      $_[0]->_cache_tmpdir($tmpdir, qw(TMPDIR TEMP TMP));
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval {
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      require Win32API::File;
    } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
     ($volume,$directories,$file) = File::Spec->splitpath( $path );
     ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                           $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( Cwd::getcwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = Cwd::getcwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_FILE_SPEC_WIN32

$fatpacked{"x86_64-linux-gnu-thread-multi/IO.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO';
  #
  
  package IO;
  
  use XSLoader ();
  use Carp;
  use strict;
  use warnings;
  
  our $VERSION = "1.50";
  XSLoader::load 'IO', $VERSION;
  
  sub import {
      shift;
  
      warnings::warnif('deprecated', qq{Parameterless "use IO" deprecated})
          if @_ == 0 ;
      
      my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);
  
      local @INC = @INC;
      pop @INC if $INC[-1] eq '.';
      eval join("", map { "require IO::" . (/(\w+)/)[0] . ";\n" } @l)
  	or croak $@;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO - load various IO modules
  
  =head1 SYNOPSIS
  
     use IO qw(Handle File); # loads IO modules, here IO::Handle, IO::File
     use IO;                 # DEPRECATED
  
  =head1 DESCRIPTION
  
  C<IO> provides a simple mechanism to load several of the IO modules
  in one go.  The IO modules belonging to the core are:
  
        IO::Handle
        IO::Seekable
        IO::File
        IO::Pipe
        IO::Socket
        IO::Dir
        IO::Select
        IO::Poll
  
  Some other IO modules don't belong to the perl core but can be loaded
  as well if they have been installed from CPAN.  You can discover which
  ones exist with this query:  L<https://metacpan.org/search?q=IO%3A%3A>.
  
  For more information on any of these modules, please see its respective
  documentation.
  
  =head1 DEPRECATED
  
      use IO;                # loads all the modules listed below
  
  The loaded modules are IO::Handle, IO::Seekable, IO::File, IO::Pipe,
  IO::Socket, IO::Dir.  You should instead explicitly import the IO
  modules you want.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Dir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR';
  # IO::Dir.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Dir;
  
  use 5.008_001;
  
  use strict;
  use Carp;
  use Symbol;
  use Exporter;
  use IO::File;
  use Tie::Hash;
  use File::stat;
  use File::Spec;
  
  our @ISA = qw(Tie::Hash Exporter);
  our $VERSION = "1.49";
  
  our @EXPORT_OK = qw(DIR_UNLINK);
  
  sub DIR_UNLINK () { 1 }
  
  sub new {
      @_ >= 1 && @_ <= 2 or croak 'usage: IO::Dir->new([DIRNAME])';
      my $class = shift;
      my $dh = gensym;
      if (@_) {
  	IO::Dir::open($dh, $_[0])
  	    or return undef;
      }
      bless $dh, $class;
  }
  
  sub DESTROY {
      my ($dh) = @_;
      local($., $@, $!, $^E, $?);
      no warnings 'io';
      closedir($dh);
  }
  
  sub open {
      @_ == 2 or croak 'usage: $dh->open(DIRNAME)';
      my ($dh, $dirname) = @_;
      return undef
  	unless opendir($dh, $dirname);
      # a dir name should always have a ":" in it; assume dirname is
      # in current directory
      $dirname = ':' .  $dirname if ( ($^O eq 'MacOS') && ($dirname !~ /:/) );
      ${*$dh}{io_dir_path} = $dirname;
      1;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $dh->close()';
      my ($dh) = @_;
      closedir($dh);
  }
  
  sub read {
      @_ == 1 or croak 'usage: $dh->read()';
      my ($dh) = @_;
      readdir($dh);
  }
  
  sub seek {
      @_ == 2 or croak 'usage: $dh->seek(POS)';
      my ($dh,$pos) = @_;
      seekdir($dh,$pos);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $dh->tell()';
      my ($dh) = @_;
      telldir($dh);
  }
  
  sub rewind {
      @_ == 1 or croak 'usage: $dh->rewind()';
      my ($dh) = @_;
      rewinddir($dh);
  }
  
  sub TIEHASH {
      my($class,$dir,$options) = @_;
  
      my $dh = $class->new($dir)
  	or return undef;
  
      $options ||= 0;
  
      ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;
      $dh;
  }
  
  sub FIRSTKEY {
      my($dh) = @_;
      $dh->rewind;
      scalar $dh->read;
  }
  
  sub NEXTKEY {
      my($dh) = @_;
      scalar $dh->read;
  }
  
  sub EXISTS {
      my($dh,$key) = @_;
      -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  }
  
  sub FETCH {
      my($dh,$key) = @_;
      &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));
  }
  
  sub STORE {
      my($dh,$key,$data) = @_;
      my($atime,$mtime) = ref($data) ? @$data : ($data,$data);
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
      unless(-e $file) {
  	my $io = IO::File->new($file,O_CREAT | O_RDWR);
  	$io->close if $io;
      }
      utime($atime,$mtime, $file);
  }
  
  sub DELETE {
      my($dh,$key) = @_;
  
      # Only unlink if unlink-ing is enabled
      return 0
  	unless ${*$dh}{io_dir_unlink};
  
      my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);
  
      -d $file
  	? rmdir($file)
  	: unlink($file);
  }
  
  1;
  
  __END__
  
  =head1 NAME 
  
  IO::Dir - supply object methods for directory handles
  
  =head1 SYNOPSIS
  
      use IO::Dir;
      $d = IO::Dir->new(".");
      if (defined $d) {
          while (defined($_ = $d->read)) { something($_); }
          $d->rewind;
          while (defined($_ = $d->read)) { something_else($_); }
          undef $d;
      }
  
      tie %dir, 'IO::Dir', ".";
      foreach (keys %dir) {
  	print $_, " " , $dir{$_}->size,"\n";
      }
  
  =head1 DESCRIPTION
  
  The C<IO::Dir> package provides two interfaces to perl's directory reading
  routines.
  
  The first interface is an object approach. C<IO::Dir> provides an object
  constructor and methods, which are just wrappers around perl's built in
  directory reading routines.
  
  =over 4
  
  =item new ( [ DIRNAME ] )
  
  C<new> is the constructor for C<IO::Dir> objects. It accepts one optional
  argument which,  if given, C<new> will pass to C<open>
  
  =back
  
  The following methods are wrappers for the directory related functions built
  into perl (the trailing 'dir' has been removed from the names). See L<perlfunc>
  for details of these functions.
  
  =over 4
  
  =item open ( DIRNAME )
  
  =item read ()
  
  =item seek ( POS )
  
  =item tell ()
  
  =item rewind ()
  
  =item close ()
  
  =back
  
  C<IO::Dir> also provides an interface to reading directories via a tied
  hash. The tied hash extends the interface beyond just the directory
  reading routines by the use of C<lstat>, from the C<File::stat> package,
  C<unlink>, C<rmdir> and C<utime>.
  
  =over 4
  
  =item tie %hash, 'IO::Dir', DIRNAME [, OPTIONS ]
  
  =back
  
  The keys of the hash will be the names of the entries in the directory. 
  Reading a value from the hash will be the result of calling
  C<File::stat::lstat>.  Deleting an element from the hash will 
  delete the corresponding file or subdirectory,
  provided that C<DIR_UNLINK> is included in the C<OPTIONS>.
  
  Assigning to an entry in the hash will cause the time stamps of the file
  to be modified. If the file does not exist then it will be created. Assigning
  a single integer to a hash element will cause both the access and 
  modification times to be changed to that value. Alternatively a reference to
  an array of two values can be passed. The first array element will be used to
  set the access time and the second element will be used to set the modification
  time.
  
  =head1 SEE ALSO
  
  L<File::stat>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2003 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_DIR

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE';
  #
  
  package IO::File;
  
  =head1 NAME
  
  IO::File - supply object methods for filehandles
  
  =head1 SYNOPSIS
  
      use IO::File;
  
      $fh = IO::File->new();
      if ($fh->open("< file")) {
          print <$fh>;
          $fh->close;
      }
  
      $fh = IO::File->new("> file");
      if (defined $fh) {
          print $fh "bar\n";
          $fh->close;
      }
  
      $fh = IO::File->new("file", "r");
      if (defined $fh) {
          print <$fh>;
          undef $fh;       # automatically closes the file
      }
  
      $fh = IO::File->new("file", O_WRONLY|O_APPEND);
      if (defined $fh) {
          print $fh "corge\n";
  
          $pos = $fh->getpos;
          $fh->setpos($pos);
  
          undef $fh;       # automatically closes the file
      }
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::File> inherits from C<IO::Handle> and C<IO::Seekable>. It extends
  these classes with methods that are specific to file handles.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( FILENAME [,MODE [,PERMS]] )
  
  Creates an C<IO::File>.  If it receives any parameters, they are passed to
  the method C<open>; if the open fails, the object is destroyed.  Otherwise,
  it is returned to the caller.
  
  =item new_tmpfile
  
  Creates an C<IO::File> opened for read/write on a newly created temporary
  file.  On systems where this is possible, the temporary file is anonymous
  (i.e. it is unlinked after creation, but held open).  If the temporary
  file cannot be created or opened, the C<IO::File> object is destroyed.
  Otherwise, it is returned to the caller.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item open( FILENAME [,MODE [,PERMS]] )
  
  =item open( FILENAME, IOLAYERS )
  
  C<open> accepts one, two or three parameters.  With one parameter,
  it is just a front end for the built-in C<open> function.  With two or three
  parameters, the first parameter is a filename that may include
  whitespace or other special characters, and the second parameter is
  the open mode, optionally followed by a file permission value.
  
  If C<IO::File::open> receives a Perl mode string ("E<gt>", "+E<lt>", etc.)
  or an ANSI C fopen() mode string ("w", "r+", etc.), it uses the basic
  Perl C<open> operator (but protects any special characters).
  
  If C<IO::File::open> is given a numeric mode, it passes that mode
  and the optional permissions value to the Perl C<sysopen> operator.
  The permissions default to 0666.
  
  If C<IO::File::open> is given a mode that includes the C<:> character,
  it passes all the three arguments to the three-argument C<open> operator.
  
  For convenience, C<IO::File> exports the O_XXX constants from the
  Fcntl module, if this module is available.
  
  =item binmode( [LAYER] )
  
  C<binmode> sets C<binmode> on the underlying C<IO> object, as documented
  in C<perldoc -f binmode>.
  
  C<binmode> accepts one optional parameter, which is the layer to be
  passed on to the C<binmode> call.
  
  =back
  
  =head1 NOTE
  
  Some operating systems may perform  C<IO::File::new()> or C<IO::File::open()>
  on a directory without errors.  This behavior is not portable and not
  suggested for use.  Using C<opendir()> and C<readdir()> or C<IO::Dir> are
  suggested instead.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>,
  L<IO::Seekable>,
  L<IO::Dir>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>.
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO::Seekable;
  
  require Exporter;
  
  our @ISA = qw(IO::Handle IO::Seekable Exporter);
  
  our $VERSION = "1.48";
  
  our @EXPORT = @IO::Seekable::EXPORT;
  
  eval {
      # Make all Fcntl O_XXX constants available for importing
      require Fcntl;
      my @O = grep /^O_/, @Fcntl::EXPORT;
      Fcntl->import(@O);  # first we import what we want to export
      push(@EXPORT, @O);
  };
  
  ################################################
  ## Constructor
  ##
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::File";
      @_ >= 0 && @_ <= 3
  	or croak "usage: $class->new([FILENAME [,MODE [,PERMS]]])";
      my $fh = $class->SUPER::new();
      if (@_) {
  	$fh->open(@_)
  	    or return undef;
      }
      $fh;
  }
  
  ################################################
  ## Open
  ##
  
  sub open {
      @_ >= 2 && @_ <= 4 or croak 'usage: $fh->open(FILENAME [,MODE [,PERMS]])';
      my ($fh, $file) = @_;
      if (@_ > 2) {
  	my ($mode, $perms) = @_[2, 3];
  	if ($mode =~ /^\d+$/) {
  	    defined $perms or $perms = 0666;
  	    return sysopen($fh, $file, $mode, $perms);
  	} elsif ($mode =~ /:/) {
  	    return open($fh, $mode, $file) if @_ == 3;
  	    croak 'usage: $fh->open(FILENAME, IOLAYERS)';
  	} else {
              return open($fh, IO::Handle::_open_mode_string($mode), $file);
          }
      }
      open($fh, $file);
  }
  
  ################################################
  ## Binmode
  ##
  
  sub binmode {
      ( @_ == 1 or @_ == 2 ) or croak 'usage $fh->binmode([LAYER])';
  
      my($fh, $layer) = @_;
  
      return binmode $$fh unless $layer;
      return binmode $$fh, $layer;
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_FILE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Handle.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE';
  package IO::Handle;
  
  =head1 NAME
  
  IO::Handle - supply object methods for I/O handles
  
  =head1 SYNOPSIS
  
      use IO::Handle;
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDIN),"r")) {
          print $io->getline;
          $io->close;
      }
  
      $io = IO::Handle->new();
      if ($io->fdopen(fileno(STDOUT),"w")) {
          $io->print("Some text\n");
      }
  
      # setvbuf is not available by default on Perls 5.8.0 and later.
      use IO::Handle '_IOLBF';
      $io->setvbuf($buffer_var, _IOLBF, 1024);
  
      undef $io;       # automatically closes the file if it's open
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  C<IO::Handle> is the base class for all other IO handle classes. It is
  not intended that objects of C<IO::Handle> would be created directly,
  but instead C<IO::Handle> is inherited from by several other classes
  in the IO hierarchy.
  
  If you are reading this documentation, looking for a replacement for
  the C<FileHandle> package, then I suggest you read the documentation
  for C<IO::File> too.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ()
  
  Creates a new C<IO::Handle> object.
  
  =item new_from_fd ( FD, MODE )
  
  Creates an C<IO::Handle> like C<new> does.
  It requires two parameters, which are passed to the method C<fdopen>;
  if the fdopen fails, the object is destroyed. Otherwise, it is returned
  to the caller.
  
  =back
  
  =head1 METHODS
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Handle> methods, which are just front ends for the
  corresponding built-in functions:
  
      $io->close
      $io->eof
      $io->fcntl( FUNCTION, SCALAR )
      $io->fileno
      $io->format_write( [FORMAT_NAME] )
      $io->getc
      $io->ioctl( FUNCTION, SCALAR )
      $io->read ( BUF, LEN, [OFFSET] )
      $io->print ( ARGS )
      $io->printf ( FMT, [ARGS] )
      $io->say ( ARGS )
      $io->stat
      $io->sysread ( BUF, LEN, [OFFSET] )
      $io->syswrite ( BUF, [LEN, [OFFSET]] )
      $io->truncate ( LEN )
  
  See L<perlvar> for complete descriptions of each of the following
  supported C<IO::Handle> methods.  All of them return the previous
  value of the attribute and takes an optional single argument that when
  given will set the value.  If no argument is given the previous value
  is unchanged (except for $io->autoflush will actually turn ON
  autoflush by default).
  
      $io->autoflush ( [BOOL] )                         $|
      $io->format_page_number( [NUM] )                  $%
      $io->format_lines_per_page( [NUM] )               $=
      $io->format_lines_left( [NUM] )                   $-
      $io->format_name( [STR] )                         $~
      $io->format_top_name( [STR] )                     $^
      $io->input_line_number( [NUM])                    $.
  
  The following methods are not supported on a per-filehandle basis.
  
      IO::Handle->format_line_break_characters( [STR] ) $:
      IO::Handle->format_formfeed( [STR])               $^L
      IO::Handle->output_field_separator( [STR] )       $,
      IO::Handle->output_record_separator( [STR] )      $\
  
      IO::Handle->input_record_separator( [STR] )       $/
  
  Furthermore, for doing normal I/O you might need these:
  
  =over 4
  
  =item $io->fdopen ( FD, MODE )
  
  C<fdopen> is like an ordinary C<open> except that its first parameter
  is not a filename but rather a file handle name, an IO::Handle object,
  or a file descriptor number.  (For the documentation of the C<open>
  method, see L<IO::File>.)
  
  =item $io->opened
  
  Returns true if the object is currently a valid file descriptor, false
  otherwise.
  
  =item $io->getline
  
  This works like <$io> described in L<perlop/"I/O Operators">
  except that it's more readable and can be safely called in a
  list context but still returns just one line.  If used as the conditional
  within a C<while> or C-style C<for> loop, however, you will need to
  emulate the functionality of <$io> with C<< defined($_ = $io->getline) >>.
  
  =item $io->getlines
  
  This works like <$io> when called in a list context to read all
  the remaining lines in a file, except that it's more readable.
  It will also croak() if accidentally called in a scalar context.
  
  =item $io->ungetc ( ORD )
  
  Pushes a character with the given ordinal value back onto the given
  handle's input stream.  Only one character of pushback per handle is
  guaranteed.
  
  =item $io->write ( BUF, LEN [, OFFSET ] )
  
  This C<write> is somewhat like C<write> found in C, in that it is the
  opposite of read. The wrapper for the perl C<write> function is
  called C<format_write>. However, whilst the C C<write> function returns
  the number of bytes written, this C<write> function simply returns true
  if successful (like C<print>). A more C-like C<write> is C<syswrite>
  (see above).
  
  =item $io->error
  
  Returns a true value if the given handle has experienced any errors
  since it was opened or since the last call to C<clearerr>, or if the
  handle is invalid. It only returns false for a valid handle with no
  outstanding errors.
  
  =item $io->clearerr
  
  Clear the given handle's error indicator. Returns -1 if the handle is
  invalid, 0 otherwise.
  
  =item $io->sync
  
  C<sync> synchronizes a file's in-memory state  with  that  on the
  physical medium. C<sync> does not operate at the perlio api level, but
  operates on the file descriptor (similar to sysread, sysseek and
  systell). This means that any data held at the perlio api level will not
  be synchronized. To synchronize data that is buffered at the perlio api
  level you must use the flush method. C<sync> is not implemented on all
  platforms. Returns "0 but true" on success, C<undef> on error, C<undef>
  for an invalid handle. See L<fsync(3c)>.
  
  =item $io->flush
  
  C<flush> causes perl to flush any buffered data at the perlio api level.
  Any unread data in the buffer will be discarded, and any unwritten data
  will be written to the underlying file descriptor. Returns "0 but true"
  on success, C<undef> on error.
  
  =item $io->printflush ( ARGS )
  
  Turns on autoflush, print ARGS and then restores the autoflush status of the
  C<IO::Handle> object. Returns the return value from print.
  
  =item $io->blocking ( [ BOOL ] )
  
  If called with an argument C<blocking> will turn on non-blocking IO if
  C<BOOL> is false, and turn it off if C<BOOL> is true.
  
  C<blocking> will return the value of the previous setting, or the
  current setting if C<BOOL> is not given. 
  
  If an error occurs C<blocking> will return undef and C<$!> will be set.
  
  =back
  
  
  If the C functions setbuf() and/or setvbuf() are available, then
  C<IO::Handle::setbuf> and C<IO::Handle::setvbuf> set the buffering
  policy for an IO::Handle.  The calling sequences for the Perl functions
  are the same as their C counterparts--including the constants C<_IOFBF>,
  C<_IOLBF>, and C<_IONBF> for setvbuf()--except that the buffer parameter
  specifies a scalar variable to use as a buffer. You should only
  change the buffer before any I/O, or immediately after calling flush.
  
  WARNING: The IO::Handle::setvbuf() is not available by default on
  Perls 5.8.0 and later because setvbuf() is rather specific to using
  the stdio library, while Perl prefers the new perlio subsystem instead.
  
  WARNING: A variable used as a buffer by C<setbuf> or C<setvbuf> B<must not
  be modified> in any way until the IO::Handle is closed or C<setbuf> or
  C<setvbuf> is called again, or memory corruption may result! Remember that
  the order of global destruction is undefined, so even if your buffer
  variable remains in scope until program termination, it may be undefined
  before the file IO::Handle is closed. Note that you need to import the
  constants C<_IOFBF>, C<_IOLBF>, and C<_IONBF> explicitly. Like C, setbuf
  returns nothing. setvbuf returns "0 but true", on success, C<undef> on
  failure.
  
  Lastly, there is a special method for working under B<-T> and setuid/gid
  scripts:
  
  =over 4
  
  =item $io->untaint
  
  Marks the object as taint-clean, and as such data read from it will also
  be considered taint-clean. Note that this is a very trusting action to
  take, and appropriate consideration for the data source and potential
  vulnerability should be kept in mind. Returns 0 on success, -1 if setting
  the taint-clean flag failed. (eg invalid handle)
  
  =back
  
  =head1 NOTE
  
  An C<IO::Handle> object is a reference to a symbol/GLOB reference (see
  the C<Symbol> package).  Some modules that
  inherit from C<IO::Handle> may want to keep object related variables
  in the hash table part of the GLOB. In an attempt to prevent modules
  trampling on each other I propose the that any such module should prefix
  its variables with its own name separated by _'s. For example the IO::Socket
  module keeps a C<timeout> variable in 'io_socket_timeout'.
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::File>
  
  =head1 BUGS
  
  Due to backwards compatibility, all filehandles resemble objects
  of class C<IO::Handle>, or actually classes derived from that class.
  They actually aren't.  Which means you can't derive your own 
  class from C<IO::Handle> and inherit those methods.
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  
  =cut
  
  use 5.008_001;
  use strict;
  use Carp;
  use Symbol;
  use SelectSaver;
  use IO ();	# Load the XS module
  
  require Exporter;
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.48";
  
  our @EXPORT_OK = qw(
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
      format_write
  
      print
      printf
      say
      getline
      getlines
  
      printflush
      flush
  
      SEEK_SET
      SEEK_CUR
      SEEK_END
      _IOFBF
      _IOLBF
      _IONBF
  );
  
  ################################################
  ## Constructors, destructors.
  ##
  
  sub new {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      if (@_ != 1) {
  	# Since perl will automatically require IO::File if needed, but
  	# also initialises IO::File's @ISA as part of the core we must
  	# ensure IO::File is loaded if IO::Handle is. This avoids effect-
  	# ively "half-loading" IO::File.
  	if ($] > 5.013 && $class eq 'IO::File' && !$INC{"IO/File.pm"}) {
  	    require IO::File;
  	    shift;
  	    return IO::File::->new(@_);
  	}
  	croak "usage: $class->new()";
      }
      my $io = gensym;
      bless $io, $class;
  }
  
  sub new_from_fd {
      my $class = ref($_[0]) || $_[0] || "IO::Handle";
      @_ == 3 or croak "usage: $class->new_from_fd(FD, MODE)";
      my $io = gensym;
      shift;
      IO::Handle::fdopen($io, @_)
  	or return undef;
      bless $io, $class;
  }
  
  #
  # There is no need for DESTROY to do anything, because when the
  # last reference to an IO object is gone, Perl automatically
  # closes its associated files (if any).  However, to avoid any
  # attempts to autoload DESTROY, we here define it to do nothing.
  #
  sub DESTROY {}
  
  
  ################################################
  ## Open and close.
  ##
  
  sub _open_mode_string {
      my ($mode) = @_;
      $mode =~ /^\+?(<|>>?)$/
        or $mode =~ s/^r(\+?)$/$1</
        or $mode =~ s/^w(\+?)$/$1>/
        or $mode =~ s/^a(\+?)$/$1>>/
        or croak "IO::Handle: bad open mode: $mode";
      $mode;
  }
  
  sub fdopen {
      @_ == 3 or croak 'usage: $io->fdopen(FD, MODE)';
      my ($io, $fd, $mode) = @_;
      local(*GLOB);
  
      if (ref($fd) && "$fd" =~ /GLOB\(/o) {
  	# It's a glob reference; Alias it as we cannot get name of anon GLOBs
  	my $n = qualify(*GLOB);
  	*GLOB = *{*$fd};
  	$fd =  $n;
      } elsif ($fd =~ m#^\d+$#) {
  	# It's an FD number; prefix with "=".
  	$fd = "=$fd";
      }
  
      open($io, _open_mode_string($mode) . '&' . $fd)
  	? $io : undef;
  }
  
  sub close {
      @_ == 1 or croak 'usage: $io->close()';
      my($io) = @_;
  
      close($io);
  }
  
  ################################################
  ## Normal I/O functions.
  ##
  
  # flock
  # select
  
  sub opened {
      @_ == 1 or croak 'usage: $io->opened()';
      defined fileno($_[0]);
  }
  
  sub fileno {
      @_ == 1 or croak 'usage: $io->fileno()';
      fileno($_[0]);
  }
  
  sub getc {
      @_ == 1 or croak 'usage: $io->getc()';
      getc($_[0]);
  }
  
  sub eof {
      @_ == 1 or croak 'usage: $io->eof()';
      eof($_[0]);
  }
  
  sub print {
      @_ or croak 'usage: $io->print(ARGS)';
      my $this = shift;
      print $this @_;
  }
  
  sub printf {
      @_ >= 2 or croak 'usage: $io->printf(FMT,[ARGS])';
      my $this = shift;
      printf $this @_;
  }
  
  sub say {
      @_ or croak 'usage: $io->say(ARGS)';
      my $this = shift;
      local $\ = "\n";
      print $this @_;
  }
  
  sub truncate {
      @_ == 2 or croak 'usage: $io->truncate(LEN)';
      truncate($_[0], $_[1]);
  }
  
  sub read {
      @_ == 3 || @_ == 4 or croak 'usage: $io->read(BUF, LEN [, OFFSET])';
      read($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub sysread {
      @_ == 3 || @_ == 4 or croak 'usage: $io->sysread(BUF, LEN [, OFFSET])';
      sysread($_[0], $_[1], $_[2], $_[3] || 0);
  }
  
  sub write {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->write(BUF [, LEN [, OFFSET]])';
      local($\) = "";
      $_[2] = length($_[1]) unless defined $_[2];
      print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);
  }
  
  sub syswrite {
      @_ >= 2 && @_ <= 4 or croak 'usage: $io->syswrite(BUF [, LEN [, OFFSET]])';
      if (defined($_[2])) {
  	syswrite($_[0], $_[1], $_[2], $_[3] || 0);
      } else {
  	syswrite($_[0], $_[1]);
      }
  }
  
  sub stat {
      @_ == 1 or croak 'usage: $io->stat()';
      stat($_[0]);
  }
  
  ################################################
  ## State modification functions.
  ##
  
  sub autoflush {
      my $old = SelectSaver->new(qualify($_[0], caller));
      my $prev = $|;
      $| = @_ > 1 ? $_[1] : 1;
      $prev;
  }
  
  sub output_field_separator {
      carp "output_field_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $,;
      $, = $_[1] if @_ > 1;
      $prev;
  }
  
  sub output_record_separator {
      carp "output_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $\;
      $\ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_record_separator {
      carp "input_record_separator is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $/;
      $/ = $_[1] if @_ > 1;
      $prev;
  }
  
  sub input_line_number {
      local $.;
      () = tell qualify($_[0], caller) if ref($_[0]);
      my $prev = $.;
      $. = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_page_number {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $%;
      $% = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_per_page {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $=;
      $= = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_lines_left {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $-;
      $- = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $~;
      $~ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_top_name {
      my $old;
      $old = SelectSaver->new(qualify($_[0], caller)) if ref($_[0]);
      my $prev = $^;
      $^ = qualify($_[1], caller) if @_ > 1;
      $prev;
  }
  
  sub format_line_break_characters {
      carp "format_line_break_characters is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $:;
      $: = $_[1] if @_ > 1;
      $prev;
  }
  
  sub format_formfeed {
      carp "format_formfeed is not supported on a per-handle basis"
  	if ref($_[0]);
      my $prev = $^L;
      $^L = $_[1] if @_ > 1;
      $prev;
  }
  
  sub formline {
      my $io = shift;
      my $picture = shift;
      local($^A) = $^A;
      local($\) = "";
      formline($picture, @_);
      print $io $^A;
  }
  
  sub format_write {
      @_ < 3 || croak 'usage: $io->write( [FORMAT_NAME] )';
      if (@_ == 2) {
  	my ($io, $fmt) = @_;
  	my $oldfmt = $io->format_name(qualify($fmt,caller));
  	CORE::write($io);
  	$io->format_name($oldfmt);
      } else {
  	CORE::write($_[0]);
      }
  }
  
  sub fcntl {
      @_ == 3 || croak 'usage: $io->fcntl( OP, VALUE );';
      my ($io, $op) = @_;
      return fcntl($io, $op, $_[2]);
  }
  
  sub ioctl {
      @_ == 3 || croak 'usage: $io->ioctl( OP, VALUE );';
      my ($io, $op) = @_;
      return ioctl($io, $op, $_[2]);
  }
  
  # this sub is for compatibility with older releases of IO that used
  # a sub called constant to determine if a constant existed -- GMB
  #
  # The SEEK_* and _IO?BF constants were the only constants at that time
  # any new code should just check defined(&CONSTANT_NAME)
  
  sub constant {
      no strict 'refs';
      my $name = shift;
      (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})
  	? &{$name}() : undef;
  }
  
  
  # so that flush.pl can be deprecated
  
  sub printflush {
      my $io = shift;
      my $old;
      $old = SelectSaver->new(qualify($io, caller)) if ref($io);
      local $| = 1;
      if(ref($io)) {
          print $io @_;
      }
      else {
  	print @_;
      }
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_HANDLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Pipe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE';
  # IO::Pipe.pm
  #
  # Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Pipe;
  
  use 5.008_001;
  
  use IO::Handle;
  use strict;
  use Carp;
  use Symbol;
  
  our $VERSION = "1.49";
  
  sub new {
      my $type = shift;
      my $class = ref($type) || $type || "IO::Pipe";
      @_ == 0 || @_ == 2 or croak "usage: $class->([READFH, WRITEFH])";
  
      my $me = bless gensym(), $class;
  
      my($readfh,$writefh) = @_ ? @_ : $me->handles;
  
      pipe($readfh, $writefh)
  	or return undef;
  
      @{*$me} = ($readfh, $writefh);
  
      $me;
  }
  
  sub handles {
      @_ == 1 or croak 'usage: $pipe->handles()';
      (IO::Pipe::End->new(), IO::Pipe::End->new());
  }
  
  my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';
  
  sub _doit {
      my $me = shift;
      my $rw = shift;
  
      my $pid = $do_spawn ? 0 : fork();
  
      if($pid) { # Parent
          return $pid;
      }
      elsif(defined $pid) { # Child or spawn
          my $fh;
          my $io = $rw ? \*STDIN : \*STDOUT;
          my ($mode, $save) = $rw ? "r" : "w";
          if ($do_spawn) {
            require Fcntl;
            $save = IO::Handle->new_from_fd($io, $mode);
  	  my $handle = shift;
            # Close in child:
  	  unless ($^O eq 'MSWin32') {
              fcntl($handle, Fcntl::F_SETFD(), 1) or croak "fcntl: $!";
  	  }
            $fh = $rw ? ${*$me}[0] : ${*$me}[1];
          } else {
            shift;
            $fh = $rw ? $me->reader() : $me->writer(); # close the other end
          }
          bless $io, "IO::Handle";
          $io->fdopen($fh, $mode);
  	$fh->close;
  
          if ($do_spawn) {
            $pid = eval { system 1, @_ }; # 1 == P_NOWAIT
            my $err = $!;
      
            $io->fdopen($save, $mode);
            $save->close or croak "Cannot close $!";
            croak "IO::Pipe: Cannot spawn-NOWAIT: $err" if not $pid or $pid < 0;
            return $pid;
          } else {
            exec @_ or
              croak "IO::Pipe: Cannot exec: $!";
          }
      }
      else {
          croak "IO::Pipe: Cannot fork: $!";
      }
  
      # NOT Reached
  }
  
  sub reader {
      @_ >= 1 or croak 'usage: $pipe->reader( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[0];
      my $pid;
      $pid = $me->_doit(0, $fh, @_)
          if(@_);
  
      close ${*$me}[1];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"r")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  sub writer {
      @_ >= 1 or croak 'usage: $pipe->writer( [SUB_COMMAND_ARGS] )';
      my $me = shift;
  
      return undef
  	unless(ref($me) || ref($me = $me->new));
  
      my $fh  = ${*$me}[1];
      my $pid;
      $pid = $me->_doit(1, $fh, @_)
          if(@_);
  
      close ${*$me}[0];
      bless $me, ref($fh);
      *$me = *$fh;          # Alias self to handle
      $me->fdopen($fh->fileno,"w")
  	unless defined($me->fileno);
      bless $fh;                  # Really wan't un-bless here
      ${*$me}{'io_pipe_pid'} = $pid
          if defined $pid;
  
      $me;
  }
  
  package IO::Pipe::End;
  
  our(@ISA);
  
  @ISA = qw(IO::Handle);
  
  sub close {
      my $fh = shift;
      my $r = $fh->SUPER::close(@_);
  
      waitpid(${*$fh}{'io_pipe_pid'},0)
  	if(defined ${*$fh}{'io_pipe_pid'});
  
      $r;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Pipe - supply object methods for pipes
  
  =head1 SYNOPSIS
  
  	use IO::Pipe;
  
  	$pipe = IO::Pipe->new();
  
  	if($pid = fork()) { # Parent
  	    $pipe->reader();
  
  	    while(<$pipe>) {
  		...
  	    }
  
  	}
  	elsif(defined $pid) { # Child
  	    $pipe->writer();
  
  	    print $pipe ...
  	}
  
  	or
  
  	$pipe = IO::Pipe->new();
  
  	$pipe->reader(qw(ls -l));
  
  	while(<$pipe>) {
  	    ...
  	}
  
  =head1 DESCRIPTION
  
  C<IO::Pipe> provides an interface to creating pipes between
  processes.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [READER, WRITER] )
  
  Creates an C<IO::Pipe>, which is a reference to a newly created symbol
  (see the C<Symbol> package). C<IO::Pipe::new> optionally takes two
  arguments, which should be objects blessed into C<IO::Handle>, or a
  subclass thereof. These two objects will be used for the system call
  to C<pipe>. If no arguments are given then method C<handles> is called
  on the new C<IO::Pipe> object.
  
  These two handles are held in the array part of the GLOB until either
  C<reader> or C<writer> is called.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item reader ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the reading end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item writer ([ARGS])
  
  The object is re-blessed into a sub-class of C<IO::Handle>, and becomes a
  handle at the writing end of the pipe. If C<ARGS> are given then C<fork>
  is called and C<ARGS> are passed to exec.
  
  =item handles ()
  
  This method is called during construction by C<IO::Pipe::new>
  on the newly created C<IO::Pipe> object. It returns an array of two objects
  blessed into C<IO::Pipe::End>, or a subclass thereof.
  
  =back
  
  =head1 SEE ALSO
  
  L<IO::Handle>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_PIPE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Poll.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL';
  
  # IO::Poll.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Poll;
  
  use strict;
  use IO::Handle;
  use Exporter ();
  
  our @ISA = qw(Exporter);
  our $VERSION = "1.49";
  
  our @EXPORT = qw( POLLIN
  	      POLLOUT
  	      POLLERR
  	      POLLHUP
  	      POLLNVAL
  	    );
  
  our @EXPORT_OK = qw(
   POLLPRI
   POLLRDNORM
   POLLWRNORM
   POLLRDBAND
   POLLWRBAND
   POLLNORM
  	       );
  
  # [0] maps fd's to requested masks
  # [1] maps fd's to returned  masks
  # [2] maps fd's to handles
  sub new {
      my $class = shift;
  
      my $self = bless [{},{},{}], $class;
  
      $self;
  }
  
  sub mask {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      return unless defined $fd;
      if (@_) {
  	my $mask = shift;
  	if($mask) {
  	  $self->[0]{$fd}{$io} = $mask; # the error events are always returned
  	  $self->[1]{$fd}      = 0;     # output mask
  	  $self->[2]{$io}      = $io;   # remember handle
  	} else {
            delete $self->[0]{$fd}{$io};
            unless(%{$self->[0]{$fd}}) {
              # We no longer have any handles for this FD
              delete $self->[1]{$fd};
              delete $self->[0]{$fd};
            }
            delete $self->[2]{$io};
  	}
      }
      
      return unless exists $self->[0]{$fd} and exists $self->[0]{$fd}{$io};
  	return $self->[0]{$fd}{$io};
  }
  
  
  sub poll {
      my($self,$timeout) = @_;
  
      $self->[1] = {};
  
      my($fd,$mask,$iom);
      my @poll = ();
  
      while(($fd,$iom) = each %{$self->[0]}) {
  	$mask   = 0;
  	$mask  |= $_ for values(%$iom);
  	push(@poll,$fd => $mask);
      }
  
      my $ret = _poll(defined($timeout) ? $timeout * 1000 : -1,@poll);
  
      return $ret
  	unless $ret > 0;
  
      while(@poll) {
  	my($fd,$got) = splice(@poll,0,2);
  	$self->[1]{$fd} = $got if $got;
      }
  
      return $ret;  
  }
  
  sub events {
      my $self = shift;
      my $io = shift;
      my $fd = fileno($io);
      exists $self->[1]{$fd} and exists $self->[0]{$fd}{$io} 
                  ? $self->[1]{$fd} & ($self->[0]{$fd}{$io}|POLLHUP|POLLERR|POLLNVAL)
  	: 0;
  }
  
  sub remove {
      my $self = shift;
      my $io = shift;
      $self->mask($io,0);
  }
  
  sub handles {
      my $self = shift;
      return values %{$self->[2]} unless @_;
  
      my $events = shift || 0;
      my($fd,$ev,$io,$mask);
      my @handles = ();
  
      while(($fd,$ev) = each %{$self->[1]}) {
  	while (($io,$mask) = each %{$self->[0]{$fd}}) {
  	    $mask |= POLLHUP|POLLERR|POLLNVAL;  # must allow these
  	    push @handles,$self->[2]{$io} if ($ev & $mask) & $events;
  	}
      }
      return @handles;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Poll - Object interface to system poll call
  
  =head1 SYNOPSIS
  
      use IO::Poll qw(POLLRDNORM POLLWRNORM POLLIN POLLHUP);
  
      $poll = IO::Poll->new();
  
      $poll->mask($input_handle => POLLIN);
      $poll->mask($output_handle => POLLOUT);
  
      $poll->poll($timeout);
  
      $ev = $poll->events($input);
  
  =head1 DESCRIPTION
  
  C<IO::Poll> is a simple interface to the system level poll routine.
  
  =head1 METHODS
  
  =over 4
  
  =item mask ( IO [, EVENT_MASK ] )
  
  If EVENT_MASK is given, then, if EVENT_MASK is non-zero, IO is added to the
  list of file descriptors and the next call to poll will check for
  any event specified in EVENT_MASK. If EVENT_MASK is zero then IO will be
  removed from the list of file descriptors.
  
  If EVENT_MASK is not given then the return value will be the current
  event mask value for IO.
  
  =item poll ( [ TIMEOUT ] )
  
  Call the system level poll routine. If TIMEOUT is not specified then the
  call will block. Returns the number of handles which had events
  happen, or -1 on error.
  
  =item events ( IO )
  
  Returns the event mask which represents the events that happened on IO
  during the last call to C<poll>.
  
  =item remove ( IO )
  
  Remove IO from the list of file descriptors for the next poll.
  
  =item handles( [ EVENT_MASK ] )
  
  Returns a list of handles. If EVENT_MASK is not given then a list of all
  handles known will be returned. If EVENT_MASK is given then a list
  of handles will be returned which had one of the events specified by
  EVENT_MASK happen during the last call ti C<poll>
  
  =back
  
  =head1 SEE ALSO
  
  L<poll(2)>, L<IO::Handle>, L<IO::Select>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_POLL

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Seekable.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE';
  #
  
  package IO::Seekable;
  
  =head1 NAME
  
  IO::Seekable - supply seek based methods for I/O objects
  
  =head1 SYNOPSIS
  
      use IO::Seekable;
      package IO::Something;
      @ISA = qw(IO::Seekable);
  
  =head1 DESCRIPTION
  
  C<IO::Seekable> does not have a constructor of its own as it is intended to
  be inherited by other C<IO::Handle> based objects. It provides methods
  which allow seeking of the file descriptors.
  
  =over 4
  
  =item $io->getpos
  
  Returns an opaque value that represents the current position of the
  IO::File, or C<undef> if this is not possible (eg an unseekable stream such
  as a terminal, pipe or socket). If the fgetpos() function is available in
  your C library it is used to implements getpos, else perl emulates getpos
  using C's ftell() function.
  
  =item $io->setpos
  
  Uses the value of a previous getpos call to return to a previously visited
  position. Returns "0 but true" on success, C<undef> on failure.
  
  =back
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<IO::Seekable> methods, which are just front ends for the
  corresponding built-in functions:
  
  =over 4
  
  =item $io->seek ( POS, WHENCE )
  
  Seek the IO::File to position POS, relative to WHENCE:
  
  =over 8
  
  =item WHENCE=0 (SEEK_SET)
  
  POS is absolute position. (Seek relative to the start of the file)
  
  =item WHENCE=1 (SEEK_CUR)
  
  POS is an offset from the current position. (Seek relative to current)
  
  =item WHENCE=2 (SEEK_END)
  
  POS is an offset from the end of the file. (Seek relative to end)
  
  =back
  
  The SEEK_* constants can be imported from the C<Fcntl> module if you
  don't wish to use the numbers C<0> C<1> or C<2> in your code.
  
  Returns C<1> upon success, C<0> otherwise.
  
  =item $io->sysseek( POS, WHENCE )
  
  Similar to $io->seek, but sets the IO::File's position using the system
  call lseek(2) directly, so will confuse most perl IO operators except
  sysread and syswrite (see L<perlfunc> for full details)
  
  Returns the new position, or C<undef> on failure.  A position
  of zero is returned as the string C<"0 but true">
  
  =item $io->tell
  
  Returns the IO::File's current position, or -1 on error.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc>, 
  L<perlop/"I/O Operators">,
  L<IO::Handle>
  L<IO::File>
  
  =head1 HISTORY
  
  Derived from FileHandle.pm by Graham Barr E<lt>gbarr@pobox.comE<gt>
  
  =cut
  
  use 5.008_001;
  use Carp;
  use strict;
  use IO::Handle ();
  # XXX we can't get these from IO::Handle or we'll get prototype
  # mismatch warnings on C<use POSIX; use IO::File;> :-(
  use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
  require Exporter;
  
  our @EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);
  our @ISA = qw(Exporter);
  
  our $VERSION = "1.48";
  
  sub seek {
      @_ == 3 or croak 'usage: $io->seek(POS, WHENCE)';
      seek($_[0], $_[1], $_[2]);
  }
  
  sub sysseek {
      @_ == 3 or croak 'usage: $io->sysseek(POS, WHENCE)';
      sysseek($_[0], $_[1], $_[2]);
  }
  
  sub tell {
      @_ == 1 or croak 'usage: $io->tell()';
      tell($_[0]);
  }
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_IO_SEEKABLE

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Select.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT';
  # IO::Select.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Select;
  
  use     strict;
  use warnings::register;
  require Exporter;
  
  our $VERSION = "1.49";
  
  our @ISA = qw(Exporter); # This is only so we can do version checking
  
  sub VEC_BITS () {0}
  sub FD_COUNT () {1}
  sub FIRST_FD () {2}
  
  sub new
  {
   my $self = shift;
   my $type = ref($self) || $self;
  
   my $vec = bless [undef,0], $type;
  
   $vec->add(@_)
      if @_;
  
   $vec;
  }
  
  sub add
  {
   shift->_update('add', @_);
  }
  
  
  sub remove
  {
   shift->_update('remove', @_);
  }
  
  
  sub exists
  {
   my $vec = shift;
   my $fno = $vec->_fileno(shift);
   return undef unless defined $fno;
   $vec->[$fno + FIRST_FD];
  }
  
  
  sub _fileno
  {
   my($self, $f) = @_;
   return unless defined $f;
   $f = $f->[0] if ref($f) eq 'ARRAY';
   if($f =~ /^[0-9]+$/) { # plain file number
    return $f;
   }
   elsif(defined(my $fd = fileno($f))) {
    return $fd;
   }
   else {
    # Neither a plain file number nor an opened filehandle; but maybe it was
    # previously registered and has since been closed. ->remove still wants to
    # know what fileno it had
    foreach my $i ( FIRST_FD .. $#$self ) {
     return $i - FIRST_FD if defined $self->[$i] && $self->[$i] == $f;
    }
    return undef;
   }
  }
  
  sub _update
  {
   my $vec = shift;
   my $add = shift eq 'add';
  
   my $bits = $vec->[VEC_BITS];
   $bits = '' unless defined $bits;
  
   my $count = 0;
   my $f;
   foreach $f (@_)
    {
     my $fn = $vec->_fileno($f);
     if ($add) {
       next unless defined $fn;
       my $i = $fn + FIRST_FD;
       if (defined $vec->[$i]) {
  	 $vec->[$i] = $f;  # if array rest might be different, so we update
  	 next;
       }
       $vec->[FD_COUNT]++;
       vec($bits, $fn, 1) = 1;
       $vec->[$i] = $f;
     } else {      # remove
       if ( ! defined $fn ) { # remove if fileno undef'd
         $fn = 0;
         for my $fe (@{$vec}[FIRST_FD .. $#$vec]) {
           if (defined($fe) && $fe == $f) {
  	   $vec->[FD_COUNT]--;
  	   $fe = undef;
  	   vec($bits, $fn, 1) = 0;
  	   last;
  	 }
  	 ++$fn;
         }
       }
       else {
         my $i = $fn + FIRST_FD;
         next unless defined $vec->[$i];
         $vec->[FD_COUNT]--;
         vec($bits, $fn, 1) = 0;
         $vec->[$i] = undef;
       }
     }
     $count++;
    }
   $vec->[VEC_BITS] = $vec->[FD_COUNT] ? $bits : undef;
   $count;
  }
  
  sub can_read
  {
   my $vec = shift;
   my $timeout = shift;
   my $r = $vec->[VEC_BITS];
  
   defined($r) && (select($r,undef,undef,$timeout) > 0)
      ? handles($vec, $r)
      : ();
  }
  
  sub can_write
  {
   my $vec = shift;
   my $timeout = shift;
   my $w = $vec->[VEC_BITS];
  
   defined($w) && (select(undef,$w,undef,$timeout) > 0)
      ? handles($vec, $w)
      : ();
  }
  
  sub has_exception
  {
   my $vec = shift;
   my $timeout = shift;
   my $e = $vec->[VEC_BITS];
  
   defined($e) && (select(undef,undef,$e,$timeout) > 0)
      ? handles($vec, $e)
      : ();
  }
  
  sub has_error
  {
   warnings::warn("Call to deprecated method 'has_error', use 'has_exception'")
  	if warnings::enabled();
   goto &has_exception;
  }
  
  sub count
  {
   my $vec = shift;
   $vec->[FD_COUNT];
  }
  
  sub bits
  {
   my $vec = shift;
   $vec->[VEC_BITS];
  }
  
  sub as_string  # for debugging
  {
   my $vec = shift;
   my $str = ref($vec) . ": ";
   my $bits = $vec->bits;
   my $count = $vec->count;
   $str .= defined($bits) ? unpack("b*", $bits) : "undef";
   $str .= " $count";
   my @handles = @$vec;
   splice(@handles, 0, FIRST_FD);
   for (@handles) {
       $str .= " " . (defined($_) ? "$_" : "-");
   }
   $str;
  }
  
  sub _max
  {
   my($a,$b,$c) = @_;
   $a > $b
      ? $a > $c
          ? $a
          : $c
      : $b > $c
          ? $b
          : $c;
  }
  
  sub select
  {
   shift
     if defined $_[0] && !ref($_[0]);
  
   my($r,$w,$e,$t) = @_;
   my @result = ();
  
   my $rb = defined $r ? $r->[VEC_BITS] : undef;
   my $wb = defined $w ? $w->[VEC_BITS] : undef;
   my $eb = defined $e ? $e->[VEC_BITS] : undef;
  
   if(select($rb,$wb,$eb,$t) > 0)
    {
     my @r = ();
     my @w = ();
     my @e = ();
     my $i = _max(defined $r ? scalar(@$r)-1 : 0,
                  defined $w ? scalar(@$w)-1 : 0,
                  defined $e ? scalar(@$e)-1 : 0);
  
     for( ; $i >= FIRST_FD ; $i--)
      {
       my $j = $i - FIRST_FD;
       push(@r, $r->[$i])
          if defined $rb && defined $r->[$i] && vec($rb, $j, 1);
       push(@w, $w->[$i])
          if defined $wb && defined $w->[$i] && vec($wb, $j, 1);
       push(@e, $e->[$i])
          if defined $eb && defined $e->[$i] && vec($eb, $j, 1);
      }
  
     @result = (\@r, \@w, \@e);
    }
   @result;
  }
  
  
  sub handles
  {
   my $vec = shift;
   my $bits = shift;
   my @h = ();
   my $i;
   my $max = scalar(@$vec) - 1;
  
   for ($i = FIRST_FD; $i <= $max; $i++)
    {
     next unless defined $vec->[$i];
     push(@h, $vec->[$i])
        if !defined($bits) || vec($bits, $i - FIRST_FD, 1);
    }
   
   @h;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  IO::Select - OO interface to the select system call
  
  =head1 SYNOPSIS
  
      use IO::Select;
  
      $s = IO::Select->new();
  
      $s->add(\*STDIN);
      $s->add($some_handle);
  
      @ready = $s->can_read($timeout);
  
      @ready = IO::Select->new(@handles)->can_read(0);
  
  =head1 DESCRIPTION
  
  The C<IO::Select> package implements an object approach to the system C<select>
  function call. It allows the user to see what IO handles, see L<IO::Handle>,
  are ready for reading, writing or have an exception pending.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ HANDLES ] )
  
  The constructor creates a new object and optionally initialises it with a set
  of handles.
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item add ( HANDLES )
  
  Add the list of handles to the C<IO::Select> object. It is these values that
  will be returned when an event occurs. C<IO::Select> keeps these values in a
  cache which is indexed by the C<fileno> of the handle, so if more than one
  handle with the same C<fileno> is specified then only the last one is cached.
  
  Each handle can be an C<IO::Handle> object, an integer or an array
  reference where the first element is an C<IO::Handle> or an integer.
  
  =item remove ( HANDLES )
  
  Remove all the given handles from the object. This method also works
  by the C<fileno> of the handles. So the exact handles that were added
  need not be passed, just handles that have an equivalent C<fileno>
  
  =item exists ( HANDLE )
  
  Returns a true value (actually the handle itself) if it is present.
  Returns undef otherwise.
  
  =item handles
  
  Return an array of all registered handles.
  
  =item can_read ( [ TIMEOUT ] )
  
  Return an array of handles that are ready for reading.  C<TIMEOUT> is the
  maximum amount of time to wait before returning an empty list (with C<$!>
  unchanged), in seconds, possibly fractional.  If C<TIMEOUT> is not given
  and any handles are registered then the call will block indefinitely.
  Upon error, an empty list is returned, with C<$!> set to indicate the
  error.  To distinguish between timeout and error, set C<$!> to zero
  before calling this method, and check it after an empty list is returned.
  
  =item can_write ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that can be written to.
  
  =item has_exception ( [ TIMEOUT ] )
  
  Same as C<can_read> except check for handles that have an exception
  condition, for example pending out-of-band data.
  
  =item count ()
  
  Returns the number of handles that the object will check for when
  one of the C<can_> methods is called or the object is passed to
  the C<select> static method.
  
  =item bits()
  
  Return the bit string suitable as argument to the core select() call.
  
  =item select ( READ, WRITE, EXCEPTION [, TIMEOUT ] )
  
  C<select> is a static method, that is you call it with the package name
  like C<new>. C<READ>, C<WRITE> and C<EXCEPTION> are either C<undef> or
  C<IO::Select> objects. C<TIMEOUT> is optional and has the same effect as
  for the core select call.
  
  If at least one handle is ready for the specified kind of operation,
  the result will be an array of 3 elements, each a reference to an array
  which will hold the handles that are ready for reading, writing and
  have exceptions respectively.  Upon timeout, an empty list is returned,
  with C<$!> unchanged.  Upon error, an empty list is returned, with C<$!>
  set to indicate the error.  To distinguish between timeout and error,
  set C<$!> to zero before calling this method, and check it after an
  empty list is returned.
  
  =back
  
  =head1 EXAMPLE
  
  Here is a short example which shows how C<IO::Select> could be used
  to write a server which communicates with several sockets while also
  listening for more connections on a listen socket
  
      use IO::Select;
      use IO::Socket;
  
      $lsn = IO::Socket::INET->new(Listen => 1, LocalPort => 8080);
      $sel = IO::Select->new( $lsn );
  
      while(@ready = $sel->can_read) {
          foreach $fh (@ready) {
              if($fh == $lsn) {
                  # Create a new socket
                  $new = $lsn->accept;
                  $sel->add($new);
              }
              else {
                  # Process socket
  
                  # Maybe we have finished with the socket
                  $sel->remove($fh);
                  $fh->close;
              }
          }
      }
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
  
X86_64-LINUX-GNU-THREAD-MULTI_IO_SELECT

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET';
  
  # IO::Socket.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket;
  
  use 5.008_001;
  
  use IO::Handle;
  use Socket 1.3;
  use Carp;
  use strict;
  use Exporter;
  use Errno;
  
  # legacy
  
  require IO::Socket::INET;
  require IO::Socket::UNIX if ($^O ne 'epoc' && $^O ne 'symbian');
  
  our @ISA = qw(IO::Handle);
  
  our $VERSION = "1.49";
  
  our @EXPORT_OK = qw(sockatmark);
  
  our $errstr;
  
  sub import {
      my $pkg = shift;
      if (@_ && $_[0] eq 'sockatmark') { # not very extensible but for now, fast
  	Exporter::export_to_level('IO::Socket', 1, $pkg, 'sockatmark');
      } else {
  	my $callpkg = caller;
  	Exporter::export 'Socket', $callpkg, @_;
      }
  }
  
  sub new {
      my($class,%arg) = @_;
      my $sock = $class->SUPER::new();
  
      $sock->autoflush(1);
  
      ${*$sock}{'io_socket_timeout'} = delete $arg{Timeout};
  
      return scalar(%arg) ? $sock->configure(\%arg)
  			: $sock;
  }
  
  my @domain2pkg;
  
  sub register_domain {
      my($p,$d) = @_;
      $domain2pkg[$d] = $p;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my $domain = delete $arg->{Domain};
  
      croak 'IO::Socket: Cannot configure a generic socket'
  	unless defined $domain;
  
      croak "IO::Socket: Unsupported socket domain"
  	unless defined $domain2pkg[$domain];
  
      croak "IO::Socket: Cannot configure socket in domain '$domain'"
  	unless ref($sock) eq "IO::Socket";
  
      bless($sock, $domain2pkg[$domain]);
      $sock->configure($arg);
  }
  
  sub socket {
      @_ == 4 or croak 'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)';
      my($sock,$domain,$type,$protocol) = @_;
  
      socket($sock,$domain,$type,$protocol) or
      	return undef;
  
      ${*$sock}{'io_socket_domain'} = $domain;
      ${*$sock}{'io_socket_type'}   = $type;
  
      # "A value of 0 for protocol will let the system select an
      # appropriate protocol"
      # so we need to look up what the system selected,
      # not cache PF_UNSPEC.
      ${*$sock}{'io_socket_proto'} = $protocol if $protocol;
  
      $sock;
  }
  
  sub socketpair {
      @_ == 4 || croak 'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)';
      my($class,$domain,$type,$protocol) = @_;
      my $sock1 = $class->new();
      my $sock2 = $class->new();
  
      socketpair($sock1,$sock2,$domain,$type,$protocol) or
      	return ();
  
      ${*$sock1}{'io_socket_type'}  = ${*$sock2}{'io_socket_type'}  = $type;
      ${*$sock1}{'io_socket_proto'} = ${*$sock2}{'io_socket_proto'} = $protocol;
  
      ($sock1,$sock2);
  }
  
  sub connect {
      @_ == 2 or croak 'usage: $sock->connect(NAME)';
      my $sock = shift;
      my $addr = shift;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $err;
      my $blocking;
  
      $blocking = $sock->blocking(0) if $timeout;
      if (!connect($sock, $addr)) {
  	if (defined $timeout && ($!{EINPROGRESS} || $!{EWOULDBLOCK})) {
  	    require IO::Select;
  
  	    my $sel = IO::Select->new( $sock );
  
  	    undef $!;
  	    my($r,$w,$e) = IO::Select::select(undef,$sel,$sel,$timeout);
  	    if(@$e[0]) {
  		# Windows return from select after the timeout in case of
  		# WSAECONNREFUSED(10061) if exception set is not used.
  		# This behavior is different from Linux.
  		# Using the exception
  		# set we now emulate the behavior in Linux
  		#    - Karthik Rajagopalan
  		$err = $sock->getsockopt(SOL_SOCKET,SO_ERROR);
  		$errstr = $@ = "connect: $err";
  	    }
  	    elsif(!@$w[0]) {
  		$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  		$errstr = $@ = "connect: timeout";
  	    }
  	    elsif (!connect($sock,$addr) &&
                  not ($!{EISCONN} || ($^O eq 'MSWin32' &&
                  ($! == (($] < 5.019004) ? 10022 : Errno::EINVAL))))
              ) {
  		# Some systems refuse to re-connect() to
  		# an already open socket and set errno to EISCONN.
  		# Windows sets errno to WSAEINVAL (10022) (pre-5.19.4) or
  		# EINVAL (22) (5.19.4 onwards).
  		$err = $!;
  		$errstr = $@ = "connect: $!";
  	    }
  	}
          elsif ($blocking || !($!{EINPROGRESS} || $!{EWOULDBLOCK}))  {
  	    $err = $!;
  	    $errstr = $@ = "connect: $!";
  	}
      }
  
      $sock->blocking(1) if $blocking;
  
      $! = $err if $err;
  
      $err ? undef : $sock;
  }
  
  # Enable/disable blocking IO on sockets.
  # Without args return the current status of blocking,
  # with args change the mode as appropriate, returning the
  # old setting, or in case of error during the mode change
  # undef.
  
  sub blocking {
      my $sock = shift;
  
      return $sock->SUPER::blocking(@_)
          if $^O ne 'MSWin32' && $^O ne 'VMS';
  
      # Windows handles blocking differently
      #
      # http://groups.google.co.uk/group/perl.perl5.porters/browse_thread/thread/b4e2b1d88280ddff/630b667a66e3509f?#630b667a66e3509f
      # http://msdn.microsoft.com/library/default.asp?url=/library/en-us/winsock/winsock/ioctlsocket_2.asp
      #
      # 0x8004667e is FIONBIO
      #
      # which is used to set blocking behaviour.
  
      # NOTE:
      # This is a little confusing, the perl keyword for this is
      # 'blocking' but the OS level behaviour is 'non-blocking', probably
      # because sockets are blocking by default.
      # Therefore internally we have to reverse the semantics.
  
      my $orig= !${*$sock}{io_sock_nonblocking};
  
      return $orig unless @_;
  
      my $block = shift;
  
      if ( !$block != !$orig ) {
          ${*$sock}{io_sock_nonblocking} = $block ? 0 : 1;
          ioctl($sock, 0x8004667e, pack("L!",${*$sock}{io_sock_nonblocking}))
              or return undef;
      }
  
      return $orig;
  }
  
  
  sub close {
      @_ == 1 or croak 'usage: $sock->close()';
      my $sock = shift;
      ${*$sock}{'io_socket_peername'} = undef;
      $sock->SUPER::close();
  }
  
  sub bind {
      @_ == 2 or croak 'usage: $sock->bind(NAME)';
      my $sock = shift;
      my $addr = shift;
  
      return bind($sock, $addr) ? $sock
  			      : undef;
  }
  
  sub listen {
      @_ >= 1 && @_ <= 2 or croak 'usage: $sock->listen([QUEUE])';
      my($sock,$queue) = @_;
      $queue = 5
  	unless $queue && $queue > 0;
  
      return listen($sock, $queue) ? $sock
  				 : undef;
  }
  
  sub accept {
      @_ == 1 || @_ == 2 or croak 'usage $sock->accept([PKG])';
      my $sock = shift;
      my $pkg = shift || $sock;
      my $timeout = ${*$sock}{'io_socket_timeout'};
      my $new = $pkg->new(Timeout => $timeout);
      my $peer = undef;
  
      if(defined $timeout) {
  	require IO::Select;
  
  	my $sel = IO::Select->new( $sock );
  
  	unless ($sel->can_read($timeout)) {
  	    $errstr = $@ = 'accept: timeout';
  	    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);
  	    return;
  	}
      }
  
      $peer = accept($new,$sock)
  	or return;
  
      ${*$new}{$_} = ${*$sock}{$_} for qw( io_socket_domain io_socket_type io_socket_proto );
  
      return wantarray ? ($new, $peer)
      	      	     : $new;
  }
  
  sub sockname {
      @_ == 1 or croak 'usage: $sock->sockname()';
      getsockname($_[0]);
  }
  
  sub peername {
      @_ == 1 or croak 'usage: $sock->peername()';
      my($sock) = @_;
      ${*$sock}{'io_socket_peername'} ||= getpeername($sock);
  }
  
  sub connected {
      @_ == 1 or croak 'usage: $sock->connected()';
      my($sock) = @_;
      getpeername($sock);
  }
  
  sub send {
      @_ >= 2 && @_ <= 4 or croak 'usage: $sock->send(BUF, [FLAGS, [TO]])';
      my $sock  = $_[0];
      my $flags = $_[2] || 0;
      my $peer;
  
      if ($_[3]) {
          # the caller explicitly requested a TO, so use it
          # this is non-portable for "connected" UDP sockets
          $peer = $_[3];
      }
      elsif (!defined getpeername($sock)) {
          # we're not connected, so we require a peer from somewhere
          $peer = $sock->peername;
  
  	croak 'send: Cannot determine peer address'
  	    unless(defined $peer);
      }
  
      my $r = $peer
        ? send($sock, $_[1], $flags, $peer)
        : send($sock, $_[1], $flags);
  
      # remember who we send to, if it was successful
      ${*$sock}{'io_socket_peername'} = $peer
  	if(@_ == 4 && defined $r);
  
      $r;
  }
  
  sub recv {
      @_ == 3 || @_ == 4 or croak 'usage: $sock->recv(BUF, LEN [, FLAGS])';
      my $sock  = $_[0];
      my $len   = $_[2];
      my $flags = $_[3] || 0;
  
      # remember who we recv'd from
      ${*$sock}{'io_socket_peername'} = recv($sock, $_[1]='', $len, $flags);
  }
  
  sub shutdown {
      @_ == 2 or croak 'usage: $sock->shutdown(HOW)';
      my($sock, $how) = @_;
      ${*$sock}{'io_socket_peername'} = undef;
      shutdown($sock, $how);
  }
  
  sub setsockopt {
      @_ == 4 or croak '$sock->setsockopt(LEVEL, OPTNAME, OPTVAL)';
      setsockopt($_[0],$_[1],$_[2],$_[3]);
  }
  
  my $intsize = length(pack("i",0));
  
  sub getsockopt {
      @_ == 3 or croak '$sock->getsockopt(LEVEL, OPTNAME)';
      my $r = getsockopt($_[0],$_[1],$_[2]);
      # Just a guess
      $r = unpack("i", $r)
  	if(defined $r && length($r) == $intsize);
      $r;
  }
  
  sub sockopt {
      my $sock = shift;
      @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)
  	    : $sock->setsockopt(SOL_SOCKET,@_);
  }
  
  sub atmark {
      @_ == 1 or croak 'usage: $sock->atmark()';
      my($sock) = @_;
      sockatmark($sock);
  }
  
  sub timeout {
      @_ == 1 || @_ == 2 or croak 'usage: $sock->timeout([VALUE])';
      my($sock,$val) = @_;
      my $r = ${*$sock}{'io_socket_timeout'};
  
      ${*$sock}{'io_socket_timeout'} = defined $val ? 0 + $val : $val
  	if(@_ == 2);
  
      $r;
  }
  
  sub sockdomain {
      @_ == 1 or croak 'usage: $sock->sockdomain()';
      my $sock = shift;
      if (!defined(${*$sock}{'io_socket_domain'})) {
  	my $addr = $sock->sockname();
  	${*$sock}{'io_socket_domain'} = sockaddr_family($addr)
  	    if (defined($addr));
      }
      ${*$sock}{'io_socket_domain'};
  }
  
  sub socktype {
      @_ == 1 or croak 'usage: $sock->socktype()';
      my $sock = shift;
      ${*$sock}{'io_socket_type'} = $sock->sockopt(Socket::SO_TYPE)
  	if (!defined(${*$sock}{'io_socket_type'}) && defined(eval{Socket::SO_TYPE}));
      ${*$sock}{'io_socket_type'}
  }
  
  sub protocol {
      @_ == 1 or croak 'usage: $sock->protocol()';
      my($sock) = @_;
      ${*$sock}{'io_socket_proto'} = $sock->sockopt(Socket::SO_PROTOCOL)
  	if (!defined(${*$sock}{'io_socket_proto'}) && defined(eval{Socket::SO_PROTOCOL}));
      ${*$sock}{'io_socket_proto'};
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket - Object interface to socket communications
  
  =head1 SYNOPSIS
  
      use strict;
      use warnings;
  
      use IO::Socket qw(AF_INET AF_UNIX);
  
      # create a new AF_INET socket
      my $sock = IO::Socket->new(Domain => AF_INET);
      # which is the same as
      $sock = IO::Socket::INET->new();
  
      # create a new AF_UNIX socket
      $sock = IO::Socket->new(Domain => AF_UNIX);
      # which is the same as
      $sock = IO::Socket::UNIX->new();
  
  =head1 DESCRIPTION
  
  C<IO::Socket> provides an object-oriented, L<IO::Handle>-based interface to
  creating and using sockets via L<Socket>, which provides a near one-to-one
  interface to the C socket library.
  
  C<IO::Socket> is a base class that really only defines methods for those
  operations which are common to all types of sockets. Operations which are
  specific to a particular socket domain have methods defined in subclasses of
  C<IO::Socket>. See L<IO::Socket::INET>, L<IO::Socket::UNIX>, and
  L<IO::Socket::IP> for examples of such a subclass.
  
  C<IO::Socket> will export all functions (and constants) defined by L<Socket>.
  
  =head1 CONSTRUCTOR ARGUMENTS
  
  Given that C<IO::Socket> doesn't have attributes in the traditional sense, the
  following arguments, rather than attributes, can be passed into the
  constructor.
  
  Constructor arguments should be passed in C<< Key => 'Value' >> pairs.
  
  The only required argument is L<IO::Socket/"Domain">.
  
  =head2 Blocking
  
      my $sock = IO::Socket->new(..., Blocking => 1);
      $sock = IO::Socket->new(..., Blocking => 0);
  
  If defined but false, the socket will be set to non-blocking mode. If not
  specified it defaults to C<1> (blocking mode).
  
  =head2 Domain
  
      my $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
  The socket domain will define which subclass of C<IO::Socket> to use. The two
  options available along with this distribution are C<AF_INET> and C<AF_UNIX>.
  
  C<AF_INET> is for the internet address family of sockets and is handled via
  L<IO::Socket::INET>. C<AF_INET> sockets are bound to an internet address and
  port.
  
  C<AF_UNIX> is for the unix domain socket and is handled via
  L<IO::Socket::UNIX>. C<AF_UNIX> sockets are bound to the file system as their
  address name space.
  
  This argument is B<required>. All other arguments are optional.
  
  =head2 Listen
  
      my $sock = IO::Socket->new(..., Listen => 5);
  
  Listen should be an integer value or left unset.
  
  If provided, this argument will place the socket into listening mode. New
  connections can then be accepted using the L<IO::Socket/"accept"> method. The
  value given is used as the C<listen(2)> queue size.
  
  If the C<Listen> argument is given, but false, the queue size will be set to
  5.
  
  =head2 Timeout
  
      my $sock = IO::Socket->new(..., Timeout => 5);
  
  The timeout value, in seconds, for this socket connection. How exactly this
  value is utilized is defined in the socket domain subclasses that make use of
  the value.
  
  =head2 Type
  
      my $sock = IO::Socket->new(..., Type => IO::Socket::SOCK_STREAM);
  
  The socket type that will be used. These are usually C<SOCK_STREAM>,
  C<SOCK_DGRAM>, or C<SOCK_RAW>. If this argument is left undefined an attempt
  will be made to infer the type from the service name.
  
  For example, you'll usually use C<SOCK_STREAM> with a C<tcp> connection and
  C<SOCK_DGRAM> with a C<udp> connection.
  
  =head1 CONSTRUCTORS
  
  C<IO::Socket> extends the L<IO::Handle> constructor.
  
  =head2 new
  
      my $sock = IO::Socket->new();
  
      # get a new IO::Socket::INET instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_INET);
      # get a new IO::Socket::UNIX instance
      $sock = IO::Socket->new(Domain => IO::Socket::AF_UNIX);
  
      # Domain is the only required argument
      $sock = IO::Socket->new(
          Domain => IO::Socket::AF_INET, # AF_INET, AF_UNIX
          Type => IO::Socket::SOCK_STREAM, # SOCK_STREAM, SOCK_DGRAM, ...
          Proto => 'tcp', # 'tcp', 'udp', IPPROTO_TCP, IPPROTO_UDP
          # and so on...
      );
  
  Creates an C<IO::Socket>, which is a reference to a newly created symbol (see
  the L<Symbol> package). C<new> optionally takes arguments, these arguments
  are defined in L<IO::Socket/"CONSTRUCTOR ARGUMENTS">.
  
  Any of the L<IO::Socket/"CONSTRUCTOR ARGUMENTS"> may be passed to the
  constructor, but if any arguments are provided, then one of them must be
  the L<IO::Socket/"Domain"> argument. The L<IO::Socket/"Domain"> argument can,
  by default, be either C<AF_INET> or C<AF_UNIX>. Other domains can be used if a
  proper subclass for the domain family is registered. All other arguments will
  be passed to the C<configuration> method of the package for that domain.
  
  If the constructor fails it will return C<undef> and set the C<$errstr> package
  variable to contain an error message.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket->new(...)
          or die "Cannot create socket - $@\n";
  
  =head1 METHODS
  
  C<IO::Socket> inherits all methods from L<IO::Handle> and implements the
  following new ones.
  
  =head2 accept
  
      my $client_sock = $sock->accept();
      my $inet_sock = $sock->accept('IO::Socket::INET');
  
  The accept method will perform the system call C<accept> on the socket and
  return a new object. The new object will be created in the same class as the
  listen socket, unless a specific package name is specified. This object can be
  used to communicate with the client that was trying to connect.
  
  This differs slightly from the C<accept> function in L<perlfunc>.
  
  In a scalar context the new socket is returned, or C<undef> upon
  failure. In a list context a two-element array is returned containing
  the new socket and the peer address; the list will be empty upon failure.
  
  =head2 atmark
  
      my $integer = $sock->atmark();
      # read in some data on a given socket
      my $data;
      $sock->read($data, 1024) until $sock->atmark;
  
      # or, export the function to use:
      use IO::Socket 'sockatmark';
      $sock->read($data, 1024) until sockatmark($sock);
  
  True if the socket is currently positioned at the urgent data mark, false
  otherwise. If your system doesn't yet implement C<sockatmark> this will throw
  an exception.
  
  If your system does not support C<sockatmark>, the C<use> declaration will
  fail at compile time.
  
  =head2 autoflush
  
      # by default, autoflush will be turned on when referenced
      $sock->autoflush(); # turns on autoflush
      # turn off autoflush
      $sock->autoflush(0);
      # turn on autoflush
      $sock->autoflush(1);
  
  This attribute isn't overridden from L<IO::Handle>'s implementation. However,
  since we turn it on by default, it's worth mentioning here.
  
  =head2 bind
  
      use Socket qw(pack_sockaddr_in);
      my $port = 3000;
      my $ip_address = '0.0.0.0';
      my $packed_addr = pack_sockaddr_in($port, $ip_address);
      $sock->bind($packed_addr);
  
  Binds a network address to a socket, just as C<bind(2)> does. Returns true if
  it succeeded, false otherwise. You should provide a packed address of the
  appropriate type for the socket.
  
  =head2 connected
  
      my $peer_addr = $sock->connected();
      if ($peer_addr) {
          say "We're connected to $peer_addr";
      }
  
  If the socket is in a connected state, the peer address is returned. If the
  socket is not in a connected state, C<undef> is returned.
  
  Note that this method considers a half-open TCP socket to be "in a connected
  state".  Specifically, it does not distinguish between the
  B<ESTABLISHED> and B<CLOSE-WAIT> TCP states; it returns the peer address,
  rather than C<undef>, in either case.  Thus, in general, it cannot
  be used to reliably learn whether the peer has initiated a graceful shutdown
  because in most cases (see below) the local TCP state machine remains in
  B<CLOSE-WAIT> until the local application calls L<IO::Socket/"shutdown"> or
  C<close>. Only at that point does this function return C<undef>.
  
  The "in most cases" hedge is because local TCP state machine behavior may
  depend on the peer's socket options. In particular, if the peer socket has
  C<SO_LINGER> enabled with a zero timeout, then the peer's C<close> will
  generate a C<RST> segment. Upon receipt of that segment, the local TCP
  transitions immediately to B<CLOSED>, and in that state, this method I<will>
  return C<undef>.
  
  =head2 getsockopt
  
      my $value = $sock->getsockopt(SOL_SOCKET, SO_REUSEADDR);
      my $buf = $socket->getsockopt(SOL_SOCKET, SO_RCVBUF);
      say "Receive buffer is $buf bytes";
  
  Get an option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will unpack a byte buffer
  of the correct size back into a number.
  
  =head2 listen
  
      $sock->listen(5);
  
  Does the same thing that the C<listen(2)> system call does. Returns true if it
  succeeded, false otherwise. Listens to a socket with a given queue size.
  
  =head2 peername
  
      my $sockaddr_in = $sock->peername();
  
  Returns the packed C<sockaddr> address of the other end of the socket
  connection. It calls C<getpeername>.
  
  
  =head2 protocol
  
      my $proto = $sock->protocol();
  
  Returns the number for the protocol being used on the socket, if
  known. If the protocol is unknown, as with an C<AF_UNIX> socket, zero
  is returned.
  
  =head2 recv
  
      my $buffer = "";
      my $length = 1024;
      my $flags = 0; # default. optional
      $sock->recv($buffer, $length);
      $sock->recv($buffer, $length, $flags);
  
  Similar in functionality to L<perlfunc/recv>.
  
  Receives a message on a socket. Attempts to receive C<$length> characters of
  data into C<$buffer> from the specified socket. C<$buffer> will be grown or
  shrunk to the length actually read. Takes the same flags as the system call of
  the same name. Returns the address of the sender if socket's protocol supports
  this; returns an empty string otherwise. If there's an error, returns
  C<undef>. This call is actually implemented in terms of the C<recvfrom(2)>
  system call.
  
  Flags are ORed together values, such as C<MSG_BCAST>, C<MSG_OOB>,
  C<MSG_TRUNC>. The default value for the flags is C<0>.
  
  The cached value of L<IO::Socket/"peername"> is updated with the result of
  C<recv>.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<recv> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are received. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be read.
  
  =head2 send
  
      my $message = "Hello, world!";
      my $flags = 0; # defaults to zero
      my $to = '0.0.0.0'; # optional destination
      my $sent = $sock->send($message);
      $sent = $sock->send($message, $flags);
      $sent = $sock->send($message, $flags, $to);
  
  Similar in functionality to L<perlfunc/send>.
  
  Sends a message on a socket. Attempts to send the scalar message to the
  socket. Takes the same flags as the system call of the same name. On
  unconnected sockets, you must specify a destination to send to, in which case
  it does a C<sendto(2)> syscall. Returns the number of characters sent, or
  C<undef> on error. The C<sendmsg(2)> syscall is currently unimplemented.
  
  The C<flags> option is optional and defaults to C<0>.
  
  After a successful send with C<$to>, further calls to C<send> on an
  unconnected socket without C<$to> will send to the same address, and C<$to>
  will be used as the result of L<IO::Socket/"peername">.
  
  B<Note:> In Perl v5.30 and newer, if the socket has been marked as C<:utf8>,
  C<send> will throw an exception. The C<:encoding(...)> layer implicitly
  introduces the C<:utf8> layer. See L<perlfunc/binmode>.
  
  B<Note:> In Perl versions older than v5.30, depending on the status of the
  socket, either (8-bit) bytes or characters are sent. By default all
  sockets operate on bytes, but for example if the socket has been changed
  using L<perlfunc/binmode> to operate with the C<:encoding(UTF-8)> I/O layer
  (see the L<perlfunc/open> pragma), the I/O will operate on UTF8-encoded
  Unicode characters, not bytes. Similarly for the C<:encoding> layer: in
  that case pretty much any characters can be sent.
  
  =head2 setsockopt
  
      $sock->setsockopt(SOL_SOCKET, SO_REUSEADDR, 1);
      $sock->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024);
  
  Set option associated with the socket. Levels other than C<SOL_SOCKET>
  may be specified here. As a convenience, this method will convert a number
  into a packed byte buffer.
  
  =head2 shutdown
  
      $sock->shutdown(SHUT_RD); # we stopped reading data
      $sock->shutdown(SHUT_WR); # we stopped writing data
      $sock->shutdown(SHUT_RDWR); # we stopped using this socket
  
  Shuts down a socket connection in the manner indicated by the value passed in,
  which has the same interpretation as in the syscall of the same name.
  
  This is useful with sockets when you want to tell the other side you're done
  writing but not done reading, or vice versa. It's also a more insistent form
  of C<close> because it also disables the file descriptor in any
  forked copies in other processes.
  
  Returns C<1> for success; on error, returns C<undef> if the socket is
  not a valid filehandle, or returns C<0> and sets C<$!> for any other failure.
  
  =head2 sockdomain
  
      my $domain = $sock->sockdomain();
  
  Returns the number for the socket domain type. For example, for
  an C<AF_INET> socket the value of C<&AF_INET> will be returned.
  
  =head2 socket
  
      my $sock = IO::Socket->new(); # no values given
      # now let's actually get a socket with the socket method
      # domain, type, and protocol are required
      $sock = $sock->socket(AF_INET, SOCK_STREAM, 'tcp');
  
  Opens a socket of the specified kind and returns it. Domain, type, and
  protocol are specified the same as for the syscall of the same name.
  
  =head2 socketpair
  
      my ($r, $w) = $sock->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
      ($r, $w) = IO::Socket::UNIX
          ->socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
  
  Will return a list of two sockets created (read and write), or an empty list
  on failure.
  
  Differs slightly from C<socketpair> in L<perlfunc> in that the argument list
  is a bit simpler.
  
  =head2 sockname
  
      my $packed_addr = $sock->sockname();
  
  Returns the packed C<sockaddr> address of this end of the connection. It's the
  same as C<getsockname(2)>.
  
  =head2 sockopt
  
      my $value = $sock->sockopt(SO_REUSEADDR);
      $sock->sockopt(SO_REUSEADDR, 1);
  
  Unified method to both set and get options in the C<SOL_SOCKET> level. If
  called with one argument then L<IO::Socket/"getsockopt"> is called, otherwise
  L<IO::Socket/"setsockopt"> is called.
  
  =head2 socktype
  
      my $type = $sock->socktype();
  
  Returns the number for the socket type. For example, for
  a C<SOCK_STREAM> socket the value of C<&SOCK_STREAM> will be returned.
  
  =head2 timeout
  
      my $seconds = $sock->timeout();
      my $old_val = $sock->timeout(5); # set new and return old value
  
  Set or get the timeout value (in seconds) associated with this socket.
  If called without any arguments then the current setting is returned. If
  called with an argument the current setting is changed and the previous
  value returned.
  
  This method is available to all C<IO::Socket> implementations but may or may
  not be used by the individual domain subclasses.
  
  =head1 EXAMPLES
  
  Let's create a TCP server on C<localhost:3333>.
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $server = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          Proto => 'tcp',
          LocalHost => '0.0.0.0',
          LocalPort => 3333,
          ReusePort => 1,
          Listen => 5,
      ) || die "Can't open socket: $IO::Socket::errstr";
      say "Waiting on 3333";
  
      while (1) {
          # waiting for a new client connection
          my $client = $server->accept();
  
          # get information about a newly connected client
          my $client_address = $client->peerhost();
          my $client_port = $client->peerport();
          say "Connection from $client_address:$client_port";
  
          # read up to 1024 characters from the connected client
          my $data = "";
          $client->recv($data, 1024);
          say "received data: $data";
  
          # write response data to the connected client
          $data = "ok";
          $client->send($data);
  
          # notify client that response has been sent
          $client->shutdown(SHUT_WR);
      }
  
      $server->close();
  
  A client for such a server could be
  
      use strict;
      use warnings;
      use feature 'say';
  
      use IO::Socket qw(AF_INET AF_UNIX SOCK_STREAM SHUT_WR);
  
      my $client = IO::Socket->new(
          Domain => AF_INET,
          Type => SOCK_STREAM,
          proto => 'tcp',
          PeerPort => 3333,
          PeerHost => '0.0.0.0',
      ) || die "Can't open socket: $IO::Socket::errstr";
  
      say "Sending Hello World!";
      my $size = $client->send("Hello World!");
      say "Sent data of length: $size";
  
      $client->shutdown(SHUT_WR);
  
      my $buffer;
      $client->recv($buffer, 1024);
      say "Got back $buffer";
  
      $client->close();
  
  
  =head1 LIMITATIONS
  
  On some systems, for an IO::Socket object created with C<new_from_fd>,
  or created with L<IO::Socket/"accept"> from such an object, the
  L<IO::Socket/"protocol">, L<IO::Socket/"sockdomain"> and
  L<IO::Socket/"socktype"> methods may return C<undef>.
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Handle>, L<IO::Socket::INET>, L<IO::Socket::UNIX>,
  L<IO::Socket::IP>
  
  =head1 AUTHOR
  
  Graham Barr.  atmark() by Lincoln Stein.  Currently maintained by the Perl 5
  Porters.  Please report all bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  The atmark() implementation: Copyright 2001, Lincoln Stein <lstein@cshl.org>.
  This module is distributed under the same terms as Perl itself.
  Feel free to use, modify and redistribute it as long as you retain
  the correct attribution.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/INET.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET';
  # IO::Socket::INET.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::INET;
  
  use strict;
  use IO::Socket;
  use Socket;
  use Carp;
  use Exporter;
  use Errno;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.49";
  
  my $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;
  
  IO::Socket::INET->register_domain( AF_INET );
  
  my %socket_type = ( tcp  => SOCK_STREAM,
  		    udp  => SOCK_DGRAM,
  		    icmp => SOCK_RAW
  		  );
  my %proto_number;
  $proto_number{tcp}  = Socket::IPPROTO_TCP()  if defined &Socket::IPPROTO_TCP;
  $proto_number{udp}  = Socket::IPPROTO_UDP()  if defined &Socket::IPPROTO_UDP;
  $proto_number{icmp} = Socket::IPPROTO_ICMP() if defined &Socket::IPPROTO_ICMP;
  my %proto_name = reverse %proto_number;
  
  sub new {
      my $class = shift;
      unshift(@_, "PeerAddr") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub _cache_proto {
      my @proto = @_;
      for (map lc($_), $proto[0], split(' ', $proto[1])) {
  	$proto_number{$_} = $proto[2];
      }
      $proto_name{$proto[2]} = $proto[0];
  }
  
  sub _get_proto_number {
      my $name = lc(shift);
      return undef unless defined $name;
      return $proto_number{$name} if exists $proto_number{$name};
  
      my @proto = eval { getprotobyname($name) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[2];
  }
  
  sub _get_proto_name {
      my $num = shift;
      return undef unless defined $num;
      return $proto_name{$num} if exists $proto_name{$num};
  
      my @proto = eval { getprotobynumber($num) };
      return undef unless @proto;
      _cache_proto(@proto);
  
      return $proto[0];
  }
  
  sub _sock_info {
    my($addr,$port,$proto) = @_;
    my $origport = $port;
    my @serv = ();
  
    $port = $1
  	if(defined $addr && $addr =~ s,:([\w\(\)/]+)$,,);
  
    if(defined $proto  && $proto =~ /\D/) {
      my $num = _get_proto_number($proto);
      unless (defined $num) {
        $IO::Socket::errstr = $@ = "Bad protocol '$proto'";
        return;
      }
      $proto = $num;
    }
  
    if(defined $port) {
      my $defport = ($port =~ s,\((\d+)\)$,,) ? $1 : undef;
      my $pnum = ($port =~ m,^(\d+)$,)[0];
  
      @serv = getservbyname($port, _get_proto_name($proto) || "")
  	if ($port =~ m,\D,);
  
      $port = $serv[2] || $defport || $pnum;
      unless (defined $port) {
  	$IO::Socket::errstr = $@ = "Bad service '$origport'";
  	return;
      }
  
      $proto = _get_proto_number($serv[3]) if @serv && !$proto;
    }
  
   return ($addr || undef,
  	 $port || undef,
  	 $proto || undef
  	);
  }
  
  sub _error {
      my $sock = shift;
      my $err = shift;
      {
        local($!);
        my $title = ref($sock).": ";
        $IO::Socket::errstr = $@ = join("", $_[0] =~ /^$title/ ? "" : $title, @_);
        $sock->close()
  	if(defined fileno($sock));
      }
      $! = $err;
      return undef;
  }
  
  sub _get_addr {
      my($sock,$addr_str, $multi) = @_;
      my @addr;
      if ($multi && $addr_str !~ /^\d+(?:\.\d+){3}$/) {
  	(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);
      } else {
  	my $h = inet_aton($addr_str);
  	push(@addr, $h) if defined $h;
      }
      @addr;
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($lport,$rport,$laddr,$raddr,$proto,$type);
  
  
      $arg->{LocalAddr} = $arg->{LocalHost}
  	if exists $arg->{LocalHost} && !exists $arg->{LocalAddr};
  
      ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},
  					$arg->{LocalPort},
  					$arg->{Proto})
  			or return _error($sock, $!, $@);
  
      $laddr = defined $laddr ? inet_aton($laddr)
  			    : INADDR_ANY;
  
      return _error($sock, $EINVAL, "Bad hostname '",$arg->{LocalAddr},"'")
  	unless(defined $laddr);
  
      $arg->{PeerAddr} = $arg->{PeerHost}
  	if exists $arg->{PeerHost} && !exists $arg->{PeerAddr};
  
      unless(exists $arg->{Listen}) {
  	($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},
  					    $arg->{PeerPort},
  					    $proto)
  			or return _error($sock, $!, $@);
      }
  
      $proto ||= _get_proto_number('tcp');
  
      $type = $arg->{Type} || $socket_type{lc _get_proto_name($proto)};
  
      my @raddr = ();
  
      if(defined $raddr) {
  	@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless @raddr;
      }
  
      while(1) {
  
  	$sock->socket(AF_INET, $type, $proto) or
  	    return _error($sock, $!, "$!");
  
          if (defined $arg->{Blocking}) {
  	    defined $sock->blocking($arg->{Blocking})
  		or return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Reuse} || $arg->{ReuseAddr}) {
  	    $sock->sockopt(SO_REUSEADDR,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{ReusePort}) {
  	    $sock->sockopt(SO_REUSEPORT,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if ($arg->{Broadcast}) {
  		$sock->sockopt(SO_BROADCAST,1) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {
  	    $sock->bind($lport || 0, $laddr) or
  		    return _error($sock, $!, "$!");
  	}
  
  	if(exists $arg->{Listen}) {
  	    $sock->listen($arg->{Listen} || 5) or
  		return _error($sock, $!, "$!");
  	    last;
  	}
  
   	# don't try to connect unless we're given a PeerAddr
   	last unless exists($arg->{PeerAddr});
   
          $raddr = shift @raddr;
  
  	return _error($sock, $EINVAL, 'Cannot determine remote port')
  		unless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);
  
  	last
  	    unless($type == SOCK_STREAM || defined $raddr);
  
  	return _error($sock, $EINVAL, "Bad hostname '",$arg->{PeerAddr},"'")
  	    unless defined $raddr;
  
  #        my $timeout = ${*$sock}{'io_socket_timeout'};
  #        my $before = time() if $timeout;
  
  	undef $@;
          if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {
  #            ${*$sock}{'io_socket_timeout'} = $timeout;
              return $sock;
          }
  
  	return _error($sock, $!, $@ || "Timeout")
  	    unless @raddr;
  
  #	if ($timeout) {
  #	    my $new_timeout = $timeout - (time() - $before);
  #	    return _error($sock,
  #                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),
  #                         "Timeout") if $new_timeout <= 0;
  #	    ${*$sock}{'io_socket_timeout'} = $new_timeout;
  #        }
  
      }
  
      $sock;
  }
  
  sub connect {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));
  }
  
  sub bind {
      @_ == 2 || @_ == 3 or
         croak 'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)';
      my $sock = shift;
      return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))
  }
  
  sub sockaddr {
      @_ == 1 or croak 'usage: $sock->sockaddr()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub sockport {
      @_ == 1 or croak 'usage: $sock->sockport()';
      my($sock) = @_;
      my $name = $sock->sockname;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub sockhost {
      @_ == 1 or croak 'usage: $sock->sockhost()';
      my($sock) = @_;
      my $addr = $sock->sockaddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  sub peeraddr {
      @_ == 1 or croak 'usage: $sock->peeraddr()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[1] : undef;
  }
  
  sub peerport {
      @_ == 1 or croak 'usage: $sock->peerport()';
      my($sock) = @_;
      my $name = $sock->peername;
      $name ? (sockaddr_in($name))[0] : undef;
  }
  
  sub peerhost {
      @_ == 1 or croak 'usage: $sock->peerhost()';
      my($sock) = @_;
      my $addr = $sock->peeraddr;
      $addr ? inet_ntoa($addr) : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::Socket::INET - Object interface for AF_INET domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::INET;
  
  =head1 DESCRIPTION
  
  C<IO::Socket::INET> provides an object interface to creating and using sockets
  in the AF_INET domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::INET> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::INET> provides.
  
  
   PeerAddr    Remote host address          <hostname>[:<port>]
   PeerHost    Synonym for PeerAddr
   PeerPort    Remote port or service       <service>[(<no>)] | <no>
   LocalAddr   Local host bind address      hostname[:port]
   LocalHost   Synonym for LocalAddr
   LocalPort   Local host bind port         <service>[(<no>)] | <no>
   Proto       Protocol name (or number)    "tcp" | "udp" | ...
   Type        Socket type              SOCK_STREAM | SOCK_DGRAM | ...
   Listen      Queue size for listen
   ReuseAddr   Set SO_REUSEADDR before binding
   Reuse       Set SO_REUSEADDR before binding (deprecated,
                                                prefer ReuseAddr)
   ReusePort   Set SO_REUSEPORT before binding
   Broadcast   Set SO_BROADCAST before binding
   Timeout     Timeout value for various operations
   MultiHomed  Try all addresses for multi-homed hosts
   Blocking    Determine if connection will be blocking mode
  
  If C<Listen> is defined then a listen socket is created, else if the
  socket type, which is derived from the protocol, is SOCK_STREAM then
  connect() is called.  If the C<Listen> argument is given, but false,
  the queue size will be set to 5.
  
  Although it is not illegal, the use of C<MultiHomed> on a socket
  which is in non-blocking mode is of little use. This is because the
  first connect will never fail with a timeout as the connect call
  will not block.
  
  The C<PeerAddr> can be a hostname or the IP-address on the
  "xx.xx.xx.xx" form.  The C<PeerPort> can be a number or a symbolic
  service name.  The service name might be followed by a number in
  parenthesis which is used if the service is not known by the system.
  The C<PeerPort> specification can also be embedded in the C<PeerAddr>
  by preceding it with a ":".
  
  If C<Proto> is not given and you specify a symbolic C<PeerPort> port,
  then the constructor will try to derive C<Proto> from the service
  name.  As a last resort C<Proto> "tcp" is assumed.  The C<Type>
  parameter will be deduced from C<Proto> if not specified.
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<PeerAddr> specification.
  
  If C<Blocking> is set to 0, the connection will be in nonblocking mode.
  If not specified it defaults to 1 (blocking mode).
  
  Examples:
  
     $sock = IO::Socket::INET->new(PeerAddr => 'www.perl.org',
                                   PeerPort => 'http(80)',
                                   Proto    => 'tcp');
  
     $sock = IO::Socket::INET->new(PeerAddr => 'localhost:smtp(25)');
  
     $sock = IO::Socket::INET->new(Listen    => 5,
                                   LocalAddr => 'localhost',
                                   LocalPort => 9000,
                                   Proto     => 'tcp');
  
     $sock = IO::Socket::INET->new('127.0.0.1:25');
  
     $sock = IO::Socket::INET->new(
                             PeerPort  => 9999,
                             PeerAddr  => inet_ntoa(INADDR_BROADCAST),
                             Proto     => 'udp',
                             LocalAddr => 'localhost',
                             Broadcast => 1 ) 
                         or die "Can't bind : $IO::Socket::errstr\n";
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::INET->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head2 METHODS
  
  =over 4
  
  =item sockaddr ()
  
  Return the address part of the sockaddr structure for the socket
  
  =item sockport ()
  
  Return the port number that the socket is using on the local host
  
  =item sockhost ()
  
  Return the address part of the sockaddr structure for the socket in a
  text form xx.xx.xx.xx
  
  =item peeraddr ()
  
  Return the address part of the sockaddr structure for the socket on
  the peer host
  
  =item peerport ()
  
  Return the port number for the socket on the peer host.
  
  =item peerhost ()
  
  Return the address part of the sockaddr structure for the socket on the
  peer host in a text form xx.xx.xx.xx
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_INET

$fatpacked{"x86_64-linux-gnu-thread-multi/IO/Socket/UNIX.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX';
  # IO::Socket::UNIX.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package IO::Socket::UNIX;
  
  use strict;
  use IO::Socket;
  use Carp;
  
  our @ISA = qw(IO::Socket);
  our $VERSION = "1.49";
  
  IO::Socket::UNIX->register_domain( AF_UNIX );
  
  sub new {
      my $class = shift;
      unshift(@_, "Peer") if @_ == 1;
      return $class->SUPER::new(@_);
  }
  
  sub configure {
      my($sock,$arg) = @_;
      my($bport,$cport);
  
      my $type = $arg->{Type} || SOCK_STREAM;
  
      $sock->socket(AF_UNIX, $type, 0) or
  	return undef;
  
      if(exists $arg->{Blocking}) {
          $sock->blocking($arg->{Blocking}) or
  	    return undef;
      }
      if(exists $arg->{Local}) {
  	my $addr = sockaddr_un($arg->{Local});
  	$sock->bind($addr) or
  	    return undef;
      }
      if(exists $arg->{Listen} && $type != SOCK_DGRAM) {
  	$sock->listen($arg->{Listen} || 5) or
  	    return undef;
      }
      elsif(exists $arg->{Peer}) {
  	my $addr = sockaddr_un($arg->{Peer});
  	$sock->connect($addr) or
  	    return undef;
      }
  
      $sock;
  }
  
  sub hostpath {
      @_ == 1 or croak 'usage: $sock->hostpath()';
      my $n = $_[0]->sockname || return undef;
      (sockaddr_un($n))[0];
  }
  
  sub peerpath {
      @_ == 1 or croak 'usage: $sock->peerpath()';
      my $n = $_[0]->peername || return undef;
      (sockaddr_un($n))[0];
  }
  
  1; # Keep require happy
  
  __END__
  
  =head1 NAME
  
  IO::Socket::UNIX - Object interface for AF_UNIX domain sockets
  
  =head1 SYNOPSIS
  
      use IO::Socket::UNIX;
  
      my $SOCK_PATH = "$ENV{HOME}/unix-domain-socket-test.sock";
  
      # Server:
      my $server = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Local => $SOCK_PATH,
          Listen => 1,
      );
  
      my $count = 1;
      while (my $conn = $server->accept()) {
          $conn->print("Hello " . ($count++) . "\n");
      }
  
      # Client:
      my $client = IO::Socket::UNIX->new(
          Type => SOCK_STREAM(),
          Peer => $SOCK_PATH,
      );
  
      # Now read and write from $client
  
  =head1 DESCRIPTION
  
  C<IO::Socket::UNIX> provides an object interface to creating and using sockets
  in the AF_UNIX domain. It is built upon the L<IO::Socket> interface and
  inherits all the methods defined by L<IO::Socket>.
  
  =head1 CONSTRUCTOR
  
  =over 4
  
  =item new ( [ARGS] )
  
  Creates an C<IO::Socket::UNIX> object, which is a reference to a
  newly created symbol (see the C<Symbol> package). C<new>
  optionally takes arguments, these arguments are in key-value pairs.
  
  In addition to the key-value pairs accepted by L<IO::Socket>,
  C<IO::Socket::UNIX> provides.
  
      Type    	Type of socket (eg SOCK_STREAM or SOCK_DGRAM)
      Local   	Path to local fifo
      Peer    	Path to peer fifo
      Listen  	Queue size for listen
  
  If the constructor is only passed a single argument, it is assumed to
  be a C<Peer> specification.
  
  If the C<Listen> argument is given, but false, the queue size will be set to 5.
  
  If the constructor fails it will return C<undef> and set the
  C<$IO::Socket::errstr> package variable to contain an error message.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $IO::Socket::errstr\n";
  
  For legacy reasons the error message is also set into the global C<$@>
  variable, and you may still find older code which looks here instead.
  
      $sock = IO::Socket::UNIX->new(...)
          or die "Cannot create socket - $@\n";
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item hostpath()
  
  Returns the pathname to the fifo at the local end
  
  =item peerpath()
  
  Returns the pathanme to the fifo at the peer end
  
  =back
  
  =head1 SEE ALSO
  
  L<Socket>, L<IO::Socket>
  
  =head1 AUTHOR
  
  Graham Barr. Currently maintained by the Perl Porters.  Please report all
  bugs at L<https://github.com/Perl/perl5/issues>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_IO_SOCKET_UNIX

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce reductions sum sum0
    sample shuffle uniq uniqint uniqnum uniqstr zip zip_longest zip_shortest mesh mesh_longest mesh_shortest
    head tail pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.63";
  our $XS_VERSION = $VERSION;
  $VERSION =~ tr/_//d;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  # Used by shuffle()
  our $RAND;
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  sub List::Util::_Pair::TO_JSON { [ @{+shift} ] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first reductions
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqint uniqnum uniqstr zip mesh
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all apply a given block of code to a list of
  values.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The other scalar-returning list reduction functions are all specialisations of
  this generic idea.
  
  =head2 reductions
  
      @results = reductions { BLOCK } @list
  
  I<Since version 1.54.>
  
  Similar to C<reduce> except that it also returns the intermediate values along
  with the final result. As before, C<$a> is set to the first element of the
  given list, and the C<BLOCK> is then called once for remaining item in the
  list set into C<$b>, with the result being captured for return as well as
  becoming the new value for C<$a>.
  
  The returned list will begin with the initial value for C<$a>, followed by
  each return value from the block in order. The final value of the result will
  be identical to what the C<reduce> function would have returned given the same
  block and list.
  
      reduce     { "$a-$b" }  "a".."d"    # "a-b-c-d"
      reductions { "$a-$b" }  "a".."d"    # "a", "a-b", "a-b-c", "a-b-c-d"
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  Since version C<1.51> they also have a C<TO_JSON> method to ease
  serialisation.
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  This function is affected by the C<$RAND> variable.
  
  =cut
  
  =head2 sample
  
      my @items = sample $count, @values
  
  I<Since version 1.54.>
  
  Randomly select the given number of elements from the input list. Any given
  position in the input list will be selected at most once.
  
  If there are fewer than C<$count> items in the list then the function will
  return once all of them have been randomly selected; effectively the function
  behaves similarly to L</shuffle>.
  
  This function is affected by the C<$RAND> variable.
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqint
  
      my @subset = uniqint @values
  
  I<Since version 1.55.>
  
  Filters a list of values to remove subsequent duplicates, as judged by an
  integer numerical equality test. Preserves the order of unique elements, and
  retains the first value of any duplicate set. Values in the returned list will
  be coerced into integers.
  
      my $count = uniqint @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqint> are well-behaved as integers.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head2 head
  
      my @values = head $size, @list;
  
  I<Since version 1.50.>
  
  Returns the first C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the last C<$size> elements from C<@list>.
  
      @result = head 2, qw( foo bar baz );
      # foo, bar
  
      @result = head -2, qw( foo bar baz );
      # foo
  
  =head2 tail
  
      my @values = tail $size, @list;
  
  I<Since version 1.50.>
  
  Returns the last C<$size> elements from C<@list>. If C<$size> is negative, returns
  all but the first C<$size> elements from C<@list>.
  
      @result = tail 2, qw( foo bar baz );
      # bar, baz
  
      @result = tail -2, qw( foo bar baz );
      # baz
  
  =head2 zip
  
      my @result = zip [1..3], ['a'..'c'];
      # [1, 'a'], [2, 'b'], [3, 'c']
  
  I<Since version 1.56.>
  
  Returns a list of array references, composed of elements from the given list
  of array references. Each array in the returned list is composed of elements
  at that corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  The C<zip> function is particularly handy for iterating over multiple arrays
  at the same time with a C<foreach> loop, taking one element from each:
  
      foreach ( zip \@xs, \@ys, \@zs ) {
          my ($x, $y, $z) = @$_;
          ...
      }
  
  B<NOTE> to users of L<List::MoreUtils>: This function does not behave the same
  as C<List::MoreUtils::zip>, but is actually a non-prototyped equivalent to
  C<List::MoreUtils::zip_unflatten>. This function does not apply a prototype,
  so make sure to invoke it with references to arrays.
  
  For a function similar to the C<zip> function from C<List::MoreUtils>, see
  L<mesh>.
  
      my @result = zip_shortest ...
  
  A variation of the function that differs in how it behaves when given input
  arrays of differing lengths. C<zip_shortest> will stop as soon as any one of
  the input arrays run out of elements, discarding any remaining unused values
  from the others.
  
      my @result = zip_longest ...
  
  C<zip_longest> is an alias to the C<zip> function, provided simply to be
  explicit about that behaviour as compared to C<zip_shortest>.
  
  =head2 mesh
  
      my @result = mesh [1..3], ['a'..'c'];
      # (1, 'a', 2, 'b', 3, 'c')
  
  I<Since version 1.56.>
  
  Returns a list of items collected from elements of the given list of array
  references. Each section of items in the returned list is composed of elements
  at the corresponding position from each of the given input arrays. If any
  input arrays run out of elements before others, then C<undef> will be inserted
  into the result to fill in the gaps.
  
  This is similar to L<zip>, except that all of the ranges in the result are
  returned in one long flattened list, instead of being bundled into separate
  arrays.
  
  Because it returns a flat list of items, the C<mesh> function is particularly
  useful for building a hash out of two separate arrays of keys and values:
  
      my %hash = mesh \@keys, \@values;
  
      my $href = { mesh \@keys, \@values };
  
  B<NOTE> to users of L<List::MoreUtils>: This function is a non-prototyped
  equivalent to C<List::MoreUtils::mesh> or C<List::MoreUtils::zip> (themselves
  aliases of each other). This function does not apply a prototype, so make sure
  to invoke it with references to arrays.
  
      my @result = mesh_shortest ...
  
      my @result = mesh_longest ...
  
  These variations are similar to those of L<zip>, in that they differ in
  behaviour when one of the input lists runs out of elements before the others.
  
  =head1 CONFIGURATION VARIABLES
  
  =head2 $RAND
  
      local $List::Util::RAND = sub { ... };
  
  I<Since version 1.54.>
  
  This package variable is used by code which needs to generate random numbers
  (such as the L</shuffle> and L</sample> functions). If set to a CODE reference
  it provides an alternative to perl's builtin C<rand()> function. When a new
  random number is needed this function will be invoked with no arguments and is
  expected to return a floating-point value, of which only the fractional part
  will be used.
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.63";       # FIXUP
  $VERSION =~ tr/_//d;         # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_LIST_UTIL_XS

$fatpacked{"x86_64-linux-gnu-thread-multi/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  # populating @EXPORT_FAIL is done in the XS code
  sub export_fail {
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in this version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =head2 Core Perl C<builtin> Functions
  
  Many functions in this module have served as the inspiration for a new
  experimental facility in recent versions of Perl. From various development
  versions, starting at 5.35.7, equivalent functions to many of these utilities
  are available in the C<builtin::> package.
  
      use Scalar::Util qw(blessed);
  
      $class = blessed $obj;
  
      $class = builtin::blessed $obj;  # equivalent
  
  For more information, see the documentation on L<builtin>.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::blessed>.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::refaddr>.
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  Note that for internal reasons, all precompiled regexps (C<qr/.../>) are
  blessed references; thus C<ref()> returns the package name string C<"Regexp">
  on these but C<reftype()> will return the underlying C structure type of
  C<"REGEXP"> in all capitals.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::reftype>.
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::weaken>.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::unweaken>.
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  I<Since Perl version 5.35.7> an equivalent function is available as
  C<builtin::is_weak>.
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  standard operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  The C<$!> variable is commonly dual-valued, though it is also magical in other
  ways:
  
      $! = 1;
      $dual = isdual($!);                 # true
      print("$!\n");                      # "Operation not permitted"
  
  B<CAUTION>: This function is not as useful as it may seem. Dualvars are not a
  distinct concept in Perl, but a standard internal construct of all scalar
  values. Almost any value could be considered as a dualvar by this function
  through the course of normal operations.
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself, if C<$fh> may be used as a filehandle and is open, or if
  it is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Vstrings are not implemented in this version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX-GNU-THREAD-MULTI_SCALAR_UTIL

$fatpacked{"x86_64-linux-gnu-thread-multi/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.63";
  $VERSION =~ tr/_//d;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If the package the code was compiled in has been deleted
  (e.g. using C<delete_package> from L<Symbol>), C<__ANON__> will be returned as
  the package name. If a name has been set using L</set_subname>, this name will be
  returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.*?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX-GNU-THREAD-MULTI_SUB_UTIL

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use v5.32;
use IPC::Run qw(run);

my $log = 'ctx-switch.log';
run ["./A"], '>>', $log, '&', ["./B"], '>>', $log;
